{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/aircloud/source/css/aircloud.css","path":"css/aircloud.css","modified":1,"renderable":1},{"_id":"themes/aircloud/source/css/aircloud.css.map","path":"css/aircloud.css.map","modified":1,"renderable":1},{"_id":"themes/aircloud/source/css/aircloud.less","path":"css/aircloud.less","modified":1,"renderable":1},{"_id":"themes/aircloud/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/aircloud/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"themes/aircloud/source/js/index.js","path":"js/index.js","modified":1,"renderable":1},{"_id":"source/img/1.jpg","path":"img/1.jpg","modified":1,"renderable":0},{"_id":"source/img/2.jpg","path":"img/2.jpg","modified":1,"renderable":0},{"_id":"source/img/3.jpg","path":"img/3.jpg","modified":1,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/img/cv1.jpg","path":"img/cv1.jpg","modified":1,"renderable":0},{"_id":"source/img/donate.jpg","path":"img/donate.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":0},{"_id":"source/img/kd.jpg","path":"img/kd.jpg","modified":1,"renderable":0},{"_id":"source/img/kds.jpg","path":"img/kds.jpg","modified":1,"renderable":0},{"_id":"source/img/ker1.jpg","path":"img/ker1.jpg","modified":1,"renderable":0},{"_id":"source/img/logo.png","path":"img/logo.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/about/index.md","hash":"4cb16c49858557c804bc1c052cfe31afe619b5ec","modified":1640224270333},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1640224270320},{"_id":"source/_posts/Deno 是如何运行 TypeScript 的.md","hash":"eed598e22f05dd39d4576b7a4ca2660d15fb67a7","modified":1640224270322},{"_id":"source/_posts/CentOS7下安装和配置redis.md","hash":"e53a5b4afd3d90f715a8b9030c4a986e5344e06a","modified":1640224270321},{"_id":"source/_posts/CentOS安装node8-x版本.md","hash":"776b542ec2cae546a2361b0e40af4afa00381678","modified":1640224270321},{"_id":"source/_posts/JS的静态作用域、子程序引用环境与参数传递类型.md","hash":"ba283c07507ab0590027cd2c74eac852273cb114","modified":1640224270322},{"_id":"source/_posts/Linux服务器初始化设置用户和ssh公私钥登陆.md","hash":"a44d6e0fc9bc3e4e6dd8aa154ca16e5b5c351ec6","modified":1640224270323},{"_id":"source/_posts/Node-js的TCP链接管理.md","hash":"b1aa03cc318da116e7a98a1d4d758323a0bf120a","modified":1640224270323},{"_id":"source/_posts/PWA实践-serviceWorker生命周期、请求代理与通信.md","hash":"adeb78666ec3b904327a7da642d97e1aa7bc47a8","modified":1640224270324},{"_id":"source/_posts/github_blog.md","hash":"6d7120a587a9a2c31cdb0d9d1f403620b5b9b644","modified":1640238592847},{"_id":"source/_posts/Rust初探-实现二叉树的增删与遍历.md","hash":"571c389e7d053169386e96f4927815e09798e631","modified":1640224270324},{"_id":"source/_posts/centOS7-2搭建nginx环境以及负载均衡.md","hash":"85d4aab9a1f6ed11ce61361ef9717d610ef9a29f","modified":1640224270324},{"_id":"source/_posts/qlc解决了什么问题.md","hash":"a6c5884ed9e4cd8c14481b5cc31d2c680c309fa0","modified":1640224270326},{"_id":"source/_posts/dva源码解读.md","hash":"0201515818b0804b834493745f8d9ef1226998cb","modified":1640224270325},{"_id":"source/_posts/web应用开发与部署——你必须掌握的内容.md","hash":"512d25b866c6d546aa9bf158f2ae4fc6dd44b4a2","modified":1640224270326},{"_id":"source/_posts/web跨端融合方案浅析.md","hash":"3bb883e9490f435e603a8f1f0ebf03ff08b8514a","modified":1640224270327},{"_id":"source/_posts/一些性能相关的 JavaScript 代码编写建议规范.md","hash":"385799f3ec03a2d0a25c4b0f061ffbaf56a485a7","modified":1640224270327},{"_id":"source/_posts/一篇关于react历史的流水账.md","hash":"21a4019d075e69e30ffc1e5ed22821620651169e","modified":1640224270327},{"_id":"source/_posts/使用 Node.js 打造多用户实时监控系统.md","hash":"3b2bd4019718174d8a3fce05c7cb3c52a0f9910a","modified":1640224270328},{"_id":"source/_posts/从源码分析sentry的错误信息收集.md","hash":"7358596ed8d590b0fee479f81826b184fd32a56d","modified":1640224270328},{"_id":"source/_posts/使用OpenCV实现简单的人脸识别程序.md","hash":"d7d1d66044152805a231b4f8cbacc73c06b52836","modified":1640224270329},{"_id":"source/_posts/使用RustWebAssembly0拷贝进行计算加速.md","hash":"04c1c65ea8e0935e6e9ac2a2355d6edbce83e129","modified":1640224270329},{"_id":"source/_posts/入门WebAssembly以及使用其进行图像卷积处理.md","hash":"9a7267f266cb01240016a713f465e540985a9500","modified":1640224270329},{"_id":"source/_posts/十条编写优化的JavaScript代码的建议.md","hash":"2ada7d41fff98ea1a80eb8601fdb7b5448d8c5d7","modified":1640224270330},{"_id":"source/_posts/多组件单页列表应用的代码组织实践.md","hash":"444ab2e467431ed018c752b7cb301f33d7f0ac05","modified":1640224270330},{"_id":"source/_posts/如何让你的精力更多的用于提高技术深度.md","hash":"6b48c1f85a924e23daefb001cf49ef844444247c","modified":1640224270330},{"_id":"source/_posts/构建利用Proxy和Reflect实现双向数据绑定的微框架.md","hash":"e9cdaaacbf7f265262cc9ad527716ca8b32573eb","modified":1640224270331},{"_id":"source/_posts/浅谈前端中的二进制数据类型.md","hash":"750120163d9eee8ed821ced7e47c043bbfa6b537","modified":1640224270331},{"_id":"source/_posts/深入Vue源代码解决时序问题一.md","hash":"d4cacd38879d566c964163e2ac58f8013f7e11a6","modified":1640224270331},{"_id":"source/_posts/深入浏览器web渲染与优化-续.md","hash":"917308065bce9eada9020f3122f1a24d8cf0c7e5","modified":1640224270332},{"_id":"source/_posts/深入浏览器web渲染与优化.md","hash":"4d8b47d007a6f60f31bcf7f795f395d05989e87c","modified":1640224270332},{"_id":"source/_posts/腾讯云北美服务器搭建ShadowSocks代理.md","hash":"4eda1931844f13433d0f40b0df5ede73bec9a68f","modified":1640224270332},{"_id":"source/img/2.jpg","hash":"2f5b0345c366a264ed5b685e464a84e592ac0017","modified":1640224270335},{"_id":"source/img/cv1.jpg","hash":"2160c839498ddf205bdbeb0d612da9338fc39500","modified":1640224270340},{"_id":"source/img/favicon.ico","hash":"1ab283284297821bf37dccc6308dbe0a68545d73","modified":1640173430249},{"_id":"source/tags/index.md","hash":"4e3dfcd992b0772a4b8b034fe41ead1cc7ce9903","modified":1640224270364},{"_id":"source/img/1.jpg","hash":"f667d88d44741ff7b92ee9db5f1994bbcc05311c","modified":1640224270334},{"_id":"source/img/ker1.jpg","hash":"708e619ae0ad4524c41665f9930d3b8240d9ddcd","modified":1640224270364},{"_id":"source/img/3.jpg","hash":"2de0cbd6ef6695f024865eb614e849641d369b87","modified":1640224270337},{"_id":"source/img/avatar.jpg","hash":"5304e3982426a771746874abc1e70bc93261e197","modified":1640224270340},{"_id":"source/img/kds.jpg","hash":"70558c28dbc717528049673f7653804596e45fde","modified":1640224270363},{"_id":"source/img/logo.png","hash":"73c51450346d9f14235282b8881dc0c2869c3aa9","modified":1640173374280},{"_id":"themes/aircloud/layout/catagory.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640225152558},{"_id":"themes/aircloud/layout/page.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640225152559},{"_id":"themes/aircloud/source/_less/about.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640225152560},{"_id":"themes/aircloud/source/_less/about.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640225152560},{"_id":"themes/aircloud/source/_less/diff.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640225152561},{"_id":"themes/aircloud/source/_less/diff.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640225152561},{"_id":"themes/aircloud/source/_less/page.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640225152563},{"_id":"themes/aircloud/source/_less/page.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640225152564},{"_id":"themes/aircloud/source/_less/theme.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640225152564},{"_id":"themes/aircloud/source/_less/theme.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640225152565},{"_id":"themes/aircloud/LICENSE","hash":"218b4bf797149a2751a015812a9adefe368185c1","modified":1640225152556},{"_id":"themes/aircloud/_config.yml","hash":"0ad3a6ab2c9bb07fb1e030052622fdcde5c6f28a","modified":1640225152556},{"_id":"themes/aircloud/readme-en.md","hash":"26ea5c998b0c1f1947fbae5313b722bcf57ea7fe","modified":1640225152559},{"_id":"themes/aircloud/.DS_Store","hash":"cc02158edac4a7157941cd83b9c25376c475eff6","modified":1640225184766},{"_id":"themes/aircloud/languages/en.yml","hash":"f3dd50ca369974ac7d335fb1cfabf4ebb04a64fa","modified":1640225152556},{"_id":"themes/aircloud/readme.md","hash":"4be1fc64bd1dc335a986a39594564e89bd7eba43","modified":1640225152560},{"_id":"themes/aircloud/languages/ko.yml","hash":"c58138bcc1087201c22e996d24eb314c0447228f","modified":1640225152556},{"_id":"themes/aircloud/languages/zh.yml","hash":"9ffaff1f5d240c94e44f9ef3b02bbae146af0dd4","modified":1640225152557},{"_id":"themes/aircloud/layout/about.ejs","hash":"cec034166ce08d2f8c961178e07b2f0ceac95cf2","modified":1640225152558},{"_id":"themes/aircloud/layout/404.ejs","hash":"8a30233a7b99831bd771121b5f450aaba412e8d5","modified":1640225152557},{"_id":"themes/aircloud/layout/archive.ejs","hash":"0f8a062f4f2f0648b23bd8c4a21945a6ca60dc1f","modified":1640225152558},{"_id":"themes/aircloud/layout/index.ejs","hash":"09e2407d615be7fe7ac41d11df3b7026e7393080","modified":1640225152559},{"_id":"themes/aircloud/layout/post.ejs","hash":"2eb5fc0c2bb801528c3db3b09e6cb4d073e3ad99","modified":1640225152559},{"_id":"themes/aircloud/layout/layout.ejs","hash":"7efd113aee90e698e187d0ea1f0b42a1c00d210e","modified":1640225152559},{"_id":"themes/aircloud/layout/tags.ejs","hash":"1a174d9213d25d9bf6ef28aabdaea6661cdd88c8","modified":1640225152559},{"_id":"themes/aircloud/layout/_partial/donate.ejs","hash":"81c976a3b7fa5c47ef61181d537220eaf1d55eac","modified":1640225152557},{"_id":"themes/aircloud/source/.DS_Store","hash":"ef26bd671844af93e08d5886beb1419e10de579f","modified":1640225175543},{"_id":"themes/aircloud/layout/_partial/footer.ejs","hash":"33db88f1b03548c5181c04d44387dc68a9c4cdf6","modified":1640225152557},{"_id":"themes/aircloud/layout/_partial/head.ejs","hash":"3f18d5d4951a205bab25b08d6bf85b054c84a21b","modified":1640225152558},{"_id":"themes/aircloud/layout/_partial/nav.ejs","hash":"079fa72aa7a02ee11f6a44a8a9e58eb80fe28190","modified":1640225152558},{"_id":"themes/aircloud/layout/_partial/toc.ejs","hash":"41d11d159011466f0b6272aca9a74df8642b693f","modified":1640225152558},{"_id":"themes/aircloud/source/_less/archive.css","hash":"905efcc06a62d1e8b60df0e12434afa353378d3a","modified":1640225152561},{"_id":"themes/aircloud/source/_less/archive.less","hash":"5538d38614960e69b97a7f80f38b5933851212b8","modified":1640225152561},{"_id":"themes/aircloud/source/_less/common.css","hash":"64914aa6ecd5b948676870e0809e0f220b162e3b","modified":1640225152561},{"_id":"themes/aircloud/source/_less/common.less","hash":"8aef4d8cfdefbcd2e28d4985a4f79a5005ca0b6c","modified":1640225152561},{"_id":"themes/aircloud/source/_less/donate.less","hash":"d63139f4aa148bf894afa5c1007a4398696a0e4c","modified":1640225152562},{"_id":"themes/aircloud/source/_less/donate.css","hash":"ae6a676a42321512f0536c5230bb53084aaf2c2f","modified":1640225152561},{"_id":"themes/aircloud/source/_less/gitment.css","hash":"7d560b64e367129f98424052c660ae82b03a1d02","modified":1640225152562},{"_id":"themes/aircloud/source/_less/gitment.less","hash":"916deb8ecdee798d7a9b43b544e31dfd5bbd6de4","modified":1640225152562},{"_id":"themes/aircloud/source/_less/hightlight.css","hash":"4e5a9ec3e88fbc2ce0faabceff8d3f5099ea1012","modified":1640225152562},{"_id":"themes/aircloud/source/_less/hightlight.less","hash":"4e5a9ec3e88fbc2ce0faabceff8d3f5099ea1012","modified":1640225152562},{"_id":"themes/aircloud/source/_less/index.css","hash":"52fe4d1b93dfb4c9c9d63e24862354b6a0ef47f8","modified":1640225152562},{"_id":"themes/aircloud/source/_less/layout.css","hash":"40d7cadf42b130ea1b40de1ae73b2b00e27f476f","modified":1640225152563},{"_id":"themes/aircloud/source/_less/index.less","hash":"502d689e3568056cc27dd4da7da2499b0be4253e","modified":1640225152562},{"_id":"themes/aircloud/source/_less/layout.less","hash":"194ac7db2eeee7307fcb7470302f8172100181fb","modified":1640225152563},{"_id":"themes/aircloud/source/_less/nav.css","hash":"32e352d71dc2e67d69a26d8b5116a27d8d2a7718","modified":1640225152563},{"_id":"themes/aircloud/source/_less/post.css","hash":"9f84ce8341a2590589baa502a8d547aba3de9013","modified":1640225152564},{"_id":"themes/aircloud/source/_less/post.less","hash":"d570a036e4e8253a3edf56ac8c1def702fc72ecc","modified":1640225152564},{"_id":"themes/aircloud/source/_less/nav.less","hash":"627e33cafb4ca9c191053b10917fc21c68c6ee8c","modified":1640225152563},{"_id":"themes/aircloud/source/_less/tag.css","hash":"3250887aaae0bc62bd82082d000ce3de8cc55ab6","modified":1640225152564},{"_id":"themes/aircloud/source/_less/tag.less","hash":"47e1ce2f55e2b62beefd0f69dfe7deb594e7b309","modified":1640225152564},{"_id":"themes/aircloud/source/_less/toc.less","hash":"c873ce552b22b0aa2c51a386a91516cadf9160ba","modified":1640225152565},{"_id":"themes/aircloud/source/css/aircloud.css","hash":"3457c640068b0eeb0e7a815531b20c14765571da","modified":1640225152566},{"_id":"themes/aircloud/source/_less/toc.css","hash":"83b1a219e7fe66d9d6cc34600e5a16311381a883","modified":1640225152565},{"_id":"themes/aircloud/source/_less/variables.css","hash":"9768d38beea904c4febc704192a49c8f7ae6e06c","modified":1640225152565},{"_id":"themes/aircloud/source/css/gitment.css","hash":"926b553be983d6dd90bcb60c5d6d4ee215d268a6","modified":1640225152567},{"_id":"themes/aircloud/source/_less/variables.less","hash":"49503f7a6c51edd6f1dbdea5345df6bb903b18a5","modified":1640225152565},{"_id":"themes/aircloud/source/js/index.js","hash":"fcec9a2e4fd90a40957359d423f7f61caa712830","modified":1640225152569},{"_id":"themes/aircloud/source/css/aircloud.less","hash":"45cab2da310dbfcba37ac3db657db77b4adac60d","modified":1640225152566},{"_id":"themes/aircloud/source/css/aircloud.css.map","hash":"50db34961d11f6f461e23912609d25141068a6fc","modified":1640225152566},{"_id":"themes/aircloud/source/_less/_partial/footer.css","hash":"e00d722211b4695449d72850340ac0dd701d6ede","modified":1640225152560},{"_id":"themes/aircloud/source/_less/_partial/footer.css.map","hash":"9e8d4df5d08425de5a8b247d0dd8b805c6edc661","modified":1640225152560},{"_id":"themes/aircloud/source/_less/_partial/footer.less","hash":"d1469f97daf750f3e4be18c4d640772780c32a75","modified":1640225152560},{"_id":"themes/aircloud/source/js/gitment.js","hash":"89687f8fffe1125e08323fd6635ca4e53771c05e","modified":1640225152569},{"_id":"source/img/donate.jpg","hash":"bae2b0f605495463a161716e35884b9c8f23a7a1","modified":1640224270349},{"_id":"source/img/kd.jpg","hash":"37b74057d1c06436c4c8c1b191b86ff6593fca16","modified":1640224270358}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2021-12-23T01:51:10.320Z","updated":"2021-12-23T01:51:10.320Z","path":"404.html","title":"","comments":1,"_id":"ckxijpqs60000d3mr2skuapw1","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2021-12-23T06:48:33.000Z","comments":1,"_content":"\n>大多数时候，都在思考自己该走向何方\n\nE-mail: onlythen@yeah.net\n\nBrief：Javascript/Rust，不想做程序员的程序员，宏观经济研究者的男朋友\n\n* 2021.03.22\n\n感觉有的时候，员工打破边界对于公司来书并不是一个好事情，比如一个客户端的同学，去做 c++ 了，这个时候应该鼓励还是反对呢。实际上这个时候，他除了仅存的业务熟悉度和一些通用的编程能力，c++ 的能力也许就只有应届生的水平，如果从新招聘可能连初试都过不了。公司就必须要承担因为他的编程能力不熟练带来的效率损失，甚至因为更容易引发问题造成更大的损失。\n\n* 2020.06.23\n\n有的时候，感觉机会其实也有很多，但是自己也许在默默流失，年初的时候疫情，带来医药股票的利好，但是自己没有买，春节结束后的第一天，明明是一次风险的释放，自己却也跟着卖了一些，导致损失了收益，其实每次危机中也都蕴藏着商机，希望之后的自己，可以多进行思考。\n\n* 2020.06.01\n\n**延迟反馈：**通常，当我们收到一个用户反馈一个问题的时候，已经有很多用户遇到这个问题了，他们通常默默忍受，或者默默走掉，不做声。并且很可能包括反馈问题的人在内，都已经尝试了很多次，在他们有限的认知下实在没有办法了，才来进行反馈。我们感谢这些发声的用户的同时，也应该审视，自己是否可以更早地发现这些问题。","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2021-12-23 14:48:33\ncomments: true\n---\n\n>大多数时候，都在思考自己该走向何方\n\nE-mail: onlythen@yeah.net\n\nBrief：Javascript/Rust，不想做程序员的程序员，宏观经济研究者的男朋友\n\n* 2021.03.22\n\n感觉有的时候，员工打破边界对于公司来书并不是一个好事情，比如一个客户端的同学，去做 c++ 了，这个时候应该鼓励还是反对呢。实际上这个时候，他除了仅存的业务熟悉度和一些通用的编程能力，c++ 的能力也许就只有应届生的水平，如果从新招聘可能连初试都过不了。公司就必须要承担因为他的编程能力不熟练带来的效率损失，甚至因为更容易引发问题造成更大的损失。\n\n* 2020.06.23\n\n有的时候，感觉机会其实也有很多，但是自己也许在默默流失，年初的时候疫情，带来医药股票的利好，但是自己没有买，春节结束后的第一天，明明是一次风险的释放，自己却也跟着卖了一些，导致损失了收益，其实每次危机中也都蕴藏着商机，希望之后的自己，可以多进行思考。\n\n* 2020.06.01\n\n**延迟反馈：**通常，当我们收到一个用户反馈一个问题的时候，已经有很多用户遇到这个问题了，他们通常默默忍受，或者默默走掉，不做声。并且很可能包括反馈问题的人在内，都已经尝试了很多次，在他们有限的认知下实在没有办法了，才来进行反馈。我们感谢这些发声的用户的同时，也应该审视，自己是否可以更早地发现这些问题。","updated":"2021-12-23T06:07:10.307Z","path":"about/index.html","_id":"ckxijpqsd0002d3mr6mmm8o1t","content":"<blockquote>\n<p>大多数时候，都在思考自己该走向何方</p>\n</blockquote>\n<p>E-mail: <a href=\"mailto:&#x6f;&#x6e;&#x6c;&#121;&#x74;&#104;&#101;&#x6e;&#64;&#121;&#x65;&#x61;&#x68;&#46;&#x6e;&#x65;&#116;\">&#x6f;&#x6e;&#x6c;&#121;&#x74;&#104;&#101;&#x6e;&#64;&#121;&#x65;&#x61;&#x68;&#46;&#x6e;&#x65;&#116;</a></p>\n<p>Brief：Javascript/Rust，不想做程序员的程序员，宏观经济研究者的男朋友</p>\n<ul>\n<li>2021.03.22</li>\n</ul>\n<p>感觉有的时候，员工打破边界对于公司来书并不是一个好事情，比如一个客户端的同学，去做 c++ 了，这个时候应该鼓励还是反对呢。实际上这个时候，他除了仅存的业务熟悉度和一些通用的编程能力，c++ 的能力也许就只有应届生的水平，如果从新招聘可能连初试都过不了。公司就必须要承担因为他的编程能力不熟练带来的效率损失，甚至因为更容易引发问题造成更大的损失。</p>\n<ul>\n<li>2020.06.23</li>\n</ul>\n<p>有的时候，感觉机会其实也有很多，但是自己也许在默默流失，年初的时候疫情，带来医药股票的利好，但是自己没有买，春节结束后的第一天，明明是一次风险的释放，自己却也跟着卖了一些，导致损失了收益，其实每次危机中也都蕴藏着商机，希望之后的自己，可以多进行思考。</p>\n<ul>\n<li>2020.06.01</li>\n</ul>\n<p><strong>延迟反馈：</strong>通常，当我们收到一个用户反馈一个问题的时候，已经有很多用户遇到这个问题了，他们通常默默忍受，或者默默走掉，不做声。并且很可能包括反馈问题的人在内，都已经尝试了很多次，在他们有限的认知下实在没有办法了，才来进行反馈。我们感谢这些发声的用户的同时，也应该审视，自己是否可以更早地发现这些问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>大多数时候，都在思考自己该走向何方</p>\n</blockquote>\n<p>E-mail: <a href=\"mailto:&#x6f;&#x6e;&#x6c;&#121;&#x74;&#104;&#101;&#x6e;&#64;&#121;&#x65;&#x61;&#x68;&#46;&#x6e;&#x65;&#116;\">&#x6f;&#x6e;&#x6c;&#121;&#x74;&#104;&#101;&#x6e;&#64;&#121;&#x65;&#x61;&#x68;&#46;&#x6e;&#x65;&#116;</a></p>\n<p>Brief：Javascript/Rust，不想做程序员的程序员，宏观经济研究者的男朋友</p>\n<ul>\n<li>2021.03.22</li>\n</ul>\n<p>感觉有的时候，员工打破边界对于公司来书并不是一个好事情，比如一个客户端的同学，去做 c++ 了，这个时候应该鼓励还是反对呢。实际上这个时候，他除了仅存的业务熟悉度和一些通用的编程能力，c++ 的能力也许就只有应届生的水平，如果从新招聘可能连初试都过不了。公司就必须要承担因为他的编程能力不熟练带来的效率损失，甚至因为更容易引发问题造成更大的损失。</p>\n<ul>\n<li>2020.06.23</li>\n</ul>\n<p>有的时候，感觉机会其实也有很多，但是自己也许在默默流失，年初的时候疫情，带来医药股票的利好，但是自己没有买，春节结束后的第一天，明明是一次风险的释放，自己却也跟着卖了一些，导致损失了收益，其实每次危机中也都蕴藏着商机，希望之后的自己，可以多进行思考。</p>\n<ul>\n<li>2020.06.01</li>\n</ul>\n<p><strong>延迟反馈：</strong>通常，当我们收到一个用户反馈一个问题的时候，已经有很多用户遇到这个问题了，他们通常默默忍受，或者默默走掉，不做声。并且很可能包括反馈问题的人在内，都已经尝试了很多次，在他们有限的认知下实在没有办法了，才来进行反馈。我们感谢这些发声的用户的同时，也应该审视，自己是否可以更早地发现这些问题。</p>\n"},{"layout":"tags","title":"Tags","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\n---\n","date":"2021-12-23T01:51:10.364Z","updated":"2021-12-23T01:51:10.364Z","path":"tags/index.html","comments":1,"_id":"ckxijpqsg0005d3mrfuqv5wwl","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"CentOS7下安装和配置redis","abbrlink":72976152,"date":"2016-10-04T15:52:11.000Z","_content":"Redis是一个高性能的，开源key-value型数据库。是构建高性能，可扩展的Web应用的完美解决方案，可以内存存储亦可持久化存储。因为要使用跨进程，跨服务级别的数据缓存，在对比多个方案后，决定使用Redis。顺便整理下Redis的安装过程，以便查阅。\n\n\n 1 . 下载Redis\n目前，最新的Redist版本为3.0，使用wget下载，命令如下：\n```\n\n# wget http://download.redis.io/releases/redis-3.0.4.tar.gz\n\n```\n 2 . 解压Redis\n下载完成后，使用tar命令解压下载文件：\n```\n\n# tar -xzvf redis-3.0.4.tar.gz\n```\n3 . 编译安装Redis\n切换至程序目录，并执行make命令编译：\n```\n# cd redis-3.0.4\n# make\n```\n执行安装命令\n```\n# make install\n```\nmake install安装完成后，会在/usr/local/bin目录下生成下面几个可执行文件，它们的作用分别是：\n\n* redis-server：Redis服务器端启动程序\n* redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作\n* redis-benchmark：Redis性能测试工具\n* redis-check-aof：数据修复工具\n* redis-check-dump：检查导出工具\n\n备注\n\n有的机器会出现类似以下错误：\n```\nmake[1]: Entering directory `/root/redis/src'\nYou need tcl 8.5 or newer in order to run the Redis test\n……\n```\n这是因为没有安装tcl导致，yum安装即可：\n```\nyum install tcl\n```\n4 . 配置Redis\n复制配置文件到/etc/目录：\n```\n# cp redis.conf /etc/\n```\n为了让Redis后台运行，一般还需要修改redis.conf文件：\n```\nvi /etc/redis.conf\n```\n修改daemonize配置项为yes，使Redis进程在后台运行：\n```\ndaemonize yes\n```\n5 . 启动Redis\n配置完成后，启动Redis：\n```\n# cd /usr/local/bin\n# ./redis-server /etc/redis.conf\n```\n检查启动情况：\n```\n# ps -ef | grep redis\n```\n看到类似下面的一行，表示启动成功：\n```\nroot     18443     1  0 13:05 ?        00:00:00 ./redis-server *:6379 \n```\n6 . 添加开机启动项\n让Redis开机运行可以将其添加到rc.local文件，也可将添加为系统服务service。本文使用rc.local的方式，添加service请参考：Redis 配置为 Service 系统服务 。\n\n为了能让Redis在服务器重启后自动启动，需要将启动命令写入开机启动项：\n```\necho \"/usr/local/bin/redis-server /etc/redis.conf\" >>/etc/rc.local\n```\n7 . Redis配置参数\n在 前面的操作中，我们用到了使Redis进程在后台运行的参数，下面介绍其它一些常用的Redis启动参数：\n```\ndaemonize：是否以后台daemon方式运行\npidfile：pid文件位置\nport：监听的端口号\ntimeout：请求超时时间\nloglevel：log信息级别\nlogfile：log文件位置\ndatabases：开启数据库的数量\nsave * *：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。\nrdbcompression：是否使用压缩\ndbfilename：数据快照文件名（只是文件名）\ndir：数据快照的保存目录（仅目录）\nappendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。\nappendfsync：appendonlylog如何同步到磁盘。三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步\n```\n","source":"_posts/CentOS7下安装和配置redis.md","raw":"---\ntitle: CentOS7下安装和配置redis\ntags:\n  - centOS\n  - redis\nabbrlink: 72976152\ndate: 2016-10-04 23:52:11\n---\nRedis是一个高性能的，开源key-value型数据库。是构建高性能，可扩展的Web应用的完美解决方案，可以内存存储亦可持久化存储。因为要使用跨进程，跨服务级别的数据缓存，在对比多个方案后，决定使用Redis。顺便整理下Redis的安装过程，以便查阅。\n\n\n 1 . 下载Redis\n目前，最新的Redist版本为3.0，使用wget下载，命令如下：\n```\n\n# wget http://download.redis.io/releases/redis-3.0.4.tar.gz\n\n```\n 2 . 解压Redis\n下载完成后，使用tar命令解压下载文件：\n```\n\n# tar -xzvf redis-3.0.4.tar.gz\n```\n3 . 编译安装Redis\n切换至程序目录，并执行make命令编译：\n```\n# cd redis-3.0.4\n# make\n```\n执行安装命令\n```\n# make install\n```\nmake install安装完成后，会在/usr/local/bin目录下生成下面几个可执行文件，它们的作用分别是：\n\n* redis-server：Redis服务器端启动程序\n* redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作\n* redis-benchmark：Redis性能测试工具\n* redis-check-aof：数据修复工具\n* redis-check-dump：检查导出工具\n\n备注\n\n有的机器会出现类似以下错误：\n```\nmake[1]: Entering directory `/root/redis/src'\nYou need tcl 8.5 or newer in order to run the Redis test\n……\n```\n这是因为没有安装tcl导致，yum安装即可：\n```\nyum install tcl\n```\n4 . 配置Redis\n复制配置文件到/etc/目录：\n```\n# cp redis.conf /etc/\n```\n为了让Redis后台运行，一般还需要修改redis.conf文件：\n```\nvi /etc/redis.conf\n```\n修改daemonize配置项为yes，使Redis进程在后台运行：\n```\ndaemonize yes\n```\n5 . 启动Redis\n配置完成后，启动Redis：\n```\n# cd /usr/local/bin\n# ./redis-server /etc/redis.conf\n```\n检查启动情况：\n```\n# ps -ef | grep redis\n```\n看到类似下面的一行，表示启动成功：\n```\nroot     18443     1  0 13:05 ?        00:00:00 ./redis-server *:6379 \n```\n6 . 添加开机启动项\n让Redis开机运行可以将其添加到rc.local文件，也可将添加为系统服务service。本文使用rc.local的方式，添加service请参考：Redis 配置为 Service 系统服务 。\n\n为了能让Redis在服务器重启后自动启动，需要将启动命令写入开机启动项：\n```\necho \"/usr/local/bin/redis-server /etc/redis.conf\" >>/etc/rc.local\n```\n7 . Redis配置参数\n在 前面的操作中，我们用到了使Redis进程在后台运行的参数，下面介绍其它一些常用的Redis启动参数：\n```\ndaemonize：是否以后台daemon方式运行\npidfile：pid文件位置\nport：监听的端口号\ntimeout：请求超时时间\nloglevel：log信息级别\nlogfile：log文件位置\ndatabases：开启数据库的数量\nsave * *：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。\nrdbcompression：是否使用压缩\ndbfilename：数据快照文件名（只是文件名）\ndir：数据快照的保存目录（仅目录）\nappendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。\nappendfsync：appendonlylog如何同步到磁盘。三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步\n```\n","slug":"CentOS7下安装和配置redis","published":1,"updated":"2021-12-23T05:50:07.535Z","_id":"ckxijpqs90001d3mr64xf3q7l","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Redis是一个高性能的，开源key-value型数据库。是构建高性能，可扩展的Web应用的完美解决方案，可以内存存储亦可持久化存储。因为要使用跨进程，跨服务级别的数据缓存，在对比多个方案后，决定使用Redis。顺便整理下Redis的安装过程，以便查阅。</p>\n<p> 1 . 下载Redis<br>目前，最新的Redist版本为3.0，使用wget下载，命令如下：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># wget http:<span class=\"comment\">//download.redis.io/releases/redis-3.0.4.tar.gz</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p> 2 . 解压Redis<br>下载完成后，使用tar命令解压下载文件：</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># tar -xzvf redis-3.0.4.tar.gz</span></span><br></pre></td></tr></table></figure>\n<p>3 . 编译安装Redis<br>切换至程序目录，并执行make命令编译：</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># cd redis-3.0.4</span></span><br><span class=\"line\"><span class=\"meta\"># make</span></span><br></pre></td></tr></table></figure>\n<p>执行安装命令</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># make install</span></span><br></pre></td></tr></table></figure>\n<p>make install安装完成后，会在/usr/local/bin目录下生成下面几个可执行文件，它们的作用分别是：</p>\n<ul>\n<li>redis-server：Redis服务器端启动程序</li>\n<li>redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作</li>\n<li>redis-benchmark：Redis性能测试工具</li>\n<li>redis-check-aof：数据修复工具</li>\n<li>redis-check-dump：检查导出工具</li>\n</ul>\n<p>备注</p>\n<p>有的机器会出现类似以下错误：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make[<span class=\"number\">1</span>]: Entering directory `/root/redis/src&#x27;</span><br><span class=\"line\">You need tcl <span class=\"number\">8.5</span> <span class=\"keyword\">or</span> newer <span class=\"keyword\">in</span> <span class=\"keyword\">order</span> <span class=\"title\">to</span> run the Redis test</span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n<p>这是因为没有安装tcl导致，yum安装即可：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum <span class=\"keyword\">install</span> tcl</span><br></pre></td></tr></table></figure>\n<p>4 . 配置Redis<br>复制配置文件到/etc/目录：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cp redis.conf <span class=\"regexp\">/etc/</span></span><br></pre></td></tr></table></figure>\n<p>为了让Redis后台运行，一般还需要修改redis.conf文件：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi <span class=\"regexp\">/etc/</span>redis.conf</span><br></pre></td></tr></table></figure>\n<p>修改daemonize配置项为yes，使Redis进程在后台运行：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">daemonize</span> <span class=\"literal\">yes</span></span><br></pre></td></tr></table></figure>\n<p>5 . 启动Redis<br>配置完成后，启动Redis：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cd <span class=\"regexp\">/usr/</span>local/bin</span><br><span class=\"line\"># .<span class=\"regexp\">/redis-server /</span>etc/redis.conf</span><br></pre></td></tr></table></figure>\n<p>检查启动情况：</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># ps -ef | grep redis</span></span><br></pre></td></tr></table></figure>\n<p>看到类似下面的一行，表示启动成功：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">root</span>     <span class=\"number\">18443</span>     <span class=\"number\">1</span>  <span class=\"number\">0</span> <span class=\"number\">13</span>:<span class=\"number\">05</span> ?        <span class=\"number\">00</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> ./redis-server *:<span class=\"number\">6379</span> </span><br></pre></td></tr></table></figure>\n<p>6 . 添加开机启动项<br>让Redis开机运行可以将其添加到rc.local文件，也可将添加为系统服务service。本文使用rc.local的方式，添加service请参考：Redis 配置为 Service 系统服务 。</p>\n<p>为了能让Redis在服务器重启后自动启动，需要将启动命令写入开机启动项：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo <span class=\"string\">&quot;/usr/local/bin/redis-server /etc/redis.conf&quot;</span> &gt;&gt;<span class=\"regexp\">/etc/</span>rc.local</span><br></pre></td></tr></table></figure>\n<p>7 . Redis配置参数<br>在 前面的操作中，我们用到了使Redis进程在后台运行的参数，下面介绍其它一些常用的Redis启动参数：</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">daemonize：是否以后台daemon方式运行</span><br><span class=\"line\">pidfile：pid文件位置</span><br><span class=\"line\"><span class=\"keyword\">port</span>：监听的端口号</span><br><span class=\"line\"><span class=\"keyword\">timeout</span>：请求超时时间</span><br><span class=\"line\">loglevel：<span class=\"keyword\">log</span>信息级别</span><br><span class=\"line\">logfile：<span class=\"keyword\">log</span>文件位置</span><br><span class=\"line\">databases：开启数据库的数量</span><br><span class=\"line\">save * *：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。</span><br><span class=\"line\">rdbcompression：是否使用压缩</span><br><span class=\"line\">dbfilename：数据快照文件名（只是文件名）</span><br><span class=\"line\">dir：数据快照的保存目录（仅目录）</span><br><span class=\"line\">appendonly：是否开启appendonlylog，开启的话每次写操作会记一条<span class=\"keyword\">log</span>，这会提高数据抗风险能力，但影响效率。</span><br><span class=\"line\">appendfsync：appendonlylog如何同步到磁盘。三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Redis是一个高性能的，开源key-value型数据库。是构建高性能，可扩展的Web应用的完美解决方案，可以内存存储亦可持久化存储。因为要使用跨进程，跨服务级别的数据缓存，在对比多个方案后，决定使用Redis。顺便整理下Redis的安装过程，以便查阅。</p>\n<p> 1 . 下载Redis<br>目前，最新的Redist版本为3.0，使用wget下载，命令如下：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># wget http:<span class=\"comment\">//download.redis.io/releases/redis-3.0.4.tar.gz</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p> 2 . 解压Redis<br>下载完成后，使用tar命令解压下载文件：</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># tar -xzvf redis-3.0.4.tar.gz</span></span><br></pre></td></tr></table></figure>\n<p>3 . 编译安装Redis<br>切换至程序目录，并执行make命令编译：</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># cd redis-3.0.4</span></span><br><span class=\"line\"><span class=\"meta\"># make</span></span><br></pre></td></tr></table></figure>\n<p>执行安装命令</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># make install</span></span><br></pre></td></tr></table></figure>\n<p>make install安装完成后，会在/usr/local/bin目录下生成下面几个可执行文件，它们的作用分别是：</p>\n<ul>\n<li>redis-server：Redis服务器端启动程序</li>\n<li>redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作</li>\n<li>redis-benchmark：Redis性能测试工具</li>\n<li>redis-check-aof：数据修复工具</li>\n<li>redis-check-dump：检查导出工具</li>\n</ul>\n<p>备注</p>\n<p>有的机器会出现类似以下错误：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make[<span class=\"number\">1</span>]: Entering directory `/root/redis/src&#x27;</span><br><span class=\"line\">You need tcl <span class=\"number\">8.5</span> <span class=\"keyword\">or</span> newer <span class=\"keyword\">in</span> <span class=\"keyword\">order</span> <span class=\"title\">to</span> run the Redis test</span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n<p>这是因为没有安装tcl导致，yum安装即可：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum <span class=\"keyword\">install</span> tcl</span><br></pre></td></tr></table></figure>\n<p>4 . 配置Redis<br>复制配置文件到/etc/目录：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cp redis.conf <span class=\"regexp\">/etc/</span></span><br></pre></td></tr></table></figure>\n<p>为了让Redis后台运行，一般还需要修改redis.conf文件：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi <span class=\"regexp\">/etc/</span>redis.conf</span><br></pre></td></tr></table></figure>\n<p>修改daemonize配置项为yes，使Redis进程在后台运行：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">daemonize</span> <span class=\"literal\">yes</span></span><br></pre></td></tr></table></figure>\n<p>5 . 启动Redis<br>配置完成后，启动Redis：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cd <span class=\"regexp\">/usr/</span>local/bin</span><br><span class=\"line\"># .<span class=\"regexp\">/redis-server /</span>etc/redis.conf</span><br></pre></td></tr></table></figure>\n<p>检查启动情况：</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># ps -ef | grep redis</span></span><br></pre></td></tr></table></figure>\n<p>看到类似下面的一行，表示启动成功：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">root</span>     <span class=\"number\">18443</span>     <span class=\"number\">1</span>  <span class=\"number\">0</span> <span class=\"number\">13</span>:<span class=\"number\">05</span> ?        <span class=\"number\">00</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> ./redis-server *:<span class=\"number\">6379</span> </span><br></pre></td></tr></table></figure>\n<p>6 . 添加开机启动项<br>让Redis开机运行可以将其添加到rc.local文件，也可将添加为系统服务service。本文使用rc.local的方式，添加service请参考：Redis 配置为 Service 系统服务 。</p>\n<p>为了能让Redis在服务器重启后自动启动，需要将启动命令写入开机启动项：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo <span class=\"string\">&quot;/usr/local/bin/redis-server /etc/redis.conf&quot;</span> &gt;&gt;<span class=\"regexp\">/etc/</span>rc.local</span><br></pre></td></tr></table></figure>\n<p>7 . Redis配置参数<br>在 前面的操作中，我们用到了使Redis进程在后台运行的参数，下面介绍其它一些常用的Redis启动参数：</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">daemonize：是否以后台daemon方式运行</span><br><span class=\"line\">pidfile：pid文件位置</span><br><span class=\"line\"><span class=\"keyword\">port</span>：监听的端口号</span><br><span class=\"line\"><span class=\"keyword\">timeout</span>：请求超时时间</span><br><span class=\"line\">loglevel：<span class=\"keyword\">log</span>信息级别</span><br><span class=\"line\">logfile：<span class=\"keyword\">log</span>文件位置</span><br><span class=\"line\">databases：开启数据库的数量</span><br><span class=\"line\">save * *：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。</span><br><span class=\"line\">rdbcompression：是否使用压缩</span><br><span class=\"line\">dbfilename：数据快照文件名（只是文件名）</span><br><span class=\"line\">dir：数据快照的保存目录（仅目录）</span><br><span class=\"line\">appendonly：是否开启appendonlylog，开启的话每次写操作会记一条<span class=\"keyword\">log</span>，这会提高数据抗风险能力，但影响效率。</span><br><span class=\"line\">appendfsync：appendonlylog如何同步到磁盘。三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步</span><br></pre></td></tr></table></figure>\n"},{"title":"Deno 是如何运行 TypeScript 的？","abbrlink":1059952923,"date":"2021-01-31T10:07:20.000Z","_content":"\n> Deno，一个 JavaScript/TypeScript 运行时。本文并不会从 JavaScript 的角度来去介绍如何使用 Deno，而是试图从框架实现的角度，来整体对 Deno 项目本身的开发实现进行解读，并且通过分析其运行 TypeScript 的原理，来对其进行一个入门的剖析。\n\n[原文链接已经转移至这里](https://zhuanlan.zhihu.com/p/348379605)","source":"_posts/Deno 是如何运行 TypeScript 的.md","raw":"---\ntitle: Deno 是如何运行 TypeScript 的？\ntags:\n  - 前端框架\nabbrlink: 1059952923\ndate: 2021-01-31 18:07:20\n---\n\n> Deno，一个 JavaScript/TypeScript 运行时。本文并不会从 JavaScript 的角度来去介绍如何使用 Deno，而是试图从框架实现的角度，来整体对 Deno 项目本身的开发实现进行解读，并且通过分析其运行 TypeScript 的原理，来对其进行一个入门的剖析。\n\n[原文链接已经转移至这里](https://zhuanlan.zhihu.com/p/348379605)","slug":"Deno 是如何运行 TypeScript 的","published":1,"updated":"2021-12-23T05:50:07.536Z","_id":"ckxijpqsd0003d3mrhq8s68gy","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>Deno，一个 JavaScript/TypeScript 运行时。本文并不会从 JavaScript 的角度来去介绍如何使用 Deno，而是试图从框架实现的角度，来整体对 Deno 项目本身的开发实现进行解读，并且通过分析其运行 TypeScript 的原理，来对其进行一个入门的剖析。</p>\n</blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/348379605\">原文链接已经转移至这里</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Deno，一个 JavaScript/TypeScript 运行时。本文并不会从 JavaScript 的角度来去介绍如何使用 Deno，而是试图从框架实现的角度，来整体对 Deno 项目本身的开发实现进行解读，并且通过分析其运行 TypeScript 的原理，来对其进行一个入门的剖析。</p>\n</blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/348379605\">原文链接已经转移至这里</a></p>\n"},{"title":"CentOS安装node8.x版本","abbrlink":533749760,"date":"2017-12-15T04:52:34.000Z","_content":"### CentOS 安装 node 8.x 版本\n\n由于一些原因需要给CentOS服务器安装8.0以上版本的node, 本来直接通过yum管理安装管理，但是没找到好办法，在此记录一下自己最后使用的简单过程：\n\n安装之前删除原来的node和npm (我原来是用yum安装的，如果是第一次安装可以省略这一步):\n\n```\nyum remove nodejs npm -y\n```\n\n首先我们随便进入服务器的一个目录，然后从淘宝的源拉取内容:\n\n```\nwget https://npm.taobao.org/mirrors/node/v8.0.0/node-v8.0.0-linux-x64.tar.xz \n```\n\n解压缩:\n\n```\nsudo tar -xvf node-v8.0.0-linux-x64.tar.xz \n```\n\n进入解压目录下的 bin 目录，执行 ls 命令\n\n```\ncd node-v8.0.0-linux-x64/bin && ls \n```\n\n我们发现有node 和 npm\n\n这个时候我们测试:\n\n```\n./node -v\n```\n\n这个时候我们发现实际上已经安装好了，接下来就是要建立链接文件。\n\n这里还是，如果我们之前已经安装过了，那么我们要先删除之前建立的链接文件：\n\n```\nsudo rm -rf /usr/bin/node\nsudo rm -rf /usr/bin/npm\n```\n\n然后建立链接文件:\n\n```\nsudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/node /usr/bin/node\nsudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/npm /usr/bin/npm\n```\n\n注意这里的第一个路径不要直接复制粘贴，要写当前文件的真正的路径，这个可以通过pwd获取。\n\n然后我们可以通过`node -v`等测试已经安装成功。\n","source":"_posts/CentOS安装node8-x版本.md","raw":"---\ntitle: CentOS安装node8.x版本\ntags:\n  - centOS\n  - Node.js\nabbrlink: 533749760\ndate: 2017-12-15 12:52:34\n---\n### CentOS 安装 node 8.x 版本\n\n由于一些原因需要给CentOS服务器安装8.0以上版本的node, 本来直接通过yum管理安装管理，但是没找到好办法，在此记录一下自己最后使用的简单过程：\n\n安装之前删除原来的node和npm (我原来是用yum安装的，如果是第一次安装可以省略这一步):\n\n```\nyum remove nodejs npm -y\n```\n\n首先我们随便进入服务器的一个目录，然后从淘宝的源拉取内容:\n\n```\nwget https://npm.taobao.org/mirrors/node/v8.0.0/node-v8.0.0-linux-x64.tar.xz \n```\n\n解压缩:\n\n```\nsudo tar -xvf node-v8.0.0-linux-x64.tar.xz \n```\n\n进入解压目录下的 bin 目录，执行 ls 命令\n\n```\ncd node-v8.0.0-linux-x64/bin && ls \n```\n\n我们发现有node 和 npm\n\n这个时候我们测试:\n\n```\n./node -v\n```\n\n这个时候我们发现实际上已经安装好了，接下来就是要建立链接文件。\n\n这里还是，如果我们之前已经安装过了，那么我们要先删除之前建立的链接文件：\n\n```\nsudo rm -rf /usr/bin/node\nsudo rm -rf /usr/bin/npm\n```\n\n然后建立链接文件:\n\n```\nsudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/node /usr/bin/node\nsudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/npm /usr/bin/npm\n```\n\n注意这里的第一个路径不要直接复制粘贴，要写当前文件的真正的路径，这个可以通过pwd获取。\n\n然后我们可以通过`node -v`等测试已经安装成功。\n","slug":"CentOS安装node8-x版本","published":1,"updated":"2021-12-23T05:50:07.536Z","_id":"ckxijpqsh0006d3mr3x61eyny","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"CentOS-安装-node-8-x-版本\"><a href=\"#CentOS-安装-node-8-x-版本\" class=\"headerlink\" title=\"CentOS 安装 node 8.x 版本\"></a>CentOS 安装 node 8.x 版本</h3><p>由于一些原因需要给CentOS服务器安装8.0以上版本的node, 本来直接通过yum管理安装管理，但是没找到好办法，在此记录一下自己最后使用的简单过程：</p>\n<p>安装之前删除原来的node和npm (我原来是用yum安装的，如果是第一次安装可以省略这一步):</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum <span class=\"builtin-name\">remove</span> nodejs npm -y</span><br></pre></td></tr></table></figure>\n\n<p>首先我们随便进入服务器的一个目录，然后从淘宝的源拉取内容:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">wget</span> https://npm.taobao.org/mirrors/node/v<span class=\"number\">8</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>/node-v<span class=\"number\">8</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>-linux-x<span class=\"number\">64</span>.tar.xz </span><br></pre></td></tr></table></figure>\n\n<p>解压缩:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">sudo</span> tar -xvf node-v<span class=\"number\">8</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>-linux-x<span class=\"number\">64</span>.tar.xz </span><br></pre></td></tr></table></figure>\n\n<p>进入解压目录下的 bin 目录，执行 ls 命令</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">cd</span> node-v<span class=\"number\">8</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>-linux-x<span class=\"number\">64</span>/bin &amp;&amp; ls </span><br></pre></td></tr></table></figure>\n\n<p>我们发现有node 和 npm</p>\n<p>这个时候我们测试:</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./<span class=\"keyword\">node</span> <span class=\"title\">-v</span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候我们发现实际上已经安装好了，接下来就是要建立链接文件。</p>\n<p>这里还是，如果我们之前已经安装过了，那么我们要先删除之前建立的链接文件：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm -rf <span class=\"regexp\">/usr/</span>bin/node</span><br><span class=\"line\">sudo rm -rf <span class=\"regexp\">/usr/</span>bin/npm</span><br></pre></td></tr></table></figure>\n\n<p>然后建立链接文件:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ln -s <span class=\"regexp\">/usr/</span>share<span class=\"regexp\">/node-v8.0.0-linux-x64/</span>bin<span class=\"regexp\">/node /u</span>sr<span class=\"regexp\">/bin/</span>node</span><br><span class=\"line\">sudo ln -s <span class=\"regexp\">/usr/</span>share<span class=\"regexp\">/node-v8.0.0-linux-x64/</span>bin<span class=\"regexp\">/npm /u</span>sr<span class=\"regexp\">/bin/</span>npm</span><br></pre></td></tr></table></figure>\n\n<p>注意这里的第一个路径不要直接复制粘贴，要写当前文件的真正的路径，这个可以通过pwd获取。</p>\n<p>然后我们可以通过<code>node -v</code>等测试已经安装成功。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"CentOS-安装-node-8-x-版本\"><a href=\"#CentOS-安装-node-8-x-版本\" class=\"headerlink\" title=\"CentOS 安装 node 8.x 版本\"></a>CentOS 安装 node 8.x 版本</h3><p>由于一些原因需要给CentOS服务器安装8.0以上版本的node, 本来直接通过yum管理安装管理，但是没找到好办法，在此记录一下自己最后使用的简单过程：</p>\n<p>安装之前删除原来的node和npm (我原来是用yum安装的，如果是第一次安装可以省略这一步):</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum <span class=\"builtin-name\">remove</span> nodejs npm -y</span><br></pre></td></tr></table></figure>\n\n<p>首先我们随便进入服务器的一个目录，然后从淘宝的源拉取内容:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">wget</span> https://npm.taobao.org/mirrors/node/v<span class=\"number\">8</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>/node-v<span class=\"number\">8</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>-linux-x<span class=\"number\">64</span>.tar.xz </span><br></pre></td></tr></table></figure>\n\n<p>解压缩:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">sudo</span> tar -xvf node-v<span class=\"number\">8</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>-linux-x<span class=\"number\">64</span>.tar.xz </span><br></pre></td></tr></table></figure>\n\n<p>进入解压目录下的 bin 目录，执行 ls 命令</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">cd</span> node-v<span class=\"number\">8</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>-linux-x<span class=\"number\">64</span>/bin &amp;&amp; ls </span><br></pre></td></tr></table></figure>\n\n<p>我们发现有node 和 npm</p>\n<p>这个时候我们测试:</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./<span class=\"keyword\">node</span> <span class=\"title\">-v</span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候我们发现实际上已经安装好了，接下来就是要建立链接文件。</p>\n<p>这里还是，如果我们之前已经安装过了，那么我们要先删除之前建立的链接文件：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm -rf <span class=\"regexp\">/usr/</span>bin/node</span><br><span class=\"line\">sudo rm -rf <span class=\"regexp\">/usr/</span>bin/npm</span><br></pre></td></tr></table></figure>\n\n<p>然后建立链接文件:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ln -s <span class=\"regexp\">/usr/</span>share<span class=\"regexp\">/node-v8.0.0-linux-x64/</span>bin<span class=\"regexp\">/node /u</span>sr<span class=\"regexp\">/bin/</span>node</span><br><span class=\"line\">sudo ln -s <span class=\"regexp\">/usr/</span>share<span class=\"regexp\">/node-v8.0.0-linux-x64/</span>bin<span class=\"regexp\">/npm /u</span>sr<span class=\"regexp\">/bin/</span>npm</span><br></pre></td></tr></table></figure>\n\n<p>注意这里的第一个路径不要直接复制粘贴，要写当前文件的真正的路径，这个可以通过pwd获取。</p>\n<p>然后我们可以通过<code>node -v</code>等测试已经安装成功。</p>\n"},{"title":"JS的静态作用域、子程序引用环境与参数传递类型","abbrlink":1712768766,"date":"2017-01-10T17:33:26.000Z","_content":"#### 静态作用域\n\n我们先来看下面这个小程序：\n\n```\n //JS版本：\n function sub1() {\n        var x;\n        function sub2() { alert(x); }\n        function sub3() { var x; x=3; sub4(sub2); }\n        function sub4(subx) { var x; x=4; subx(); }\n        x = 1;\n        sub3();\n    }\n\n    sub1();\n    \n #Python版本\ndef sub1():\n    def sub2():\n        print x\n    def sub3():\n        x=3\n        sub4(sub2)\n    def sub4(subx):\n        x=4\n        subx()\n    x = 1\n    sub3()\n\nsub1()   \n```\n\n不用亲自运行，实际上输出结果都是1，这可能不难猜到，但是需要解释一番，鉴于Python和JS在这一点上表现的类似，我就以JS来分析。\n\n我们知道，JS是静态作用域的，所谓静态作用域就是作用域在编译时确定，所以sub2中引用的x，实际上和x=3以及x=4的x没有任何关系，指向第二行的var x;\n\n#### 子程序的引用环境\n\n实际上这里面还有一个子程序(注：子程序和函数不是很一样，但我们可以认为子程序包括函数，也约等于函数)的概念，sub2、sub3、sub4都是子程序，对于允许嵌套子程序的语言，应该如何使用执行传递的子程序的引用环境？\n\n* 浅绑定：如果这样的话，应该输出4，这对动态作用域的语言来说比较自然。\n* 深绑定：也就是输出1的情况，这对静态作用域的语言来说比较自然。\n* Ad hoc binding: 这是第三种，将子程序作为实际参数传递到调用语句的环境。\n\n#### 参数传递类型\n\n参数传递类型我们普遍认为有按值传递和按引用传递两种，实际上不止。\n\n下面是一张图：\n\n![](https://www.10000h.top/images/call.png)\n\n这张图对应的第一种传递方式，叫做Pass-by-Value(In mode)，第二种是Pass-by-Result(Out mode)，第三种是Pass-by-Value-Result(Inout mode),图上说的比较明白，实际上如果有result就是说明最后把结果再赋值给参数。\n\n第二种和第三种编程语言用的少，原因如下：\n>Potential problem: sub(p1, p1)   \nWith the two corresponding formal parameters having different names, whichever formal parameter is copied back last will represent current value of p1\n\n","source":"_posts/JS的静态作用域、子程序引用环境与参数传递类型.md","raw":"---\ntitle: JS的静态作用域、子程序引用环境与参数传递类型\ntags:\n  - javascript\nabbrlink: 1712768766\ndate: 2017-01-11 01:33:26\n---\n#### 静态作用域\n\n我们先来看下面这个小程序：\n\n```\n //JS版本：\n function sub1() {\n        var x;\n        function sub2() { alert(x); }\n        function sub3() { var x; x=3; sub4(sub2); }\n        function sub4(subx) { var x; x=4; subx(); }\n        x = 1;\n        sub3();\n    }\n\n    sub1();\n    \n #Python版本\ndef sub1():\n    def sub2():\n        print x\n    def sub3():\n        x=3\n        sub4(sub2)\n    def sub4(subx):\n        x=4\n        subx()\n    x = 1\n    sub3()\n\nsub1()   \n```\n\n不用亲自运行，实际上输出结果都是1，这可能不难猜到，但是需要解释一番，鉴于Python和JS在这一点上表现的类似，我就以JS来分析。\n\n我们知道，JS是静态作用域的，所谓静态作用域就是作用域在编译时确定，所以sub2中引用的x，实际上和x=3以及x=4的x没有任何关系，指向第二行的var x;\n\n#### 子程序的引用环境\n\n实际上这里面还有一个子程序(注：子程序和函数不是很一样，但我们可以认为子程序包括函数，也约等于函数)的概念，sub2、sub3、sub4都是子程序，对于允许嵌套子程序的语言，应该如何使用执行传递的子程序的引用环境？\n\n* 浅绑定：如果这样的话，应该输出4，这对动态作用域的语言来说比较自然。\n* 深绑定：也就是输出1的情况，这对静态作用域的语言来说比较自然。\n* Ad hoc binding: 这是第三种，将子程序作为实际参数传递到调用语句的环境。\n\n#### 参数传递类型\n\n参数传递类型我们普遍认为有按值传递和按引用传递两种，实际上不止。\n\n下面是一张图：\n\n![](https://www.10000h.top/images/call.png)\n\n这张图对应的第一种传递方式，叫做Pass-by-Value(In mode)，第二种是Pass-by-Result(Out mode)，第三种是Pass-by-Value-Result(Inout mode),图上说的比较明白，实际上如果有result就是说明最后把结果再赋值给参数。\n\n第二种和第三种编程语言用的少，原因如下：\n>Potential problem: sub(p1, p1)   \nWith the two corresponding formal parameters having different names, whichever formal parameter is copied back last will represent current value of p1\n\n","slug":"JS的静态作用域、子程序引用环境与参数传递类型","published":1,"updated":"2021-12-23T05:50:07.537Z","_id":"ckxijpqsi0007d3mrhsowbqek","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"静态作用域\"><a href=\"#静态作用域\" class=\"headerlink\" title=\"静态作用域\"></a>静态作用域</h4><p>我们先来看下面这个小程序：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> //JS版本：</span><br><span class=\"line\"> function <span class=\"keyword\">sub</span><span class=\"number\">1</span>() &#123;</span><br><span class=\"line\">        var <span class=\"keyword\">x</span><span class=\"comment\">;</span></span><br><span class=\"line\">        function <span class=\"keyword\">sub</span><span class=\"number\">2</span>() &#123; alert(<span class=\"keyword\">x</span>)<span class=\"comment\">; &#125;</span></span><br><span class=\"line\">        function <span class=\"keyword\">sub</span><span class=\"number\">3</span>() &#123; var <span class=\"keyword\">x</span><span class=\"comment\">; x=3; sub4(sub2); &#125;</span></span><br><span class=\"line\">        function <span class=\"keyword\">sub</span><span class=\"number\">4</span>(subx) &#123; var <span class=\"keyword\">x</span><span class=\"comment\">; x=4; subx(); &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">x</span> <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">        <span class=\"keyword\">sub</span><span class=\"number\">3</span>()<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">sub</span><span class=\"number\">1</span>()<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"> #Python版本</span><br><span class=\"line\">def <span class=\"keyword\">sub</span><span class=\"number\">1</span>():</span><br><span class=\"line\">    def <span class=\"keyword\">sub</span><span class=\"number\">2</span>():</span><br><span class=\"line\">        print <span class=\"keyword\">x</span></span><br><span class=\"line\">    def <span class=\"keyword\">sub</span><span class=\"number\">3</span>():</span><br><span class=\"line\">        <span class=\"keyword\">x</span><span class=\"operator\">=</span><span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"keyword\">sub</span><span class=\"number\">4</span>(<span class=\"keyword\">sub</span><span class=\"number\">2</span>)</span><br><span class=\"line\">    def <span class=\"keyword\">sub</span><span class=\"number\">4</span>(subx):</span><br><span class=\"line\">        <span class=\"keyword\">x</span><span class=\"operator\">=</span><span class=\"number\">4</span></span><br><span class=\"line\">        subx()</span><br><span class=\"line\">    <span class=\"keyword\">x</span> <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">sub</span><span class=\"number\">3</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">sub</span><span class=\"number\">1</span>()   </span><br></pre></td></tr></table></figure>\n\n<p>不用亲自运行，实际上输出结果都是1，这可能不难猜到，但是需要解释一番，鉴于Python和JS在这一点上表现的类似，我就以JS来分析。</p>\n<p>我们知道，JS是静态作用域的，所谓静态作用域就是作用域在编译时确定，所以sub2中引用的x，实际上和x=3以及x=4的x没有任何关系，指向第二行的var x;</p>\n<h4 id=\"子程序的引用环境\"><a href=\"#子程序的引用环境\" class=\"headerlink\" title=\"子程序的引用环境\"></a>子程序的引用环境</h4><p>实际上这里面还有一个子程序(注：子程序和函数不是很一样，但我们可以认为子程序包括函数，也约等于函数)的概念，sub2、sub3、sub4都是子程序，对于允许嵌套子程序的语言，应该如何使用执行传递的子程序的引用环境？</p>\n<ul>\n<li>浅绑定：如果这样的话，应该输出4，这对动态作用域的语言来说比较自然。</li>\n<li>深绑定：也就是输出1的情况，这对静态作用域的语言来说比较自然。</li>\n<li>Ad hoc binding: 这是第三种，将子程序作为实际参数传递到调用语句的环境。</li>\n</ul>\n<h4 id=\"参数传递类型\"><a href=\"#参数传递类型\" class=\"headerlink\" title=\"参数传递类型\"></a>参数传递类型</h4><p>参数传递类型我们普遍认为有按值传递和按引用传递两种，实际上不止。</p>\n<p>下面是一张图：</p>\n<p><img src=\"https://www.10000h.top/images/call.png\"></p>\n<p>这张图对应的第一种传递方式，叫做Pass-by-Value(In mode)，第二种是Pass-by-Result(Out mode)，第三种是Pass-by-Value-Result(Inout mode),图上说的比较明白，实际上如果有result就是说明最后把结果再赋值给参数。</p>\n<p>第二种和第三种编程语言用的少，原因如下：</p>\n<blockquote>\n<p>Potential problem: sub(p1, p1)<br>With the two corresponding formal parameters having different names, whichever formal parameter is copied back last will represent current value of p1</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"静态作用域\"><a href=\"#静态作用域\" class=\"headerlink\" title=\"静态作用域\"></a>静态作用域</h4><p>我们先来看下面这个小程序：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> //JS版本：</span><br><span class=\"line\"> function <span class=\"keyword\">sub</span><span class=\"number\">1</span>() &#123;</span><br><span class=\"line\">        var <span class=\"keyword\">x</span><span class=\"comment\">;</span></span><br><span class=\"line\">        function <span class=\"keyword\">sub</span><span class=\"number\">2</span>() &#123; alert(<span class=\"keyword\">x</span>)<span class=\"comment\">; &#125;</span></span><br><span class=\"line\">        function <span class=\"keyword\">sub</span><span class=\"number\">3</span>() &#123; var <span class=\"keyword\">x</span><span class=\"comment\">; x=3; sub4(sub2); &#125;</span></span><br><span class=\"line\">        function <span class=\"keyword\">sub</span><span class=\"number\">4</span>(subx) &#123; var <span class=\"keyword\">x</span><span class=\"comment\">; x=4; subx(); &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">x</span> <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">        <span class=\"keyword\">sub</span><span class=\"number\">3</span>()<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">sub</span><span class=\"number\">1</span>()<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"> #Python版本</span><br><span class=\"line\">def <span class=\"keyword\">sub</span><span class=\"number\">1</span>():</span><br><span class=\"line\">    def <span class=\"keyword\">sub</span><span class=\"number\">2</span>():</span><br><span class=\"line\">        print <span class=\"keyword\">x</span></span><br><span class=\"line\">    def <span class=\"keyword\">sub</span><span class=\"number\">3</span>():</span><br><span class=\"line\">        <span class=\"keyword\">x</span><span class=\"operator\">=</span><span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"keyword\">sub</span><span class=\"number\">4</span>(<span class=\"keyword\">sub</span><span class=\"number\">2</span>)</span><br><span class=\"line\">    def <span class=\"keyword\">sub</span><span class=\"number\">4</span>(subx):</span><br><span class=\"line\">        <span class=\"keyword\">x</span><span class=\"operator\">=</span><span class=\"number\">4</span></span><br><span class=\"line\">        subx()</span><br><span class=\"line\">    <span class=\"keyword\">x</span> <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">sub</span><span class=\"number\">3</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">sub</span><span class=\"number\">1</span>()   </span><br></pre></td></tr></table></figure>\n\n<p>不用亲自运行，实际上输出结果都是1，这可能不难猜到，但是需要解释一番，鉴于Python和JS在这一点上表现的类似，我就以JS来分析。</p>\n<p>我们知道，JS是静态作用域的，所谓静态作用域就是作用域在编译时确定，所以sub2中引用的x，实际上和x=3以及x=4的x没有任何关系，指向第二行的var x;</p>\n<h4 id=\"子程序的引用环境\"><a href=\"#子程序的引用环境\" class=\"headerlink\" title=\"子程序的引用环境\"></a>子程序的引用环境</h4><p>实际上这里面还有一个子程序(注：子程序和函数不是很一样，但我们可以认为子程序包括函数，也约等于函数)的概念，sub2、sub3、sub4都是子程序，对于允许嵌套子程序的语言，应该如何使用执行传递的子程序的引用环境？</p>\n<ul>\n<li>浅绑定：如果这样的话，应该输出4，这对动态作用域的语言来说比较自然。</li>\n<li>深绑定：也就是输出1的情况，这对静态作用域的语言来说比较自然。</li>\n<li>Ad hoc binding: 这是第三种，将子程序作为实际参数传递到调用语句的环境。</li>\n</ul>\n<h4 id=\"参数传递类型\"><a href=\"#参数传递类型\" class=\"headerlink\" title=\"参数传递类型\"></a>参数传递类型</h4><p>参数传递类型我们普遍认为有按值传递和按引用传递两种，实际上不止。</p>\n<p>下面是一张图：</p>\n<p><img src=\"https://www.10000h.top/images/call.png\"></p>\n<p>这张图对应的第一种传递方式，叫做Pass-by-Value(In mode)，第二种是Pass-by-Result(Out mode)，第三种是Pass-by-Value-Result(Inout mode),图上说的比较明白，实际上如果有result就是说明最后把结果再赋值给参数。</p>\n<p>第二种和第三种编程语言用的少，原因如下：</p>\n<blockquote>\n<p>Potential problem: sub(p1, p1)<br>With the two corresponding formal parameters having different names, whichever formal parameter is copied back last will represent current value of p1</p>\n</blockquote>\n"},{"title":"Linux服务器初始化设置用户和ssh公私钥登陆","abbrlink":1131426487,"date":"2018-04-11T09:16:37.000Z","_content":"\n>当我们开始使用一个新的服务器的时候，首先一定要对服务器的登陆等做一些修改工作，笔者曾经就因为对服务器登陆安全没有重视，导致服务器数据全部丢失。接下来我们按照步骤，罗列出应该做的一些事情。\n\n### 修改ssh端口号\n\n第一件事情：\n\n修改ssh端口号： 之后加上一个端口比如说50000\n\n`vi /etc/ssh/sshd_config`之后在port字段加上一个端口比如说50000，原来的端口号字段可能是被注释掉的，要先解除注释。\n\n然后执行：\n\n```\nservice sshd restart\n```\n\n这个时候可能还要重新配置一下防火墙，开放50000端口，具体如何配置也可以参考[这里](https://blog.csdn.net/ul646691993/article/details/52104082)的后半部分。但是目前，阿里云的服务器实测是不需要再配置防火墙的，但是需要去登陆到网页后台修改安全组。\n\n之后就可以通过这样的方式登录了：(注意登录方式一定要写对)\n\n```shell\nssh root@115.29.102.81 -p 50000\n```\n\n### 创建用户\n\n这个时候我们还是用root进行操作，所以我们接下来要给自己创建一个账户，比如创建一个如下的用户：\n\n```\nuseradd xiaotao\npasswd xiaotao\n```\n\n可以用`ls -al /home/``查看一下账户\n\n对创建的这个用户增加sudo权限： 相关配置文件/etc/sudoers中，但是这个文件是只读的，所以要更改一下权限\n\n```\nchmod u+w sudoers\n```\n\n然后进入这个文件在这里进行更改：\n\n```\nroot    ALL=(ALL)       ALL\nxiaotao  ALL=(ALL)       ALL\n```\n\n然后再改回权限：\n\n```\nchmod u-w sudoers\n```\n\n注意一点，CentOS 7预设容许任何帐号透过ssh登入（也就是说自己根本不用改改，直接新建帐号登录即可），包括根和一般帐号，为了不受根帐号被黑客暴力入侵，我们必须禁止 root帐号的ssh功能，事实上root也没有必要ssh登入伺服器，因为只要使用su或sudo（当然需要输入root的密码）普通帐号便可以拥有root的权限。使用vim（或任何文本编辑器）开启的/ etc/ SSH/ sshd_config中，寻找：\n\n```\n＃PermitRootLogin yes\n```\n修改：\n\n```\nPermitRootLogin no\n```\n\n### 配置公私钥加密登录\n\n**这一步骤要切换到自己新建的用户，不能再用 root 用户了，否则可能无法正常登陆。**\n\n很多时候以上所说的还是不够安全，为了更加安全方便，我们采用公私钥对称加密登录，简单的讲做法就是再客户端生成一把私钥一把公钥，私钥是在客户端的，公钥上传到服务端，对称加密进行登录。\n\n在客户端先进到这个目录：\n\n```\ncd ~/.ssh\n```\n\n生成公钥和私钥（实际上如果之前有的话就不用重新生成了）\n\n```\nssh-keygen -t rsa\n```\n\n接下来把公钥上传到服务端\n\n```\nscp ~/.ssh/id_rsa.pub xiaotao@<ssh_server_ip>:~\n```\n\n在服务端执行以下命令(如果没有相关的文件和文件夹要先进行创建，注意不要使用 sudo )\n\n```\ncat  id_rsa.pub >> ～/.ssh/authorized_keys\n```\n\n配置服务器的/etc/ssh/sshd_config，下面是一些建议的配置：\n\n```\nvim /etc/ssh/sshd_config\n# 禁用root账户登录，非必要，但为了安全性，请配置\nPermitRootLogin no\n\n# 是否让 sshd 去检查用户家目录或相关档案的权限数据，\n# 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。\n# 例如使用者的 ~.ssh/ 权限设错时，某些特殊情况下会不许用户登入\nStrictModes no\n\n# 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。\n# 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile      %h/.ssh/authorized_keys\n\n#有了证书登录了，就禁用密码登录吧，安全要紧\nPasswordAuthentication no\n```\n\n然后不要忘记 `sudo service sshd restart`\n\n\n一般来讲，这样就算是成功了，我们可以在客户端尝试：\n\n```\nssh -i ~/.ssh/id_rsa remote_username@remote_ip\n```\n\n如果不行，可能是服务端或客户端相关 `.ssh` 文件权限不对，可以进行如下尝试：\n\n```\n服务端\nchown -R 0700  ~/.ssh\nchown -R 0644  ~/.ssh/authorized_keys\n\n客户端改一下\nchmod 600 id_rsa\n```","source":"_posts/Linux服务器初始化设置用户和ssh公私钥登陆.md","raw":"---\ntitle: Linux服务器初始化设置用户和ssh公私钥登陆\ntags:\n  - Linux\n  - ssh\nabbrlink: 1131426487\ndate: 2018-04-11 17:16:37\n---\n\n>当我们开始使用一个新的服务器的时候，首先一定要对服务器的登陆等做一些修改工作，笔者曾经就因为对服务器登陆安全没有重视，导致服务器数据全部丢失。接下来我们按照步骤，罗列出应该做的一些事情。\n\n### 修改ssh端口号\n\n第一件事情：\n\n修改ssh端口号： 之后加上一个端口比如说50000\n\n`vi /etc/ssh/sshd_config`之后在port字段加上一个端口比如说50000，原来的端口号字段可能是被注释掉的，要先解除注释。\n\n然后执行：\n\n```\nservice sshd restart\n```\n\n这个时候可能还要重新配置一下防火墙，开放50000端口，具体如何配置也可以参考[这里](https://blog.csdn.net/ul646691993/article/details/52104082)的后半部分。但是目前，阿里云的服务器实测是不需要再配置防火墙的，但是需要去登陆到网页后台修改安全组。\n\n之后就可以通过这样的方式登录了：(注意登录方式一定要写对)\n\n```shell\nssh root@115.29.102.81 -p 50000\n```\n\n### 创建用户\n\n这个时候我们还是用root进行操作，所以我们接下来要给自己创建一个账户，比如创建一个如下的用户：\n\n```\nuseradd xiaotao\npasswd xiaotao\n```\n\n可以用`ls -al /home/``查看一下账户\n\n对创建的这个用户增加sudo权限： 相关配置文件/etc/sudoers中，但是这个文件是只读的，所以要更改一下权限\n\n```\nchmod u+w sudoers\n```\n\n然后进入这个文件在这里进行更改：\n\n```\nroot    ALL=(ALL)       ALL\nxiaotao  ALL=(ALL)       ALL\n```\n\n然后再改回权限：\n\n```\nchmod u-w sudoers\n```\n\n注意一点，CentOS 7预设容许任何帐号透过ssh登入（也就是说自己根本不用改改，直接新建帐号登录即可），包括根和一般帐号，为了不受根帐号被黑客暴力入侵，我们必须禁止 root帐号的ssh功能，事实上root也没有必要ssh登入伺服器，因为只要使用su或sudo（当然需要输入root的密码）普通帐号便可以拥有root的权限。使用vim（或任何文本编辑器）开启的/ etc/ SSH/ sshd_config中，寻找：\n\n```\n＃PermitRootLogin yes\n```\n修改：\n\n```\nPermitRootLogin no\n```\n\n### 配置公私钥加密登录\n\n**这一步骤要切换到自己新建的用户，不能再用 root 用户了，否则可能无法正常登陆。**\n\n很多时候以上所说的还是不够安全，为了更加安全方便，我们采用公私钥对称加密登录，简单的讲做法就是再客户端生成一把私钥一把公钥，私钥是在客户端的，公钥上传到服务端，对称加密进行登录。\n\n在客户端先进到这个目录：\n\n```\ncd ~/.ssh\n```\n\n生成公钥和私钥（实际上如果之前有的话就不用重新生成了）\n\n```\nssh-keygen -t rsa\n```\n\n接下来把公钥上传到服务端\n\n```\nscp ~/.ssh/id_rsa.pub xiaotao@<ssh_server_ip>:~\n```\n\n在服务端执行以下命令(如果没有相关的文件和文件夹要先进行创建，注意不要使用 sudo )\n\n```\ncat  id_rsa.pub >> ～/.ssh/authorized_keys\n```\n\n配置服务器的/etc/ssh/sshd_config，下面是一些建议的配置：\n\n```\nvim /etc/ssh/sshd_config\n# 禁用root账户登录，非必要，但为了安全性，请配置\nPermitRootLogin no\n\n# 是否让 sshd 去检查用户家目录或相关档案的权限数据，\n# 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。\n# 例如使用者的 ~.ssh/ 权限设错时，某些特殊情况下会不许用户登入\nStrictModes no\n\n# 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。\n# 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile      %h/.ssh/authorized_keys\n\n#有了证书登录了，就禁用密码登录吧，安全要紧\nPasswordAuthentication no\n```\n\n然后不要忘记 `sudo service sshd restart`\n\n\n一般来讲，这样就算是成功了，我们可以在客户端尝试：\n\n```\nssh -i ~/.ssh/id_rsa remote_username@remote_ip\n```\n\n如果不行，可能是服务端或客户端相关 `.ssh` 文件权限不对，可以进行如下尝试：\n\n```\n服务端\nchown -R 0700  ~/.ssh\nchown -R 0644  ~/.ssh/authorized_keys\n\n客户端改一下\nchmod 600 id_rsa\n```","slug":"Linux服务器初始化设置用户和ssh公私钥登陆","published":1,"updated":"2021-12-23T05:50:07.538Z","_id":"ckxijpqsj0008d3mrdjfx870h","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>当我们开始使用一个新的服务器的时候，首先一定要对服务器的登陆等做一些修改工作，笔者曾经就因为对服务器登陆安全没有重视，导致服务器数据全部丢失。接下来我们按照步骤，罗列出应该做的一些事情。</p>\n</blockquote>\n<h3 id=\"修改ssh端口号\"><a href=\"#修改ssh端口号\" class=\"headerlink\" title=\"修改ssh端口号\"></a>修改ssh端口号</h3><p>第一件事情：</p>\n<p>修改ssh端口号： 之后加上一个端口比如说50000</p>\n<p><code>vi /etc/ssh/sshd_config</code>之后在port字段加上一个端口比如说50000，原来的端口号字段可能是被注释掉的，要先解除注释。</p>\n<p>然后执行：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">service sshd restart</span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候可能还要重新配置一下防火墙，开放50000端口，具体如何配置也可以参考<a href=\"https://blog.csdn.net/ul646691993/article/details/52104082\">这里</a>的后半部分。但是目前，阿里云的服务器实测是不需要再配置防火墙的，但是需要去登陆到网页后台修改安全组。</p>\n<p>之后就可以通过这样的方式登录了：(注意登录方式一定要写对)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh root@115.29.102.81 -p 50000</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><p>这个时候我们还是用root进行操作，所以我们接下来要给自己创建一个账户，比如创建一个如下的用户：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">useradd xiaotao</span></span><br><span class=\"line\"><span class=\"attribute\">passwd xiaotao</span></span><br></pre></td></tr></table></figure>\n\n<p>可以用`ls -al /home/``查看一下账户</p>\n<p>对创建的这个用户增加sudo权限： 相关配置文件/etc/sudoers中，但是这个文件是只读的，所以要更改一下权限</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">chmod</span> u+w sudoers</span><br></pre></td></tr></table></figure>\n\n<p>然后进入这个文件在这里进行更改：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root    <span class=\"keyword\">ALL</span>=(<span class=\"keyword\">ALL</span>)       <span class=\"keyword\">ALL</span></span><br><span class=\"line\">xiaotao  <span class=\"keyword\">ALL</span>=(<span class=\"keyword\">ALL</span>)       <span class=\"keyword\">ALL</span></span><br></pre></td></tr></table></figure>\n\n<p>然后再改回权限：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">chmod u-w sudoers</span></span><br></pre></td></tr></table></figure>\n\n<p>注意一点，CentOS 7预设容许任何帐号透过ssh登入（也就是说自己根本不用改改，直接新建帐号登录即可），包括根和一般帐号，为了不受根帐号被黑客暴力入侵，我们必须禁止 root帐号的ssh功能，事实上root也没有必要ssh登入伺服器，因为只要使用su或sudo（当然需要输入root的密码）普通帐号便可以拥有root的权限。使用vim（或任何文本编辑器）开启的/ etc/ SSH/ sshd_config中，寻找：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">＃PermitRootLogin <span class=\"literal\">yes</span></span><br></pre></td></tr></table></figure>\n<p>修改：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">PermitRootLogin</span> <span class=\"literal\">no</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置公私钥加密登录\"><a href=\"#配置公私钥加密登录\" class=\"headerlink\" title=\"配置公私钥加密登录\"></a>配置公私钥加密登录</h3><p><strong>这一步骤要切换到自己新建的用户，不能再用 root 用户了，否则可能无法正常登陆。</strong></p>\n<p>很多时候以上所说的还是不够安全，为了更加安全方便，我们采用公私钥对称加密登录，简单的讲做法就是再客户端生成一把私钥一把公钥，私钥是在客户端的，公钥上传到服务端，对称加密进行登录。</p>\n<p>在客户端先进到这个目录：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cd</span> ~<span class=\"string\">/.ssh</span></span><br></pre></td></tr></table></figure>\n\n<p>生成公钥和私钥（实际上如果之前有的话就不用重新生成了）</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">ssh-keygen -t rsa</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来把公钥上传到服务端</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp ~/.ssh/id_rsa.pub <span class=\"symbol\">xiaotao@<span class=\"keyword\">&lt;ssh_server_ip&gt;</span></span>:~</span><br></pre></td></tr></table></figure>\n\n<p>在服务端执行以下命令(如果没有相关的文件和文件夹要先进行创建，注意不要使用 sudo )</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat  id_rsa.pub &gt;&gt; ～<span class=\"regexp\">/.ssh/</span>authorized_keys</span><br></pre></td></tr></table></figure>\n\n<p>配置服务器的/etc/ssh/sshd_config，下面是一些建议的配置：</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/ssh/sshd_config</span><br><span class=\"line\"><span class=\"meta\"># 禁用root账户登录，非必要，但为了安全性，请配置</span></span><br><span class=\"line\">PermitRootLogin no</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 是否让 sshd 去检查用户家目录或相关档案的权限数据，</span></span><br><span class=\"line\"><span class=\"meta\"># 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。</span></span><br><span class=\"line\"><span class=\"meta\"># 例如使用者的 ~.ssh/ 权限设错时，某些特殊情况下会不许用户登入</span></span><br><span class=\"line\">StrictModes no</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。</span></span><br><span class=\"line\"><span class=\"meta\"># 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内</span></span><br><span class=\"line\">RSAAuthentication yes</span><br><span class=\"line\">PubkeyAuthentication yes</span><br><span class=\"line\">AuthorizedKeysFile      %h/.ssh/authorized_keys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#有了证书登录了，就禁用密码登录吧，安全要紧</span></span><br><span class=\"line\">PasswordAuthentication no</span><br></pre></td></tr></table></figure>\n\n<p>然后不要忘记 <code>sudo service sshd restart</code></p>\n<p>一般来讲，这样就算是成功了，我们可以在客户端尝试：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -i ~<span class=\"regexp\">/.ssh/i</span>d_rsa remote_username<span class=\"meta\">@remote_ip</span></span><br></pre></td></tr></table></figure>\n\n<p>如果不行，可能是服务端或客户端相关 <code>.ssh</code> 文件权限不对，可以进行如下尝试：</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务端</span><br><span class=\"line\"><span class=\"keyword\">chown</span> -R <span class=\"number\">0700</span>  ~<span class=\"regexp\">/.ssh</span></span><br><span class=\"line\"><span class=\"regexp\">chown -R 0644  ~/</span>.ssh/authorized_keys</span><br><span class=\"line\"></span><br><span class=\"line\">客户端改一下</span><br><span class=\"line\"><span class=\"keyword\">chmod</span> <span class=\"number\">600</span> id_rsa</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>当我们开始使用一个新的服务器的时候，首先一定要对服务器的登陆等做一些修改工作，笔者曾经就因为对服务器登陆安全没有重视，导致服务器数据全部丢失。接下来我们按照步骤，罗列出应该做的一些事情。</p>\n</blockquote>\n<h3 id=\"修改ssh端口号\"><a href=\"#修改ssh端口号\" class=\"headerlink\" title=\"修改ssh端口号\"></a>修改ssh端口号</h3><p>第一件事情：</p>\n<p>修改ssh端口号： 之后加上一个端口比如说50000</p>\n<p><code>vi /etc/ssh/sshd_config</code>之后在port字段加上一个端口比如说50000，原来的端口号字段可能是被注释掉的，要先解除注释。</p>\n<p>然后执行：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">service sshd restart</span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候可能还要重新配置一下防火墙，开放50000端口，具体如何配置也可以参考<a href=\"https://blog.csdn.net/ul646691993/article/details/52104082\">这里</a>的后半部分。但是目前，阿里云的服务器实测是不需要再配置防火墙的，但是需要去登陆到网页后台修改安全组。</p>\n<p>之后就可以通过这样的方式登录了：(注意登录方式一定要写对)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh root@115.29.102.81 -p 50000</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><p>这个时候我们还是用root进行操作，所以我们接下来要给自己创建一个账户，比如创建一个如下的用户：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">useradd xiaotao</span></span><br><span class=\"line\"><span class=\"attribute\">passwd xiaotao</span></span><br></pre></td></tr></table></figure>\n\n<p>可以用`ls -al /home/``查看一下账户</p>\n<p>对创建的这个用户增加sudo权限： 相关配置文件/etc/sudoers中，但是这个文件是只读的，所以要更改一下权限</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">chmod</span> u+w sudoers</span><br></pre></td></tr></table></figure>\n\n<p>然后进入这个文件在这里进行更改：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root    <span class=\"keyword\">ALL</span>=(<span class=\"keyword\">ALL</span>)       <span class=\"keyword\">ALL</span></span><br><span class=\"line\">xiaotao  <span class=\"keyword\">ALL</span>=(<span class=\"keyword\">ALL</span>)       <span class=\"keyword\">ALL</span></span><br></pre></td></tr></table></figure>\n\n<p>然后再改回权限：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">chmod u-w sudoers</span></span><br></pre></td></tr></table></figure>\n\n<p>注意一点，CentOS 7预设容许任何帐号透过ssh登入（也就是说自己根本不用改改，直接新建帐号登录即可），包括根和一般帐号，为了不受根帐号被黑客暴力入侵，我们必须禁止 root帐号的ssh功能，事实上root也没有必要ssh登入伺服器，因为只要使用su或sudo（当然需要输入root的密码）普通帐号便可以拥有root的权限。使用vim（或任何文本编辑器）开启的/ etc/ SSH/ sshd_config中，寻找：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">＃PermitRootLogin <span class=\"literal\">yes</span></span><br></pre></td></tr></table></figure>\n<p>修改：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">PermitRootLogin</span> <span class=\"literal\">no</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置公私钥加密登录\"><a href=\"#配置公私钥加密登录\" class=\"headerlink\" title=\"配置公私钥加密登录\"></a>配置公私钥加密登录</h3><p><strong>这一步骤要切换到自己新建的用户，不能再用 root 用户了，否则可能无法正常登陆。</strong></p>\n<p>很多时候以上所说的还是不够安全，为了更加安全方便，我们采用公私钥对称加密登录，简单的讲做法就是再客户端生成一把私钥一把公钥，私钥是在客户端的，公钥上传到服务端，对称加密进行登录。</p>\n<p>在客户端先进到这个目录：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cd</span> ~<span class=\"string\">/.ssh</span></span><br></pre></td></tr></table></figure>\n\n<p>生成公钥和私钥（实际上如果之前有的话就不用重新生成了）</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">ssh-keygen -t rsa</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来把公钥上传到服务端</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp ~/.ssh/id_rsa.pub <span class=\"symbol\">xiaotao@<span class=\"keyword\">&lt;ssh_server_ip&gt;</span></span>:~</span><br></pre></td></tr></table></figure>\n\n<p>在服务端执行以下命令(如果没有相关的文件和文件夹要先进行创建，注意不要使用 sudo )</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat  id_rsa.pub &gt;&gt; ～<span class=\"regexp\">/.ssh/</span>authorized_keys</span><br></pre></td></tr></table></figure>\n\n<p>配置服务器的/etc/ssh/sshd_config，下面是一些建议的配置：</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/ssh/sshd_config</span><br><span class=\"line\"><span class=\"meta\"># 禁用root账户登录，非必要，但为了安全性，请配置</span></span><br><span class=\"line\">PermitRootLogin no</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 是否让 sshd 去检查用户家目录或相关档案的权限数据，</span></span><br><span class=\"line\"><span class=\"meta\"># 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。</span></span><br><span class=\"line\"><span class=\"meta\"># 例如使用者的 ~.ssh/ 权限设错时，某些特殊情况下会不许用户登入</span></span><br><span class=\"line\">StrictModes no</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。</span></span><br><span class=\"line\"><span class=\"meta\"># 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内</span></span><br><span class=\"line\">RSAAuthentication yes</span><br><span class=\"line\">PubkeyAuthentication yes</span><br><span class=\"line\">AuthorizedKeysFile      %h/.ssh/authorized_keys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#有了证书登录了，就禁用密码登录吧，安全要紧</span></span><br><span class=\"line\">PasswordAuthentication no</span><br></pre></td></tr></table></figure>\n\n<p>然后不要忘记 <code>sudo service sshd restart</code></p>\n<p>一般来讲，这样就算是成功了，我们可以在客户端尝试：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -i ~<span class=\"regexp\">/.ssh/i</span>d_rsa remote_username<span class=\"meta\">@remote_ip</span></span><br></pre></td></tr></table></figure>\n\n<p>如果不行，可能是服务端或客户端相关 <code>.ssh</code> 文件权限不对，可以进行如下尝试：</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务端</span><br><span class=\"line\"><span class=\"keyword\">chown</span> -R <span class=\"number\">0700</span>  ~<span class=\"regexp\">/.ssh</span></span><br><span class=\"line\"><span class=\"regexp\">chown -R 0644  ~/</span>.ssh/authorized_keys</span><br><span class=\"line\"></span><br><span class=\"line\">客户端改一下</span><br><span class=\"line\"><span class=\"keyword\">chmod</span> <span class=\"number\">600</span> id_rsa</span><br></pre></td></tr></table></figure>"},{"title":"Node.js 的 TCP 链接管理","abbrlink":2459824913,"date":"2018-11-25T11:23:09.000Z","_content":"\n在 Node.js 的微服务中，一般不同的服务模块我们会采用 TCP 进行通信，本文来简单谈一谈如何设计 TCP 服务的基础管理。\n\n>在具体设计上，本文参考了微服务框架 [Seneca](https://github.com/senecajs/seneca) 所采用的通信方案 [Seneca-transport](https://github.com/senecajs/seneca-transport)，已经被实践所证明其可行性。\n\n一提到 TCP 通信，我们肯定离不开 `net` 模块，事实上，借助 `net` 模块，我们也可以比较快速地完成一般的 TCP 通信的任务。\n\n为了避免对基础的遗忘，我们还是先附上一个基本的 TCP 链接代码：\n\n```javascript\n//server.js:\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n    socket.write('goodbye\\n');\n    socket.on('data', (data) => {\n        console.log('data:', data.toString());\n        socket.write('goodbye\\n');\n    })\n}).on('error', (err) => {\n    throw err;\n});\n\n// grab an arbitrary unused port.\nserver.listen(8024, () => {\n    console.log('opened server on', server.address());\n});\n\n//client.js:\nconst net = require('net');\n\nconst client = net.createConnection({ port: 8024 }, () => {\n    //'connect' listener\n    console.log('connected to server!');\n    client.write('world!\\r\\n');\n    setInterval(() => {\n        client.write('world!\\r\\n');\n    }, 1000)\n});\nclient.on('data', (data) => {\n    console.log(data.toString());\n    // client.end();\n});\nclient.on('end', () => {\n    console.log('disconnected from server');\n});\n```\n\n其实，上述已经是一个几乎最简单的客户端和服务端通信 Demo，但是并不能在实际项目中使用，首先我们需要审视，其离生产环境还差哪些内容：\n\n1. 以上要求 Server 端要在 Client 端之前启动，并且一旦因为一些错误导致 Server 端重启了并且这个时候 Client 端正好和 Server 端进行通信，那么肯定会 crash，所以，我们需要一个更为平滑兼容的方案。\n2. 以上 TCP 链接的 Server 部分，并没有对 connection 进行管理的能力，并且在在以上的例子中，双方都没有主动释放链接，也就是说，建立的是一个 TCP 长连接。\n3. 以上链接的处理数据能力有限，只能处理纯文本的内容，并且还有一定的风险性（你也许会说可以用 JSON 的序列化反序列化的方法来处理 JSON 数据，但是你别忘了 `socket.on('data'...` 很可能接收到的不是一个完整的 JSON，如果 JSON 较长，其可能只接收到一般的内容，这个时候如果直接 `JSON.parse())` 很可能就会报错）。\n\n以上三个问题，便是我们要解决的主要问题，如果你看过之后立刻知道该如何解决了，那么这篇文章可能你不需要看了，否则，我们可以一起继续探索解决方案。\n\n### 使用 reconnect-core\n\n[reconnect-core](https://www.npmjs.com/package/reconnect-core) 是一个和协议无关的链接重试算法，其工作方式也比较简单，当你需要在 Client 端建立链接的时候，其流程是这样的：\n\n* 调用事先传入的链接建立函数，如果这个时候返回成功了，即成功建立链接。\n* 如果第一次建立链接失败了，那么再隔一段时间建立第二次，如果第二次还是失败，那么再隔一段更长的时间建立第三次，如果还是失败，那么再隔更长的一段时间……直到到达最大的尝试次数。\n\n实际上关于尝试的时间间隔，也会有不同的策略，比较常用的是 Fibonacci 策略和 exponential 策略。\n\n当然，关于策略的具体实现，reconnect-core 采用了一个 [backoff](https://www.npmjs.com/package/backoff) 的库来管理，其可以支持  Fibonacci 策略和 exponential 策略以及更多的自定义策略。\n\n对于上面提到的 DEMO 代码。我们给出 Client 端使用 reconnect-core 的一个实现：\n\n```javascript\n//client.js:\nconst Reconnect = require('reconnect-core');\nconst net = require('net');\nconst Ndjson = require('ndjson');\n\nconst Connect = Reconnect(function() {\n    var args = [].slice.call(arguments);\n    return net.connect.apply(null, args)\n});\n\nlet connection = Connect(function(socket) {\n    socket.write('world!\\r\\n');\n    socket.on('data', (msg) => {\n        console.log('data', msg.toString());\n    });\n    socket.on('close', (msg) => {\n        console.log('close', msg).toString();\n        connection.disconnect();\n    });\n    socket.on('end', () => {\n        console.log('end');\n    });\n});\n\nconnection.connect({\n    port: 8024\n});\nconnection.on('reconnect', function () {\n    console.log('on reconnect...')\n});\nconnection.on('error', function (err) {\n   console.log('error:', err);\n});\nconnection.on('disconnect', function (err) {\n   console.log('disconnect:', err);\n});\n```\n>采用 Reconnect 实际上相比之前是多了一层内容，我们在这里需要区分 connection 实例和 socket 句柄，并且附加正确的时间监听。\n\n现在，我们就不用担心到底是先启动服务端还是先启动客户端了，另外，就算我们的服务端在启动之后由于某些错误关闭了一会，只要没超过最大时间（而这个也是可配置的），仍然不用担心客户端与其建立连接。\n\n\n### 给 Server 端增加管理能力\n\n给 Server 端增加管理能力是一个比较必要的并且可以做成不同程度的，一般来说，最重要的功能则是及时清理链接，常用的做法是收到某条指令之后进行清理，或者到达一定时间之后定时清理。\n\n这里我们可以增加一个功能，达到一定时间之后，自动清理所有链接：\n\n```javascript\n//server.js\nconst net = require('net');\n\nvar connections = [];\n\nconst server = net.createServer((socket) => {\n    connections.push(socket);\n    socket.write('goodbye\\n');\n    socket.on('data', (data) => {\n        console.log('data:', data.toString());\n        socket.write('goodbye\\n');\n    })\n}).on('error', (err) => {\n    throw err;\n});\n\nsetTimeout(() => {\n    console.log('clear connections');\n    connections.forEach((connection) => {\n        connection.end('end')\n        // connection.destory()\n    })\n}, 10000);\n\n// grab an arbitrary unused port.\nserver.listen(8024, () => {\n    console.log('opened server on', server.address());\n});\n```\n\n我们可以通过`connection.end('end')` 和 `connection.destory()` 来清理，一般来说，前者是正常情况下的关闭指令，需要 Client 端进行确认，而后者则是强制关闭，一般在出错的时候会这样调用。\n\n### 使用 ndjson 来格式化数据\n\n[ndjson](https://www.npmjs.com/package/ndjson) 是一个比较方便的 JSON 序列化/反序列化库，相比于我们直接用 JSON，其好处主要体现在：\n\n* 可以同时解析多个 JSON 对象，如果是一个文件流，即其可以包含多个 `{}`，但是要求则是每一个占据一行，其按行分割并且解析。\n* 内部使用了 [split2](https://www.npmjs.com/package/split2)，好处就是其返回时可以保证该行的所有内容已经接受完毕，从而防止 ndjson 在序列化的时候出错。\n\n关于 ndjson 的基本使用，可以根据上述链接查找文档，这里一般情况下，我们的使用方式如下（以下是一个 demo）：\n\n```javascript\n//server.js:\nconst net = require('net');\n\nvar connections = [];\n\nconst server = net.createServer((socket) => {\n    connections.push(socket);\n    socket.on('data', (data) => {\n        console.log('data:', data.toString());\n        socket.write('{\"good\": 1234}\\r\\n');\n        socket.write('{\"good\": 4567}\\n\\n');\n    })\n}).on('error', (err) => {\n    throw err;\n});\n\n// grab an arbitrary unused port.\nserver.listen(8024, () => {\n    console.log('opened server on', server.address());\n});\n\n//client.js:\nconst Reconnect = require('reconnect-core');\nconst net = require('net');\nconst Ndjson = require('ndjson');\nvar Stream = require('stream');\n\nconst Connect = Reconnect(function() {\n    var args = [].slice.call(arguments);\n    return net.connect.apply(null, args)\n});\n\nlet connection = Connect(function(socket) {\n    socket.write('world!\\r\\n');\n    var parser = Ndjson.parse();\n    var stringifier = Ndjson.stringify();\n\n    function yourhandler(){\n        var messager = new Stream.Duplex({ objectMode: true });\n        messager._read = function () {\n            // console.log('data:', data);\n        };\n        messager._write = function (data, enc, callback) {\n            console.log(typeof data, data);\n            // your handler\n            return callback()\n        };\n        return messager\n    }\n    socket // 链接句柄\n        .pipe(parser)\n        .pipe(yourhandler())\n        .pipe(stringifier)\n        .pipe(socket);\n\n    socket.on('close', (msg) => {\n        console.log('close', msg).toString();\n        connection.disconnect();\n    });\n    socket.on('end', (msg) => {\n        console.log('end', msg);\n    });\n});\nconnection.connect({\n    port: 8024\n});\nconnection.on('reconnect', function () {\n    console.log('on reconnect...')\n});\nconnection.on('error', function (err) {\n   console.log('error:', err);\n});\nconnection.on('disconnect', function (err) {\n   console.log('disconnect:', err);\n});\n```\n\n其中，用户具体的逻辑代码，可以是 `yourhandler` 函数 `_write` 里面的一部分，其接收的是一个一个处理好的对象。\n\n","source":"_posts/Node-js的TCP链接管理.md","raw":"---\ntitle: Node.js 的 TCP 链接管理\ntags:\n  - TCP\n  - Node.js\nabbrlink: 2459824913\ndate: 2018-11-25 19:23:09\n---\n\n在 Node.js 的微服务中，一般不同的服务模块我们会采用 TCP 进行通信，本文来简单谈一谈如何设计 TCP 服务的基础管理。\n\n>在具体设计上，本文参考了微服务框架 [Seneca](https://github.com/senecajs/seneca) 所采用的通信方案 [Seneca-transport](https://github.com/senecajs/seneca-transport)，已经被实践所证明其可行性。\n\n一提到 TCP 通信，我们肯定离不开 `net` 模块，事实上，借助 `net` 模块，我们也可以比较快速地完成一般的 TCP 通信的任务。\n\n为了避免对基础的遗忘，我们还是先附上一个基本的 TCP 链接代码：\n\n```javascript\n//server.js:\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n    socket.write('goodbye\\n');\n    socket.on('data', (data) => {\n        console.log('data:', data.toString());\n        socket.write('goodbye\\n');\n    })\n}).on('error', (err) => {\n    throw err;\n});\n\n// grab an arbitrary unused port.\nserver.listen(8024, () => {\n    console.log('opened server on', server.address());\n});\n\n//client.js:\nconst net = require('net');\n\nconst client = net.createConnection({ port: 8024 }, () => {\n    //'connect' listener\n    console.log('connected to server!');\n    client.write('world!\\r\\n');\n    setInterval(() => {\n        client.write('world!\\r\\n');\n    }, 1000)\n});\nclient.on('data', (data) => {\n    console.log(data.toString());\n    // client.end();\n});\nclient.on('end', () => {\n    console.log('disconnected from server');\n});\n```\n\n其实，上述已经是一个几乎最简单的客户端和服务端通信 Demo，但是并不能在实际项目中使用，首先我们需要审视，其离生产环境还差哪些内容：\n\n1. 以上要求 Server 端要在 Client 端之前启动，并且一旦因为一些错误导致 Server 端重启了并且这个时候 Client 端正好和 Server 端进行通信，那么肯定会 crash，所以，我们需要一个更为平滑兼容的方案。\n2. 以上 TCP 链接的 Server 部分，并没有对 connection 进行管理的能力，并且在在以上的例子中，双方都没有主动释放链接，也就是说，建立的是一个 TCP 长连接。\n3. 以上链接的处理数据能力有限，只能处理纯文本的内容，并且还有一定的风险性（你也许会说可以用 JSON 的序列化反序列化的方法来处理 JSON 数据，但是你别忘了 `socket.on('data'...` 很可能接收到的不是一个完整的 JSON，如果 JSON 较长，其可能只接收到一般的内容，这个时候如果直接 `JSON.parse())` 很可能就会报错）。\n\n以上三个问题，便是我们要解决的主要问题，如果你看过之后立刻知道该如何解决了，那么这篇文章可能你不需要看了，否则，我们可以一起继续探索解决方案。\n\n### 使用 reconnect-core\n\n[reconnect-core](https://www.npmjs.com/package/reconnect-core) 是一个和协议无关的链接重试算法，其工作方式也比较简单，当你需要在 Client 端建立链接的时候，其流程是这样的：\n\n* 调用事先传入的链接建立函数，如果这个时候返回成功了，即成功建立链接。\n* 如果第一次建立链接失败了，那么再隔一段时间建立第二次，如果第二次还是失败，那么再隔一段更长的时间建立第三次，如果还是失败，那么再隔更长的一段时间……直到到达最大的尝试次数。\n\n实际上关于尝试的时间间隔，也会有不同的策略，比较常用的是 Fibonacci 策略和 exponential 策略。\n\n当然，关于策略的具体实现，reconnect-core 采用了一个 [backoff](https://www.npmjs.com/package/backoff) 的库来管理，其可以支持  Fibonacci 策略和 exponential 策略以及更多的自定义策略。\n\n对于上面提到的 DEMO 代码。我们给出 Client 端使用 reconnect-core 的一个实现：\n\n```javascript\n//client.js:\nconst Reconnect = require('reconnect-core');\nconst net = require('net');\nconst Ndjson = require('ndjson');\n\nconst Connect = Reconnect(function() {\n    var args = [].slice.call(arguments);\n    return net.connect.apply(null, args)\n});\n\nlet connection = Connect(function(socket) {\n    socket.write('world!\\r\\n');\n    socket.on('data', (msg) => {\n        console.log('data', msg.toString());\n    });\n    socket.on('close', (msg) => {\n        console.log('close', msg).toString();\n        connection.disconnect();\n    });\n    socket.on('end', () => {\n        console.log('end');\n    });\n});\n\nconnection.connect({\n    port: 8024\n});\nconnection.on('reconnect', function () {\n    console.log('on reconnect...')\n});\nconnection.on('error', function (err) {\n   console.log('error:', err);\n});\nconnection.on('disconnect', function (err) {\n   console.log('disconnect:', err);\n});\n```\n>采用 Reconnect 实际上相比之前是多了一层内容，我们在这里需要区分 connection 实例和 socket 句柄，并且附加正确的时间监听。\n\n现在，我们就不用担心到底是先启动服务端还是先启动客户端了，另外，就算我们的服务端在启动之后由于某些错误关闭了一会，只要没超过最大时间（而这个也是可配置的），仍然不用担心客户端与其建立连接。\n\n\n### 给 Server 端增加管理能力\n\n给 Server 端增加管理能力是一个比较必要的并且可以做成不同程度的，一般来说，最重要的功能则是及时清理链接，常用的做法是收到某条指令之后进行清理，或者到达一定时间之后定时清理。\n\n这里我们可以增加一个功能，达到一定时间之后，自动清理所有链接：\n\n```javascript\n//server.js\nconst net = require('net');\n\nvar connections = [];\n\nconst server = net.createServer((socket) => {\n    connections.push(socket);\n    socket.write('goodbye\\n');\n    socket.on('data', (data) => {\n        console.log('data:', data.toString());\n        socket.write('goodbye\\n');\n    })\n}).on('error', (err) => {\n    throw err;\n});\n\nsetTimeout(() => {\n    console.log('clear connections');\n    connections.forEach((connection) => {\n        connection.end('end')\n        // connection.destory()\n    })\n}, 10000);\n\n// grab an arbitrary unused port.\nserver.listen(8024, () => {\n    console.log('opened server on', server.address());\n});\n```\n\n我们可以通过`connection.end('end')` 和 `connection.destory()` 来清理，一般来说，前者是正常情况下的关闭指令，需要 Client 端进行确认，而后者则是强制关闭，一般在出错的时候会这样调用。\n\n### 使用 ndjson 来格式化数据\n\n[ndjson](https://www.npmjs.com/package/ndjson) 是一个比较方便的 JSON 序列化/反序列化库，相比于我们直接用 JSON，其好处主要体现在：\n\n* 可以同时解析多个 JSON 对象，如果是一个文件流，即其可以包含多个 `{}`，但是要求则是每一个占据一行，其按行分割并且解析。\n* 内部使用了 [split2](https://www.npmjs.com/package/split2)，好处就是其返回时可以保证该行的所有内容已经接受完毕，从而防止 ndjson 在序列化的时候出错。\n\n关于 ndjson 的基本使用，可以根据上述链接查找文档，这里一般情况下，我们的使用方式如下（以下是一个 demo）：\n\n```javascript\n//server.js:\nconst net = require('net');\n\nvar connections = [];\n\nconst server = net.createServer((socket) => {\n    connections.push(socket);\n    socket.on('data', (data) => {\n        console.log('data:', data.toString());\n        socket.write('{\"good\": 1234}\\r\\n');\n        socket.write('{\"good\": 4567}\\n\\n');\n    })\n}).on('error', (err) => {\n    throw err;\n});\n\n// grab an arbitrary unused port.\nserver.listen(8024, () => {\n    console.log('opened server on', server.address());\n});\n\n//client.js:\nconst Reconnect = require('reconnect-core');\nconst net = require('net');\nconst Ndjson = require('ndjson');\nvar Stream = require('stream');\n\nconst Connect = Reconnect(function() {\n    var args = [].slice.call(arguments);\n    return net.connect.apply(null, args)\n});\n\nlet connection = Connect(function(socket) {\n    socket.write('world!\\r\\n');\n    var parser = Ndjson.parse();\n    var stringifier = Ndjson.stringify();\n\n    function yourhandler(){\n        var messager = new Stream.Duplex({ objectMode: true });\n        messager._read = function () {\n            // console.log('data:', data);\n        };\n        messager._write = function (data, enc, callback) {\n            console.log(typeof data, data);\n            // your handler\n            return callback()\n        };\n        return messager\n    }\n    socket // 链接句柄\n        .pipe(parser)\n        .pipe(yourhandler())\n        .pipe(stringifier)\n        .pipe(socket);\n\n    socket.on('close', (msg) => {\n        console.log('close', msg).toString();\n        connection.disconnect();\n    });\n    socket.on('end', (msg) => {\n        console.log('end', msg);\n    });\n});\nconnection.connect({\n    port: 8024\n});\nconnection.on('reconnect', function () {\n    console.log('on reconnect...')\n});\nconnection.on('error', function (err) {\n   console.log('error:', err);\n});\nconnection.on('disconnect', function (err) {\n   console.log('disconnect:', err);\n});\n```\n\n其中，用户具体的逻辑代码，可以是 `yourhandler` 函数 `_write` 里面的一部分，其接收的是一个一个处理好的对象。\n\n","slug":"Node-js的TCP链接管理","published":1,"updated":"2021-12-23T05:50:07.538Z","_id":"ckxijpqsk000ad3mrbcp46vj1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在 Node.js 的微服务中，一般不同的服务模块我们会采用 TCP 进行通信，本文来简单谈一谈如何设计 TCP 服务的基础管理。</p>\n<blockquote>\n<p>在具体设计上，本文参考了微服务框架 <a href=\"https://github.com/senecajs/seneca\">Seneca</a> 所采用的通信方案 <a href=\"https://github.com/senecajs/seneca-transport\">Seneca-transport</a>，已经被实践所证明其可行性。</p>\n</blockquote>\n<p>一提到 TCP 通信，我们肯定离不开 <code>net</code> 模块，事实上，借助 <code>net</code> 模块，我们也可以比较快速地完成一般的 TCP 通信的任务。</p>\n<p>为了避免对基础的遗忘，我们还是先附上一个基本的 TCP 链接代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//server.js:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer(<span class=\"function\">(<span class=\"params\">socket</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    socket.write(<span class=\"string\">&#x27;goodbye\\n&#x27;</span>);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;data:&#x27;</span>, data.toString());</span><br><span class=\"line\">        socket.write(<span class=\"string\">&#x27;goodbye\\n&#x27;</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// grab an arbitrary unused port.</span></span><br><span class=\"line\">server.listen(<span class=\"number\">8024</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;opened server on&#x27;</span>, server.address());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//client.js:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> client = net.createConnection(&#123; <span class=\"attr\">port</span>: <span class=\"number\">8024</span> &#125;, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//&#x27;connect&#x27; listener</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;connected to server!&#x27;</span>);</span><br><span class=\"line\">    client.write(<span class=\"string\">&#x27;world!\\r\\n&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        client.write(<span class=\"string\">&#x27;world!\\r\\n&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">client.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data.toString());</span><br><span class=\"line\">    <span class=\"comment\">// client.end();</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">client.on(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;disconnected from server&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其实，上述已经是一个几乎最简单的客户端和服务端通信 Demo，但是并不能在实际项目中使用，首先我们需要审视，其离生产环境还差哪些内容：</p>\n<ol>\n<li>以上要求 Server 端要在 Client 端之前启动，并且一旦因为一些错误导致 Server 端重启了并且这个时候 Client 端正好和 Server 端进行通信，那么肯定会 crash，所以，我们需要一个更为平滑兼容的方案。</li>\n<li>以上 TCP 链接的 Server 部分，并没有对 connection 进行管理的能力，并且在在以上的例子中，双方都没有主动释放链接，也就是说，建立的是一个 TCP 长连接。</li>\n<li>以上链接的处理数据能力有限，只能处理纯文本的内容，并且还有一定的风险性（你也许会说可以用 JSON 的序列化反序列化的方法来处理 JSON 数据，但是你别忘了 <code>socket.on(&#39;data&#39;...</code> 很可能接收到的不是一个完整的 JSON，如果 JSON 较长，其可能只接收到一般的内容，这个时候如果直接 <code>JSON.parse())</code> 很可能就会报错）。</li>\n</ol>\n<p>以上三个问题，便是我们要解决的主要问题，如果你看过之后立刻知道该如何解决了，那么这篇文章可能你不需要看了，否则，我们可以一起继续探索解决方案。</p>\n<h3 id=\"使用-reconnect-core\"><a href=\"#使用-reconnect-core\" class=\"headerlink\" title=\"使用 reconnect-core\"></a>使用 reconnect-core</h3><p><a href=\"https://www.npmjs.com/package/reconnect-core\">reconnect-core</a> 是一个和协议无关的链接重试算法，其工作方式也比较简单，当你需要在 Client 端建立链接的时候，其流程是这样的：</p>\n<ul>\n<li>调用事先传入的链接建立函数，如果这个时候返回成功了，即成功建立链接。</li>\n<li>如果第一次建立链接失败了，那么再隔一段时间建立第二次，如果第二次还是失败，那么再隔一段更长的时间建立第三次，如果还是失败，那么再隔更长的一段时间……直到到达最大的尝试次数。</li>\n</ul>\n<p>实际上关于尝试的时间间隔，也会有不同的策略，比较常用的是 Fibonacci 策略和 exponential 策略。</p>\n<p>当然，关于策略的具体实现，reconnect-core 采用了一个 <a href=\"https://www.npmjs.com/package/backoff\">backoff</a> 的库来管理，其可以支持  Fibonacci 策略和 exponential 策略以及更多的自定义策略。</p>\n<p>对于上面提到的 DEMO 代码。我们给出 Client 端使用 reconnect-core 的一个实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//client.js:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Reconnect = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;reconnect-core&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Ndjson = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;ndjson&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Connect = Reconnect(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = [].slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> net.connect.apply(<span class=\"literal\">null</span>, args)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> connection = Connect(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">    socket.write(<span class=\"string\">&#x27;world!\\r\\n&#x27;</span>);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">msg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;data&#x27;</span>, msg.toString());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"function\">(<span class=\"params\">msg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;close&#x27;</span>, msg).toString();</span><br><span class=\"line\">        connection.disconnect();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;end&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">connection.connect(&#123;</span><br><span class=\"line\">    <span class=\"attr\">port</span>: <span class=\"number\">8024</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;reconnect&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;on reconnect...&#x27;</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;error:&#x27;</span>, err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;disconnect&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;disconnect:&#x27;</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>采用 Reconnect 实际上相比之前是多了一层内容，我们在这里需要区分 connection 实例和 socket 句柄，并且附加正确的时间监听。</p>\n</blockquote>\n<p>现在，我们就不用担心到底是先启动服务端还是先启动客户端了，另外，就算我们的服务端在启动之后由于某些错误关闭了一会，只要没超过最大时间（而这个也是可配置的），仍然不用担心客户端与其建立连接。</p>\n<h3 id=\"给-Server-端增加管理能力\"><a href=\"#给-Server-端增加管理能力\" class=\"headerlink\" title=\"给 Server 端增加管理能力\"></a>给 Server 端增加管理能力</h3><p>给 Server 端增加管理能力是一个比较必要的并且可以做成不同程度的，一般来说，最重要的功能则是及时清理链接，常用的做法是收到某条指令之后进行清理，或者到达一定时间之后定时清理。</p>\n<p>这里我们可以增加一个功能，达到一定时间之后，自动清理所有链接：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//server.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> connections = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer(<span class=\"function\">(<span class=\"params\">socket</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    connections.push(socket);</span><br><span class=\"line\">    socket.write(<span class=\"string\">&#x27;goodbye\\n&#x27;</span>);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;data:&#x27;</span>, data.toString());</span><br><span class=\"line\">        socket.write(<span class=\"string\">&#x27;goodbye\\n&#x27;</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;clear connections&#x27;</span>);</span><br><span class=\"line\">    connections.forEach(<span class=\"function\">(<span class=\"params\">connection</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        connection.end(<span class=\"string\">&#x27;end&#x27;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// connection.destory()</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, <span class=\"number\">10000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// grab an arbitrary unused port.</span></span><br><span class=\"line\">server.listen(<span class=\"number\">8024</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;opened server on&#x27;</span>, server.address());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过<code>connection.end(&#39;end&#39;)</code> 和 <code>connection.destory()</code> 来清理，一般来说，前者是正常情况下的关闭指令，需要 Client 端进行确认，而后者则是强制关闭，一般在出错的时候会这样调用。</p>\n<h3 id=\"使用-ndjson-来格式化数据\"><a href=\"#使用-ndjson-来格式化数据\" class=\"headerlink\" title=\"使用 ndjson 来格式化数据\"></a>使用 ndjson 来格式化数据</h3><p><a href=\"https://www.npmjs.com/package/ndjson\">ndjson</a> 是一个比较方便的 JSON 序列化/反序列化库，相比于我们直接用 JSON，其好处主要体现在：</p>\n<ul>\n<li>可以同时解析多个 JSON 对象，如果是一个文件流，即其可以包含多个 <code>&#123;&#125;</code>，但是要求则是每一个占据一行，其按行分割并且解析。</li>\n<li>内部使用了 <a href=\"https://www.npmjs.com/package/split2\">split2</a>，好处就是其返回时可以保证该行的所有内容已经接受完毕，从而防止 ndjson 在序列化的时候出错。</li>\n</ul>\n<p>关于 ndjson 的基本使用，可以根据上述链接查找文档，这里一般情况下，我们的使用方式如下（以下是一个 demo）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//server.js:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> connections = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer(<span class=\"function\">(<span class=\"params\">socket</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    connections.push(socket);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;data:&#x27;</span>, data.toString());</span><br><span class=\"line\">        socket.write(<span class=\"string\">&#x27;&#123;&quot;good&quot;: 1234&#125;\\r\\n&#x27;</span>);</span><br><span class=\"line\">        socket.write(<span class=\"string\">&#x27;&#123;&quot;good&quot;: 4567&#125;\\n\\n&#x27;</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// grab an arbitrary unused port.</span></span><br><span class=\"line\">server.listen(<span class=\"number\">8024</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;opened server on&#x27;</span>, server.address());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//client.js:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Reconnect = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;reconnect-core&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Ndjson = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;ndjson&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> Stream = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;stream&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Connect = Reconnect(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = [].slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> net.connect.apply(<span class=\"literal\">null</span>, args)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> connection = Connect(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">    socket.write(<span class=\"string\">&#x27;world!\\r\\n&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> parser = Ndjson.parse();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stringifier = Ndjson.stringify();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">yourhandler</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> messager = <span class=\"keyword\">new</span> Stream.Duplex(&#123; <span class=\"attr\">objectMode</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">        messager._read = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// console.log(&#x27;data:&#x27;, data);</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        messager._write = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data, enc, callback</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> data, data);</span><br><span class=\"line\">            <span class=\"comment\">// your handler</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> callback()</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> messager</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    socket <span class=\"comment\">// 链接句柄</span></span><br><span class=\"line\">        .pipe(parser)</span><br><span class=\"line\">        .pipe(yourhandler())</span><br><span class=\"line\">        .pipe(stringifier)</span><br><span class=\"line\">        .pipe(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"function\">(<span class=\"params\">msg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;close&#x27;</span>, msg).toString();</span><br><span class=\"line\">        connection.disconnect();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\">(<span class=\"params\">msg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;end&#x27;</span>, msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.connect(&#123;</span><br><span class=\"line\">    <span class=\"attr\">port</span>: <span class=\"number\">8024</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;reconnect&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;on reconnect...&#x27;</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;error:&#x27;</span>, err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;disconnect&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;disconnect:&#x27;</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其中，用户具体的逻辑代码，可以是 <code>yourhandler</code> 函数 <code>_write</code> 里面的一部分，其接收的是一个一个处理好的对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 Node.js 的微服务中，一般不同的服务模块我们会采用 TCP 进行通信，本文来简单谈一谈如何设计 TCP 服务的基础管理。</p>\n<blockquote>\n<p>在具体设计上，本文参考了微服务框架 <a href=\"https://github.com/senecajs/seneca\">Seneca</a> 所采用的通信方案 <a href=\"https://github.com/senecajs/seneca-transport\">Seneca-transport</a>，已经被实践所证明其可行性。</p>\n</blockquote>\n<p>一提到 TCP 通信，我们肯定离不开 <code>net</code> 模块，事实上，借助 <code>net</code> 模块，我们也可以比较快速地完成一般的 TCP 通信的任务。</p>\n<p>为了避免对基础的遗忘，我们还是先附上一个基本的 TCP 链接代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//server.js:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer(<span class=\"function\">(<span class=\"params\">socket</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    socket.write(<span class=\"string\">&#x27;goodbye\\n&#x27;</span>);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;data:&#x27;</span>, data.toString());</span><br><span class=\"line\">        socket.write(<span class=\"string\">&#x27;goodbye\\n&#x27;</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// grab an arbitrary unused port.</span></span><br><span class=\"line\">server.listen(<span class=\"number\">8024</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;opened server on&#x27;</span>, server.address());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//client.js:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> client = net.createConnection(&#123; <span class=\"attr\">port</span>: <span class=\"number\">8024</span> &#125;, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//&#x27;connect&#x27; listener</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;connected to server!&#x27;</span>);</span><br><span class=\"line\">    client.write(<span class=\"string\">&#x27;world!\\r\\n&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        client.write(<span class=\"string\">&#x27;world!\\r\\n&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">client.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data.toString());</span><br><span class=\"line\">    <span class=\"comment\">// client.end();</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">client.on(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;disconnected from server&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其实，上述已经是一个几乎最简单的客户端和服务端通信 Demo，但是并不能在实际项目中使用，首先我们需要审视，其离生产环境还差哪些内容：</p>\n<ol>\n<li>以上要求 Server 端要在 Client 端之前启动，并且一旦因为一些错误导致 Server 端重启了并且这个时候 Client 端正好和 Server 端进行通信，那么肯定会 crash，所以，我们需要一个更为平滑兼容的方案。</li>\n<li>以上 TCP 链接的 Server 部分，并没有对 connection 进行管理的能力，并且在在以上的例子中，双方都没有主动释放链接，也就是说，建立的是一个 TCP 长连接。</li>\n<li>以上链接的处理数据能力有限，只能处理纯文本的内容，并且还有一定的风险性（你也许会说可以用 JSON 的序列化反序列化的方法来处理 JSON 数据，但是你别忘了 <code>socket.on(&#39;data&#39;...</code> 很可能接收到的不是一个完整的 JSON，如果 JSON 较长，其可能只接收到一般的内容，这个时候如果直接 <code>JSON.parse())</code> 很可能就会报错）。</li>\n</ol>\n<p>以上三个问题，便是我们要解决的主要问题，如果你看过之后立刻知道该如何解决了，那么这篇文章可能你不需要看了，否则，我们可以一起继续探索解决方案。</p>\n<h3 id=\"使用-reconnect-core\"><a href=\"#使用-reconnect-core\" class=\"headerlink\" title=\"使用 reconnect-core\"></a>使用 reconnect-core</h3><p><a href=\"https://www.npmjs.com/package/reconnect-core\">reconnect-core</a> 是一个和协议无关的链接重试算法，其工作方式也比较简单，当你需要在 Client 端建立链接的时候，其流程是这样的：</p>\n<ul>\n<li>调用事先传入的链接建立函数，如果这个时候返回成功了，即成功建立链接。</li>\n<li>如果第一次建立链接失败了，那么再隔一段时间建立第二次，如果第二次还是失败，那么再隔一段更长的时间建立第三次，如果还是失败，那么再隔更长的一段时间……直到到达最大的尝试次数。</li>\n</ul>\n<p>实际上关于尝试的时间间隔，也会有不同的策略，比较常用的是 Fibonacci 策略和 exponential 策略。</p>\n<p>当然，关于策略的具体实现，reconnect-core 采用了一个 <a href=\"https://www.npmjs.com/package/backoff\">backoff</a> 的库来管理，其可以支持  Fibonacci 策略和 exponential 策略以及更多的自定义策略。</p>\n<p>对于上面提到的 DEMO 代码。我们给出 Client 端使用 reconnect-core 的一个实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//client.js:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Reconnect = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;reconnect-core&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Ndjson = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;ndjson&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Connect = Reconnect(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = [].slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> net.connect.apply(<span class=\"literal\">null</span>, args)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> connection = Connect(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">    socket.write(<span class=\"string\">&#x27;world!\\r\\n&#x27;</span>);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">msg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;data&#x27;</span>, msg.toString());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"function\">(<span class=\"params\">msg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;close&#x27;</span>, msg).toString();</span><br><span class=\"line\">        connection.disconnect();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;end&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">connection.connect(&#123;</span><br><span class=\"line\">    <span class=\"attr\">port</span>: <span class=\"number\">8024</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;reconnect&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;on reconnect...&#x27;</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;error:&#x27;</span>, err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;disconnect&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;disconnect:&#x27;</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>采用 Reconnect 实际上相比之前是多了一层内容，我们在这里需要区分 connection 实例和 socket 句柄，并且附加正确的时间监听。</p>\n</blockquote>\n<p>现在，我们就不用担心到底是先启动服务端还是先启动客户端了，另外，就算我们的服务端在启动之后由于某些错误关闭了一会，只要没超过最大时间（而这个也是可配置的），仍然不用担心客户端与其建立连接。</p>\n<h3 id=\"给-Server-端增加管理能力\"><a href=\"#给-Server-端增加管理能力\" class=\"headerlink\" title=\"给 Server 端增加管理能力\"></a>给 Server 端增加管理能力</h3><p>给 Server 端增加管理能力是一个比较必要的并且可以做成不同程度的，一般来说，最重要的功能则是及时清理链接，常用的做法是收到某条指令之后进行清理，或者到达一定时间之后定时清理。</p>\n<p>这里我们可以增加一个功能，达到一定时间之后，自动清理所有链接：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//server.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> connections = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer(<span class=\"function\">(<span class=\"params\">socket</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    connections.push(socket);</span><br><span class=\"line\">    socket.write(<span class=\"string\">&#x27;goodbye\\n&#x27;</span>);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;data:&#x27;</span>, data.toString());</span><br><span class=\"line\">        socket.write(<span class=\"string\">&#x27;goodbye\\n&#x27;</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;clear connections&#x27;</span>);</span><br><span class=\"line\">    connections.forEach(<span class=\"function\">(<span class=\"params\">connection</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        connection.end(<span class=\"string\">&#x27;end&#x27;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// connection.destory()</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, <span class=\"number\">10000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// grab an arbitrary unused port.</span></span><br><span class=\"line\">server.listen(<span class=\"number\">8024</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;opened server on&#x27;</span>, server.address());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过<code>connection.end(&#39;end&#39;)</code> 和 <code>connection.destory()</code> 来清理，一般来说，前者是正常情况下的关闭指令，需要 Client 端进行确认，而后者则是强制关闭，一般在出错的时候会这样调用。</p>\n<h3 id=\"使用-ndjson-来格式化数据\"><a href=\"#使用-ndjson-来格式化数据\" class=\"headerlink\" title=\"使用 ndjson 来格式化数据\"></a>使用 ndjson 来格式化数据</h3><p><a href=\"https://www.npmjs.com/package/ndjson\">ndjson</a> 是一个比较方便的 JSON 序列化/反序列化库，相比于我们直接用 JSON，其好处主要体现在：</p>\n<ul>\n<li>可以同时解析多个 JSON 对象，如果是一个文件流，即其可以包含多个 <code>&#123;&#125;</code>，但是要求则是每一个占据一行，其按行分割并且解析。</li>\n<li>内部使用了 <a href=\"https://www.npmjs.com/package/split2\">split2</a>，好处就是其返回时可以保证该行的所有内容已经接受完毕，从而防止 ndjson 在序列化的时候出错。</li>\n</ul>\n<p>关于 ndjson 的基本使用，可以根据上述链接查找文档，这里一般情况下，我们的使用方式如下（以下是一个 demo）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//server.js:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> connections = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer(<span class=\"function\">(<span class=\"params\">socket</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    connections.push(socket);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;data:&#x27;</span>, data.toString());</span><br><span class=\"line\">        socket.write(<span class=\"string\">&#x27;&#123;&quot;good&quot;: 1234&#125;\\r\\n&#x27;</span>);</span><br><span class=\"line\">        socket.write(<span class=\"string\">&#x27;&#123;&quot;good&quot;: 4567&#125;\\n\\n&#x27;</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// grab an arbitrary unused port.</span></span><br><span class=\"line\">server.listen(<span class=\"number\">8024</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;opened server on&#x27;</span>, server.address());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//client.js:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Reconnect = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;reconnect-core&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Ndjson = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;ndjson&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> Stream = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;stream&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Connect = Reconnect(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = [].slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> net.connect.apply(<span class=\"literal\">null</span>, args)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> connection = Connect(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">    socket.write(<span class=\"string\">&#x27;world!\\r\\n&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> parser = Ndjson.parse();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stringifier = Ndjson.stringify();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">yourhandler</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> messager = <span class=\"keyword\">new</span> Stream.Duplex(&#123; <span class=\"attr\">objectMode</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">        messager._read = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// console.log(&#x27;data:&#x27;, data);</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        messager._write = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data, enc, callback</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> data, data);</span><br><span class=\"line\">            <span class=\"comment\">// your handler</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> callback()</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> messager</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    socket <span class=\"comment\">// 链接句柄</span></span><br><span class=\"line\">        .pipe(parser)</span><br><span class=\"line\">        .pipe(yourhandler())</span><br><span class=\"line\">        .pipe(stringifier)</span><br><span class=\"line\">        .pipe(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"function\">(<span class=\"params\">msg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;close&#x27;</span>, msg).toString();</span><br><span class=\"line\">        connection.disconnect();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    socket.on(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\">(<span class=\"params\">msg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;end&#x27;</span>, msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.connect(&#123;</span><br><span class=\"line\">    <span class=\"attr\">port</span>: <span class=\"number\">8024</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;reconnect&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;on reconnect...&#x27;</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;error:&#x27;</span>, err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;disconnect&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;disconnect:&#x27;</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其中，用户具体的逻辑代码，可以是 <code>yourhandler</code> 函数 <code>_write</code> 里面的一部分，其接收的是一个一个处理好的对象。</p>\n"},{"title":"Rust初探:实现二叉树的增删与遍历","abbrlink":2092659821,"date":"2019-09-07T15:57:28.000Z","_content":"\n### Rust 简介\n\n实际上自己接触 Rust 的时间还是很有限的，这里也不会对 Rust 进行长篇大论地介绍，简单来说，Rust 是一个性能和 c++ 相近的系统级编程语言，同时，由于其所有权与变量生命周期等机制的设计，使其相对于 c++ 来说拥有内存安全的优势，几乎不会出现诸如悬垂指针、数组越界、段错误等问题，在微软、百度、字节跳动等公司均有所使用。\n\n关于 Rust 的特性以及未来，知乎[这个问题中的一些高赞回答以及相关的评论](https://www.zhihu.com/question/30407715)，非常值得一看。\n\n本文会以二叉树这样一个具体的例子出发，来对 Rust 的一部分知识内容进行学习。\n\n### 实现二叉树数据结构\n\n#### 定义结构\n\n之前在 Javascript 等语言中，我们只要对对象有所了解，实现一个二叉树的数据结构是非常简单的事情，而在 Rust 中，可能对于新手来说仅仅是实现基本的数据结构就是一个比较脑壳疼的事情。\n\n我们一般会写出类似这样的代码：\n\n```\nstruct Tree {\n    value: i32,\n    left: Tree, // 直接使用 Tree 是不行的\n    right: Tree  \n}\n```\n\n自然不会通过 Rust 的编译检查，会报错例如：`recursive type has infinite size`，不过其同时给我们提供了解决方案，这里我们使用 `Box<T>` 指针。\n\n另外，考虑到二叉树的左右子树可能为空，所以这里我们还需要增加一个 `Option`。\n\n最终我们的二叉树数据结构定义如下：\n\n```\n#[derive(Debug, Default)]\nstruct Tree {\n    value: i32,\n    left: Option<Box<Tree>>,\n    right: Option<Box<Tree>>   \n}\n```\n\n#### 实现基本的方法\n\n这里我们实现一些二叉树的基本的方法，作为上述结构体的方法，我们将实现以下方法：\n\n* 获取二叉树节点的值（其实也可以没有这个方法）。\n* 修改二叉树节点的值。\n* 设置子树。\n* 删除子树。\n\n这里除了第一个，其余我们都需要传递 `self` 的可变引用，我们的实现如下：\n\n```\nimpl Tree {\n    fn get_val(&self) -> i32 {\n        return self.value;\n    }\n    fn set_val(&mut self, val: i32) -> i32 {\n        self.value = val;\n        return self.value;\n    }\n    fn insert(&mut self, dir: &String, val: Tree) {\n        assert!(dir == \"left\" || dir == \"right\");\n        match dir.as_ref() {\n            \"left\" => self.left = Some(Box::new(val)),\n            \"right\" => self.right = Some(Box::new(val)),\n            _ => { \n                println!(\"Insert Error: only left and right supported\");\n                process::exit(1);\n            }\n        }\n    }\n    fn delete(&mut self, dir: &String) {\n        assert!(dir == \"left\" || dir == \"right\");\n        match dir.as_ref() {\n                \"left\" => self.left = None,\n                \"right\" => self.right = None,\n                 _ => { \n                    println!(\"Insert Error: only left and right supported\");\n                    process::exit(1);\n                }\n        }\n    }\n}\n```\n\n### 遍历二叉树\n\n这里遍历二叉树我们作为一个单独的方法，而不是属性方法来实现，这样会更符合我们平时的业务场景，这里其实问题比较多的，我们先简易实现一个版本：\n\n```\nfn traverse(tree: Tree) {\n    println!(\"Node Value: {:?}\", tree.value);\n    if tree.left.is_some() {\n        traverse(*tree.left.unwrap()); // 手动解引用\n    }\n    if tree.right.is_some() {\n        traverse(*tree.right.unwrap()); // 手动解引用\n    }\n}\n```\n\n如果我们测试一下这个版本，发现的确能够正常遍历的，但是实际上这有一个致命的问题：\n\n这里采用的是所有权的移动，而不是不可变借用，这会导致我们的函数执行完后原来变量的所有权已经被移动了，换一种说法则是会消耗掉这个变量，这显然不是我们预期的。\n\n虽然我们也可以在函数中返回 tree 的方式来最后再次移动所有权，但这样非常不便于实现，经过重构，我们采用了如下的方式实现：\n\n```\nfn traverse(tree: &Tree) {\n    println!(\"Node Value: {:?}\", tree.value);\n    match tree.left {\n        Some(ref x) => traverse(x),\n        _ => {}\n    }\n    match tree.right {\n        Some(ref x) => traverse(x),\n        _ => {}\n    }\n}\n```\n\n>另外一个注意点则是由于 `unwrap()` 本身是一个消耗性操作，我们这里不能使用 `unwrap`，参考[stackOverflow的提问1](https://stackoverflow.com/questions/22282117/how-do-i-borrow-a-reference-to-what-is-inside-an-optiont)、[stackOverflow的提问2](https://stackoverflow.com/questions/32338659/cannot-move-out-of-borrowed-content-when-unwrapping)。\n\n我们最终的完整代码如下：\n\n```\nuse::std::process;\nuse std::borrow::Borrow;\n#[derive(Debug, Default)]\nstruct Tree {\n    value: i32,\n    left: Option<Box<Tree>>,\n    right: Option<Box<Tree>>   \n}\n\nimpl Tree {\n    fn get_val(&self) -> i32 {\n        return self.value;\n    }\n    fn set_val(&mut self, val: i32) -> i32 {\n        self.value = val;\n        return self.value;\n    }\n    fn insert(&mut self, dir: &String, val: Tree) {\n        assert!(dir == \"left\" || dir == \"right\");\n        match dir.as_ref() {\n            \"left\" => self.left = Some(Box::new(val)),\n            \"right\" => self.right = Some(Box::new(val)),\n            _ => { \n                println!(\"Insert Error: only left and right supported\");\n                process::exit(1);\n            }\n        }\n    }\n    fn delete(&mut self, dir: &String) {\n        assert!(dir == \"left\" || dir == \"right\");\n        match dir.as_ref() {\n                \"left\" => self.left = None,\n                \"right\" => self.right = None,\n                 _ => { \n                    println!(\"Insert Error: only left and right supported\");\n                    process::exit(1);\n                }\n        }\n    }\n}\n\n// 原始的非消耗性遍历:\n// fn traverse(tree: &Tree) {\n//     println!(\"Node Value: {:?}\", tree.value);\n//     if tree.left.is_some() {\n//         // cannot move out of borrowed content\n//         // 首先 unwrap 是一个消耗性操作\n//         // 这是由于 unwrap 函数造成?  as_ref 也不行\n//         traverse((tree.left.as_ref().map(|x| **x).unwrap()).borrow());\n//     }\n//     // if tree.right.is_some() {\n//     //     // cannot move out of borrowed content\n//     //     traverse(tree.right.unwrap().borrow());\n//     // }\n// }\n\n// 非消耗性遍历\nfn traverse(tree: &Tree) {\n    println!(\"Node Value: {:?}\", tree.value);\n    match tree.left {\n        Some(ref x) => traverse(x),\n        _ => {}\n    }\n    match tree.right {\n        Some(ref x) => traverse(x),\n        _ => {}\n    }\n}\n\n// 消耗性遍历：\n// fn traverse(tree: Tree) {\n//     println!(\"Node Value: {:?}\", tree.value);\n//     if tree.left.is_some() {\n//         traverse(*tree.left.unwrap()); // 手动解引用\n//     }\n//     if tree.right.is_some() {\n//         traverse(*tree.right.unwrap()); // 手动解引用\n//     }\n// }\n\nfn main() {\n    println!(\"begin rust tree test:\");\n    let mut tree = Tree { value : 12, ..Default::default() };\n    let mut left = Tree { value : 121, ..Default::default() };\n    tree.insert(&String::from(\"left\"), left);\n    let mut right = Tree { value : 122, ..Default::default() };\n    tree.insert(&String::from(\"right\"), right);\n    // tree.delete(&String::from(\"right\"));\n    // println!(\"Tree val: {:?}\", left.get_val()); 不能这样写，所有权已经被移动\n    traverse(&tree);\n    // traverse(tree);\n}\n```","source":"_posts/Rust初探-实现二叉树的增删与遍历.md","raw":"---\ntitle: 'Rust初探:实现二叉树的增删与遍历'\ntags:\n  - Rust\nabbrlink: 2092659821\ndate: 2019-09-07 23:57:28\n---\n\n### Rust 简介\n\n实际上自己接触 Rust 的时间还是很有限的，这里也不会对 Rust 进行长篇大论地介绍，简单来说，Rust 是一个性能和 c++ 相近的系统级编程语言，同时，由于其所有权与变量生命周期等机制的设计，使其相对于 c++ 来说拥有内存安全的优势，几乎不会出现诸如悬垂指针、数组越界、段错误等问题，在微软、百度、字节跳动等公司均有所使用。\n\n关于 Rust 的特性以及未来，知乎[这个问题中的一些高赞回答以及相关的评论](https://www.zhihu.com/question/30407715)，非常值得一看。\n\n本文会以二叉树这样一个具体的例子出发，来对 Rust 的一部分知识内容进行学习。\n\n### 实现二叉树数据结构\n\n#### 定义结构\n\n之前在 Javascript 等语言中，我们只要对对象有所了解，实现一个二叉树的数据结构是非常简单的事情，而在 Rust 中，可能对于新手来说仅仅是实现基本的数据结构就是一个比较脑壳疼的事情。\n\n我们一般会写出类似这样的代码：\n\n```\nstruct Tree {\n    value: i32,\n    left: Tree, // 直接使用 Tree 是不行的\n    right: Tree  \n}\n```\n\n自然不会通过 Rust 的编译检查，会报错例如：`recursive type has infinite size`，不过其同时给我们提供了解决方案，这里我们使用 `Box<T>` 指针。\n\n另外，考虑到二叉树的左右子树可能为空，所以这里我们还需要增加一个 `Option`。\n\n最终我们的二叉树数据结构定义如下：\n\n```\n#[derive(Debug, Default)]\nstruct Tree {\n    value: i32,\n    left: Option<Box<Tree>>,\n    right: Option<Box<Tree>>   \n}\n```\n\n#### 实现基本的方法\n\n这里我们实现一些二叉树的基本的方法，作为上述结构体的方法，我们将实现以下方法：\n\n* 获取二叉树节点的值（其实也可以没有这个方法）。\n* 修改二叉树节点的值。\n* 设置子树。\n* 删除子树。\n\n这里除了第一个，其余我们都需要传递 `self` 的可变引用，我们的实现如下：\n\n```\nimpl Tree {\n    fn get_val(&self) -> i32 {\n        return self.value;\n    }\n    fn set_val(&mut self, val: i32) -> i32 {\n        self.value = val;\n        return self.value;\n    }\n    fn insert(&mut self, dir: &String, val: Tree) {\n        assert!(dir == \"left\" || dir == \"right\");\n        match dir.as_ref() {\n            \"left\" => self.left = Some(Box::new(val)),\n            \"right\" => self.right = Some(Box::new(val)),\n            _ => { \n                println!(\"Insert Error: only left and right supported\");\n                process::exit(1);\n            }\n        }\n    }\n    fn delete(&mut self, dir: &String) {\n        assert!(dir == \"left\" || dir == \"right\");\n        match dir.as_ref() {\n                \"left\" => self.left = None,\n                \"right\" => self.right = None,\n                 _ => { \n                    println!(\"Insert Error: only left and right supported\");\n                    process::exit(1);\n                }\n        }\n    }\n}\n```\n\n### 遍历二叉树\n\n这里遍历二叉树我们作为一个单独的方法，而不是属性方法来实现，这样会更符合我们平时的业务场景，这里其实问题比较多的，我们先简易实现一个版本：\n\n```\nfn traverse(tree: Tree) {\n    println!(\"Node Value: {:?}\", tree.value);\n    if tree.left.is_some() {\n        traverse(*tree.left.unwrap()); // 手动解引用\n    }\n    if tree.right.is_some() {\n        traverse(*tree.right.unwrap()); // 手动解引用\n    }\n}\n```\n\n如果我们测试一下这个版本，发现的确能够正常遍历的，但是实际上这有一个致命的问题：\n\n这里采用的是所有权的移动，而不是不可变借用，这会导致我们的函数执行完后原来变量的所有权已经被移动了，换一种说法则是会消耗掉这个变量，这显然不是我们预期的。\n\n虽然我们也可以在函数中返回 tree 的方式来最后再次移动所有权，但这样非常不便于实现，经过重构，我们采用了如下的方式实现：\n\n```\nfn traverse(tree: &Tree) {\n    println!(\"Node Value: {:?}\", tree.value);\n    match tree.left {\n        Some(ref x) => traverse(x),\n        _ => {}\n    }\n    match tree.right {\n        Some(ref x) => traverse(x),\n        _ => {}\n    }\n}\n```\n\n>另外一个注意点则是由于 `unwrap()` 本身是一个消耗性操作，我们这里不能使用 `unwrap`，参考[stackOverflow的提问1](https://stackoverflow.com/questions/22282117/how-do-i-borrow-a-reference-to-what-is-inside-an-optiont)、[stackOverflow的提问2](https://stackoverflow.com/questions/32338659/cannot-move-out-of-borrowed-content-when-unwrapping)。\n\n我们最终的完整代码如下：\n\n```\nuse::std::process;\nuse std::borrow::Borrow;\n#[derive(Debug, Default)]\nstruct Tree {\n    value: i32,\n    left: Option<Box<Tree>>,\n    right: Option<Box<Tree>>   \n}\n\nimpl Tree {\n    fn get_val(&self) -> i32 {\n        return self.value;\n    }\n    fn set_val(&mut self, val: i32) -> i32 {\n        self.value = val;\n        return self.value;\n    }\n    fn insert(&mut self, dir: &String, val: Tree) {\n        assert!(dir == \"left\" || dir == \"right\");\n        match dir.as_ref() {\n            \"left\" => self.left = Some(Box::new(val)),\n            \"right\" => self.right = Some(Box::new(val)),\n            _ => { \n                println!(\"Insert Error: only left and right supported\");\n                process::exit(1);\n            }\n        }\n    }\n    fn delete(&mut self, dir: &String) {\n        assert!(dir == \"left\" || dir == \"right\");\n        match dir.as_ref() {\n                \"left\" => self.left = None,\n                \"right\" => self.right = None,\n                 _ => { \n                    println!(\"Insert Error: only left and right supported\");\n                    process::exit(1);\n                }\n        }\n    }\n}\n\n// 原始的非消耗性遍历:\n// fn traverse(tree: &Tree) {\n//     println!(\"Node Value: {:?}\", tree.value);\n//     if tree.left.is_some() {\n//         // cannot move out of borrowed content\n//         // 首先 unwrap 是一个消耗性操作\n//         // 这是由于 unwrap 函数造成?  as_ref 也不行\n//         traverse((tree.left.as_ref().map(|x| **x).unwrap()).borrow());\n//     }\n//     // if tree.right.is_some() {\n//     //     // cannot move out of borrowed content\n//     //     traverse(tree.right.unwrap().borrow());\n//     // }\n// }\n\n// 非消耗性遍历\nfn traverse(tree: &Tree) {\n    println!(\"Node Value: {:?}\", tree.value);\n    match tree.left {\n        Some(ref x) => traverse(x),\n        _ => {}\n    }\n    match tree.right {\n        Some(ref x) => traverse(x),\n        _ => {}\n    }\n}\n\n// 消耗性遍历：\n// fn traverse(tree: Tree) {\n//     println!(\"Node Value: {:?}\", tree.value);\n//     if tree.left.is_some() {\n//         traverse(*tree.left.unwrap()); // 手动解引用\n//     }\n//     if tree.right.is_some() {\n//         traverse(*tree.right.unwrap()); // 手动解引用\n//     }\n// }\n\nfn main() {\n    println!(\"begin rust tree test:\");\n    let mut tree = Tree { value : 12, ..Default::default() };\n    let mut left = Tree { value : 121, ..Default::default() };\n    tree.insert(&String::from(\"left\"), left);\n    let mut right = Tree { value : 122, ..Default::default() };\n    tree.insert(&String::from(\"right\"), right);\n    // tree.delete(&String::from(\"right\"));\n    // println!(\"Tree val: {:?}\", left.get_val()); 不能这样写，所有权已经被移动\n    traverse(&tree);\n    // traverse(tree);\n}\n```","slug":"Rust初探-实现二叉树的增删与遍历","published":1,"updated":"2021-12-23T05:50:07.539Z","_id":"ckxijpqsl000bd3mrefh84cfi","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Rust-简介\"><a href=\"#Rust-简介\" class=\"headerlink\" title=\"Rust 简介\"></a>Rust 简介</h3><p>实际上自己接触 Rust 的时间还是很有限的，这里也不会对 Rust 进行长篇大论地介绍，简单来说，Rust 是一个性能和 c++ 相近的系统级编程语言，同时，由于其所有权与变量生命周期等机制的设计，使其相对于 c++ 来说拥有内存安全的优势，几乎不会出现诸如悬垂指针、数组越界、段错误等问题，在微软、百度、字节跳动等公司均有所使用。</p>\n<p>关于 Rust 的特性以及未来，知乎<a href=\"https://www.zhihu.com/question/30407715\">这个问题中的一些高赞回答以及相关的评论</a>，非常值得一看。</p>\n<p>本文会以二叉树这样一个具体的例子出发，来对 Rust 的一部分知识内容进行学习。</p>\n<h3 id=\"实现二叉树数据结构\"><a href=\"#实现二叉树数据结构\" class=\"headerlink\" title=\"实现二叉树数据结构\"></a>实现二叉树数据结构</h3><h4 id=\"定义结构\"><a href=\"#定义结构\" class=\"headerlink\" title=\"定义结构\"></a>定义结构</h4><p>之前在 Javascript 等语言中，我们只要对对象有所了解，实现一个二叉树的数据结构是非常简单的事情，而在 Rust 中，可能对于新手来说仅仅是实现基本的数据结构就是一个比较脑壳疼的事情。</p>\n<p>我们一般会写出类似这样的代码：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct <span class=\"class\">Tree </span>&#123;</span><br><span class=\"line\"><span class=\"symbol\">    value:</span> i32,</span><br><span class=\"line\"><span class=\"symbol\">    left:</span> Tree, <span class=\"comment\">// 直接使用 Tree 是不行的</span></span><br><span class=\"line\"><span class=\"symbol\">    right:</span> Tree  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自然不会通过 Rust 的编译检查，会报错例如：<code>recursive type has infinite size</code>，不过其同时给我们提供了解决方案，这里我们使用 <code>Box&lt;T&gt;</code> 指针。</p>\n<p>另外，考虑到二叉树的左右子树可能为空，所以这里我们还需要增加一个 <code>Option</code>。</p>\n<p>最终我们的二叉树数据结构定义如下：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Debug, Default)]</span></span><br><span class=\"line\">struct <span class=\"class\">Tree </span>&#123;</span><br><span class=\"line\"><span class=\"symbol\">    value:</span> i32,</span><br><span class=\"line\"><span class=\"symbol\">    left:</span> Option<span class=\"params\">&lt;Box&lt;Tree&gt;</span>&gt;,</span><br><span class=\"line\"><span class=\"symbol\">    right:</span> Option<span class=\"params\">&lt;Box&lt;Tree&gt;</span>&gt;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实现基本的方法\"><a href=\"#实现基本的方法\" class=\"headerlink\" title=\"实现基本的方法\"></a>实现基本的方法</h4><p>这里我们实现一些二叉树的基本的方法，作为上述结构体的方法，我们将实现以下方法：</p>\n<ul>\n<li>获取二叉树节点的值（其实也可以没有这个方法）。</li>\n<li>修改二叉树节点的值。</li>\n<li>设置子树。</li>\n<li>删除子树。</li>\n</ul>\n<p>这里除了第一个，其余我们都需要传递 <code>self</code> 的可变引用，我们的实现如下：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Tree &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_val</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">set_val</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, val: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">insert</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, dir: &amp;<span class=\"built_in\">String</span>, val: Tree) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert!</span>(dir == <span class=\"string\">&quot;left&quot;</span> || dir == <span class=\"string\">&quot;right&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">match</span> dir.as_ref() &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;left&quot;</span> =&gt; <span class=\"keyword\">self</span>.left = <span class=\"literal\">Some</span>(<span class=\"built_in\">Box</span>::new(val)),</span><br><span class=\"line\">            <span class=\"string\">&quot;right&quot;</span> =&gt; <span class=\"keyword\">self</span>.right = <span class=\"literal\">Some</span>(<span class=\"built_in\">Box</span>::new(val)),</span><br><span class=\"line\">            _ =&gt; &#123; </span><br><span class=\"line\">                <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class=\"line\">                process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">delete</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, dir: &amp;<span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert!</span>(dir == <span class=\"string\">&quot;left&quot;</span> || dir == <span class=\"string\">&quot;right&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">match</span> dir.as_ref() &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;left&quot;</span> =&gt; <span class=\"keyword\">self</span>.left = <span class=\"literal\">None</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;right&quot;</span> =&gt; <span class=\"keyword\">self</span>.right = <span class=\"literal\">None</span>,</span><br><span class=\"line\">                 _ =&gt; &#123; </span><br><span class=\"line\">                    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class=\"line\">                    process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遍历二叉树\"><a href=\"#遍历二叉树\" class=\"headerlink\" title=\"遍历二叉树\"></a>遍历二叉树</h3><p>这里遍历二叉树我们作为一个单独的方法，而不是属性方法来实现，这样会更符合我们平时的业务场景，这里其实问题比较多的，我们先简易实现一个版本：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">fn</span> <span class=\"selector-tag\">traverse</span>(<span class=\"attribute\">tree</span>: Tree) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">println</span>!(<span class=\"string\">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> <span class=\"selector-tag\">tree</span><span class=\"selector-class\">.left</span><span class=\"selector-class\">.is_some</span>() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">traverse</span>(*tree.left.unwrap()); <span class=\"comment\">// 手动解引用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> <span class=\"selector-tag\">tree</span><span class=\"selector-class\">.right</span><span class=\"selector-class\">.is_some</span>() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">traverse</span>(*tree.right.unwrap()); <span class=\"comment\">// 手动解引用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们测试一下这个版本，发现的确能够正常遍历的，但是实际上这有一个致命的问题：</p>\n<p>这里采用的是所有权的移动，而不是不可变借用，这会导致我们的函数执行完后原来变量的所有权已经被移动了，换一种说法则是会消耗掉这个变量，这显然不是我们预期的。</p>\n<p>虽然我们也可以在函数中返回 tree 的方式来最后再次移动所有权，但这样非常不便于实现，经过重构，我们采用了如下的方式实现：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn traverse(tree: &amp;Tree) &#123;</span><br><span class=\"line\">    println!(<span class=\"string\">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class=\"line\">    <span class=\"keyword\">match</span> tree.left &#123;</span><br><span class=\"line\">        <span class=\"constructor\">Some(<span class=\"params\">ref</span> <span class=\"params\">x</span>)</span> =&gt; traverse(x),</span><br><span class=\"line\">       <span class=\"function\"> <span class=\"params\">_</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">match</span> tree.right &#123;</span><br><span class=\"line\">        <span class=\"constructor\">Some(<span class=\"params\">ref</span> <span class=\"params\">x</span>)</span> =&gt; traverse(x),</span><br><span class=\"line\">       <span class=\"function\"> <span class=\"params\">_</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另外一个注意点则是由于 <code>unwrap()</code> 本身是一个消耗性操作，我们这里不能使用 <code>unwrap</code>，参考<a href=\"https://stackoverflow.com/questions/22282117/how-do-i-borrow-a-reference-to-what-is-inside-an-optiont\">stackOverflow的提问1</a>、<a href=\"https://stackoverflow.com/questions/32338659/cannot-move-out-of-borrowed-content-when-unwrapping\">stackOverflow的提问2</a>。</p>\n</blockquote>\n<p>我们最终的完整代码如下：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use::std::process;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::borrow::Borrow;</span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug, Default)]</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Tree</span></span> &#123;</span><br><span class=\"line\">    value: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">    left: <span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">Box</span>&lt;Tree&gt;&gt;,</span><br><span class=\"line\">    right: <span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">Box</span>&lt;Tree&gt;&gt;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Tree &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_val</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">set_val</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, val: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">insert</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, dir: &amp;<span class=\"built_in\">String</span>, val: Tree) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert!</span>(dir == <span class=\"string\">&quot;left&quot;</span> || dir == <span class=\"string\">&quot;right&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">match</span> dir.as_ref() &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;left&quot;</span> =&gt; <span class=\"keyword\">self</span>.left = <span class=\"literal\">Some</span>(<span class=\"built_in\">Box</span>::new(val)),</span><br><span class=\"line\">            <span class=\"string\">&quot;right&quot;</span> =&gt; <span class=\"keyword\">self</span>.right = <span class=\"literal\">Some</span>(<span class=\"built_in\">Box</span>::new(val)),</span><br><span class=\"line\">            _ =&gt; &#123; </span><br><span class=\"line\">                <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class=\"line\">                process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">delete</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, dir: &amp;<span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert!</span>(dir == <span class=\"string\">&quot;left&quot;</span> || dir == <span class=\"string\">&quot;right&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">match</span> dir.as_ref() &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;left&quot;</span> =&gt; <span class=\"keyword\">self</span>.left = <span class=\"literal\">None</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;right&quot;</span> =&gt; <span class=\"keyword\">self</span>.right = <span class=\"literal\">None</span>,</span><br><span class=\"line\">                 _ =&gt; &#123; </span><br><span class=\"line\">                    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class=\"line\">                    process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原始的非消耗性遍历:</span></span><br><span class=\"line\"><span class=\"comment\">// fn traverse(tree: &amp;Tree) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     println!(&quot;Node Value: &#123;:?&#125;&quot;, tree.value);</span></span><br><span class=\"line\"><span class=\"comment\">//     if tree.left.is_some() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         // cannot move out of borrowed content</span></span><br><span class=\"line\"><span class=\"comment\">//         // 首先 unwrap 是一个消耗性操作</span></span><br><span class=\"line\"><span class=\"comment\">//         // 这是由于 unwrap 函数造成?  as_ref 也不行</span></span><br><span class=\"line\"><span class=\"comment\">//         traverse((tree.left.as_ref().map(|x| **x).unwrap()).borrow());</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     // if tree.right.is_some() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     //     // cannot move out of borrowed content</span></span><br><span class=\"line\"><span class=\"comment\">//     //     traverse(tree.right.unwrap().borrow());</span></span><br><span class=\"line\"><span class=\"comment\">//     // &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非消耗性遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">traverse</span></span>(tree: &amp;Tree) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class=\"line\">    <span class=\"keyword\">match</span> tree.left &#123;</span><br><span class=\"line\">        <span class=\"literal\">Some</span>(<span class=\"keyword\">ref</span> x) =&gt; traverse(x),</span><br><span class=\"line\">        _ =&gt; &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">match</span> tree.right &#123;</span><br><span class=\"line\">        <span class=\"literal\">Some</span>(<span class=\"keyword\">ref</span> x) =&gt; traverse(x),</span><br><span class=\"line\">        _ =&gt; &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 消耗性遍历：</span></span><br><span class=\"line\"><span class=\"comment\">// fn traverse(tree: Tree) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     println!(&quot;Node Value: &#123;:?&#125;&quot;, tree.value);</span></span><br><span class=\"line\"><span class=\"comment\">//     if tree.left.is_some() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         traverse(*tree.left.unwrap()); // 手动解引用</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     if tree.right.is_some() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         traverse(*tree.right.unwrap()); // 手动解引用</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;begin rust tree test:&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> tree = Tree &#123; value : <span class=\"number\">12</span>, ..<span class=\"built_in\">Default</span>::default() &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> left = Tree &#123; value : <span class=\"number\">121</span>, ..<span class=\"built_in\">Default</span>::default() &#125;;</span><br><span class=\"line\">    tree.insert(&amp;<span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;left&quot;</span>), left);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> right = Tree &#123; value : <span class=\"number\">122</span>, ..<span class=\"built_in\">Default</span>::default() &#125;;</span><br><span class=\"line\">    tree.insert(&amp;<span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;right&quot;</span>), right);</span><br><span class=\"line\">    <span class=\"comment\">// tree.delete(&amp;String::from(&quot;right&quot;));</span></span><br><span class=\"line\">    <span class=\"comment\">// println!(&quot;Tree val: &#123;:?&#125;&quot;, left.get_val()); 不能这样写，所有权已经被移动</span></span><br><span class=\"line\">    traverse(&amp;tree);</span><br><span class=\"line\">    <span class=\"comment\">// traverse(tree);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Rust-简介\"><a href=\"#Rust-简介\" class=\"headerlink\" title=\"Rust 简介\"></a>Rust 简介</h3><p>实际上自己接触 Rust 的时间还是很有限的，这里也不会对 Rust 进行长篇大论地介绍，简单来说，Rust 是一个性能和 c++ 相近的系统级编程语言，同时，由于其所有权与变量生命周期等机制的设计，使其相对于 c++ 来说拥有内存安全的优势，几乎不会出现诸如悬垂指针、数组越界、段错误等问题，在微软、百度、字节跳动等公司均有所使用。</p>\n<p>关于 Rust 的特性以及未来，知乎<a href=\"https://www.zhihu.com/question/30407715\">这个问题中的一些高赞回答以及相关的评论</a>，非常值得一看。</p>\n<p>本文会以二叉树这样一个具体的例子出发，来对 Rust 的一部分知识内容进行学习。</p>\n<h3 id=\"实现二叉树数据结构\"><a href=\"#实现二叉树数据结构\" class=\"headerlink\" title=\"实现二叉树数据结构\"></a>实现二叉树数据结构</h3><h4 id=\"定义结构\"><a href=\"#定义结构\" class=\"headerlink\" title=\"定义结构\"></a>定义结构</h4><p>之前在 Javascript 等语言中，我们只要对对象有所了解，实现一个二叉树的数据结构是非常简单的事情，而在 Rust 中，可能对于新手来说仅仅是实现基本的数据结构就是一个比较脑壳疼的事情。</p>\n<p>我们一般会写出类似这样的代码：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct <span class=\"class\">Tree </span>&#123;</span><br><span class=\"line\"><span class=\"symbol\">    value:</span> i32,</span><br><span class=\"line\"><span class=\"symbol\">    left:</span> Tree, <span class=\"comment\">// 直接使用 Tree 是不行的</span></span><br><span class=\"line\"><span class=\"symbol\">    right:</span> Tree  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自然不会通过 Rust 的编译检查，会报错例如：<code>recursive type has infinite size</code>，不过其同时给我们提供了解决方案，这里我们使用 <code>Box&lt;T&gt;</code> 指针。</p>\n<p>另外，考虑到二叉树的左右子树可能为空，所以这里我们还需要增加一个 <code>Option</code>。</p>\n<p>最终我们的二叉树数据结构定义如下：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Debug, Default)]</span></span><br><span class=\"line\">struct <span class=\"class\">Tree </span>&#123;</span><br><span class=\"line\"><span class=\"symbol\">    value:</span> i32,</span><br><span class=\"line\"><span class=\"symbol\">    left:</span> Option<span class=\"params\">&lt;Box&lt;Tree&gt;</span>&gt;,</span><br><span class=\"line\"><span class=\"symbol\">    right:</span> Option<span class=\"params\">&lt;Box&lt;Tree&gt;</span>&gt;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实现基本的方法\"><a href=\"#实现基本的方法\" class=\"headerlink\" title=\"实现基本的方法\"></a>实现基本的方法</h4><p>这里我们实现一些二叉树的基本的方法，作为上述结构体的方法，我们将实现以下方法：</p>\n<ul>\n<li>获取二叉树节点的值（其实也可以没有这个方法）。</li>\n<li>修改二叉树节点的值。</li>\n<li>设置子树。</li>\n<li>删除子树。</li>\n</ul>\n<p>这里除了第一个，其余我们都需要传递 <code>self</code> 的可变引用，我们的实现如下：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Tree &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_val</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">set_val</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, val: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">insert</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, dir: &amp;<span class=\"built_in\">String</span>, val: Tree) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert!</span>(dir == <span class=\"string\">&quot;left&quot;</span> || dir == <span class=\"string\">&quot;right&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">match</span> dir.as_ref() &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;left&quot;</span> =&gt; <span class=\"keyword\">self</span>.left = <span class=\"literal\">Some</span>(<span class=\"built_in\">Box</span>::new(val)),</span><br><span class=\"line\">            <span class=\"string\">&quot;right&quot;</span> =&gt; <span class=\"keyword\">self</span>.right = <span class=\"literal\">Some</span>(<span class=\"built_in\">Box</span>::new(val)),</span><br><span class=\"line\">            _ =&gt; &#123; </span><br><span class=\"line\">                <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class=\"line\">                process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">delete</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, dir: &amp;<span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert!</span>(dir == <span class=\"string\">&quot;left&quot;</span> || dir == <span class=\"string\">&quot;right&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">match</span> dir.as_ref() &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;left&quot;</span> =&gt; <span class=\"keyword\">self</span>.left = <span class=\"literal\">None</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;right&quot;</span> =&gt; <span class=\"keyword\">self</span>.right = <span class=\"literal\">None</span>,</span><br><span class=\"line\">                 _ =&gt; &#123; </span><br><span class=\"line\">                    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class=\"line\">                    process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遍历二叉树\"><a href=\"#遍历二叉树\" class=\"headerlink\" title=\"遍历二叉树\"></a>遍历二叉树</h3><p>这里遍历二叉树我们作为一个单独的方法，而不是属性方法来实现，这样会更符合我们平时的业务场景，这里其实问题比较多的，我们先简易实现一个版本：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">fn</span> <span class=\"selector-tag\">traverse</span>(<span class=\"attribute\">tree</span>: Tree) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">println</span>!(<span class=\"string\">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> <span class=\"selector-tag\">tree</span><span class=\"selector-class\">.left</span><span class=\"selector-class\">.is_some</span>() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">traverse</span>(*tree.left.unwrap()); <span class=\"comment\">// 手动解引用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> <span class=\"selector-tag\">tree</span><span class=\"selector-class\">.right</span><span class=\"selector-class\">.is_some</span>() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">traverse</span>(*tree.right.unwrap()); <span class=\"comment\">// 手动解引用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们测试一下这个版本，发现的确能够正常遍历的，但是实际上这有一个致命的问题：</p>\n<p>这里采用的是所有权的移动，而不是不可变借用，这会导致我们的函数执行完后原来变量的所有权已经被移动了，换一种说法则是会消耗掉这个变量，这显然不是我们预期的。</p>\n<p>虽然我们也可以在函数中返回 tree 的方式来最后再次移动所有权，但这样非常不便于实现，经过重构，我们采用了如下的方式实现：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn traverse(tree: &amp;Tree) &#123;</span><br><span class=\"line\">    println!(<span class=\"string\">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class=\"line\">    <span class=\"keyword\">match</span> tree.left &#123;</span><br><span class=\"line\">        <span class=\"constructor\">Some(<span class=\"params\">ref</span> <span class=\"params\">x</span>)</span> =&gt; traverse(x),</span><br><span class=\"line\">       <span class=\"function\"> <span class=\"params\">_</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">match</span> tree.right &#123;</span><br><span class=\"line\">        <span class=\"constructor\">Some(<span class=\"params\">ref</span> <span class=\"params\">x</span>)</span> =&gt; traverse(x),</span><br><span class=\"line\">       <span class=\"function\"> <span class=\"params\">_</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另外一个注意点则是由于 <code>unwrap()</code> 本身是一个消耗性操作，我们这里不能使用 <code>unwrap</code>，参考<a href=\"https://stackoverflow.com/questions/22282117/how-do-i-borrow-a-reference-to-what-is-inside-an-optiont\">stackOverflow的提问1</a>、<a href=\"https://stackoverflow.com/questions/32338659/cannot-move-out-of-borrowed-content-when-unwrapping\">stackOverflow的提问2</a>。</p>\n</blockquote>\n<p>我们最终的完整代码如下：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use::std::process;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::borrow::Borrow;</span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug, Default)]</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Tree</span></span> &#123;</span><br><span class=\"line\">    value: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">    left: <span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">Box</span>&lt;Tree&gt;&gt;,</span><br><span class=\"line\">    right: <span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">Box</span>&lt;Tree&gt;&gt;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Tree &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_val</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">set_val</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, val: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">insert</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, dir: &amp;<span class=\"built_in\">String</span>, val: Tree) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert!</span>(dir == <span class=\"string\">&quot;left&quot;</span> || dir == <span class=\"string\">&quot;right&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">match</span> dir.as_ref() &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;left&quot;</span> =&gt; <span class=\"keyword\">self</span>.left = <span class=\"literal\">Some</span>(<span class=\"built_in\">Box</span>::new(val)),</span><br><span class=\"line\">            <span class=\"string\">&quot;right&quot;</span> =&gt; <span class=\"keyword\">self</span>.right = <span class=\"literal\">Some</span>(<span class=\"built_in\">Box</span>::new(val)),</span><br><span class=\"line\">            _ =&gt; &#123; </span><br><span class=\"line\">                <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class=\"line\">                process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">delete</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, dir: &amp;<span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert!</span>(dir == <span class=\"string\">&quot;left&quot;</span> || dir == <span class=\"string\">&quot;right&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">match</span> dir.as_ref() &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;left&quot;</span> =&gt; <span class=\"keyword\">self</span>.left = <span class=\"literal\">None</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;right&quot;</span> =&gt; <span class=\"keyword\">self</span>.right = <span class=\"literal\">None</span>,</span><br><span class=\"line\">                 _ =&gt; &#123; </span><br><span class=\"line\">                    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class=\"line\">                    process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原始的非消耗性遍历:</span></span><br><span class=\"line\"><span class=\"comment\">// fn traverse(tree: &amp;Tree) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     println!(&quot;Node Value: &#123;:?&#125;&quot;, tree.value);</span></span><br><span class=\"line\"><span class=\"comment\">//     if tree.left.is_some() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         // cannot move out of borrowed content</span></span><br><span class=\"line\"><span class=\"comment\">//         // 首先 unwrap 是一个消耗性操作</span></span><br><span class=\"line\"><span class=\"comment\">//         // 这是由于 unwrap 函数造成?  as_ref 也不行</span></span><br><span class=\"line\"><span class=\"comment\">//         traverse((tree.left.as_ref().map(|x| **x).unwrap()).borrow());</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     // if tree.right.is_some() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     //     // cannot move out of borrowed content</span></span><br><span class=\"line\"><span class=\"comment\">//     //     traverse(tree.right.unwrap().borrow());</span></span><br><span class=\"line\"><span class=\"comment\">//     // &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非消耗性遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">traverse</span></span>(tree: &amp;Tree) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class=\"line\">    <span class=\"keyword\">match</span> tree.left &#123;</span><br><span class=\"line\">        <span class=\"literal\">Some</span>(<span class=\"keyword\">ref</span> x) =&gt; traverse(x),</span><br><span class=\"line\">        _ =&gt; &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">match</span> tree.right &#123;</span><br><span class=\"line\">        <span class=\"literal\">Some</span>(<span class=\"keyword\">ref</span> x) =&gt; traverse(x),</span><br><span class=\"line\">        _ =&gt; &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 消耗性遍历：</span></span><br><span class=\"line\"><span class=\"comment\">// fn traverse(tree: Tree) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     println!(&quot;Node Value: &#123;:?&#125;&quot;, tree.value);</span></span><br><span class=\"line\"><span class=\"comment\">//     if tree.left.is_some() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         traverse(*tree.left.unwrap()); // 手动解引用</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     if tree.right.is_some() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         traverse(*tree.right.unwrap()); // 手动解引用</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;begin rust tree test:&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> tree = Tree &#123; value : <span class=\"number\">12</span>, ..<span class=\"built_in\">Default</span>::default() &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> left = Tree &#123; value : <span class=\"number\">121</span>, ..<span class=\"built_in\">Default</span>::default() &#125;;</span><br><span class=\"line\">    tree.insert(&amp;<span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;left&quot;</span>), left);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> right = Tree &#123; value : <span class=\"number\">122</span>, ..<span class=\"built_in\">Default</span>::default() &#125;;</span><br><span class=\"line\">    tree.insert(&amp;<span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;right&quot;</span>), right);</span><br><span class=\"line\">    <span class=\"comment\">// tree.delete(&amp;String::from(&quot;right&quot;));</span></span><br><span class=\"line\">    <span class=\"comment\">// println!(&quot;Tree val: &#123;:?&#125;&quot;, left.get_val()); 不能这样写，所有权已经被移动</span></span><br><span class=\"line\">    traverse(&amp;tree);</span><br><span class=\"line\">    <span class=\"comment\">// traverse(tree);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"[PWA实践]serviceWorker生命周期、请求代理与通信","abbrlink":3297459013,"date":"2018-02-11T07:05:43.000Z","_content":"\n本文主要讲 serviceWorker 生命周期和挂载、卸载等问题，适合对 serviceWorker 的作用有所了解但是具体细节不是特别清楚的读者\n\n**以下所有分析基于 Chrome V63**\n\n### serviceWorker的挂载\n\n先来一段代码感受serviceWorker注册:\n\n```\nif ('serviceWorker' in navigator) {\n      window.addEventListener('load', function () {\n          navigator.serviceWorker.register('/sw.js', {scope: '/'})\n              .then(function (registration) {\n                  // 注册成功\n                  console.log('ServiceWorker registration successful with scope: ', registration.scope);\n              })\n              .catch(function (err) {\n                  // 注册失败:(\n                  console.log('ServiceWorker registration failed: ', err);\n              });\n      });\n}\n```\n通过上述代码，我们定义在`/sw.js`里的内容就会生效(对于当前页面之前没有 serviceWorker 的情况而言，我们注册的 serviceWorker 肯定会生效，如果当前页面已经有了我们之前注册的 serviceWorker，这个时候涉及到 serviceWorker的更新机制，下文详述)\n\n如果我们在`sw.js`没有变化的情况下刷新这个页面，每次还是会有注册成功的回调以及相应的log输出，但是这个时候浏览器发现我们的 serviceWorker 并没有发生变化，并不会重置一遍 serviceWorker\n\n### serviceWorker更新\n\n我们如果想更新一个 serviceWorker，根据我们的一般web开发策略，可能会想到以下几种策略：\n\n* 仅变更文件名(比如把`sw.js`变成`sw-v2.js`或者加一个hash)\n* 仅变更文件内容(仅仅更新`sw.js`的内容，文件名不变)\n* 同时变更：同时执行以上两条\n\n在这里，我可以很负责的告诉你，**变更serviceWorker文件名绝对不是一个好的实践**，浏览器判断 serviceWorker 是否相同基本和文件名没有关系，甚至有可能还会造成浏览器抛出404异常(因为找不到原来的文件名对应的文件了)。\n\n所以我们只需要变更内容即可，实际上，我们每次打开或者刷新该页面，浏览器都会重新请求一遍 serviceWorker 的定义文件，如果发现文件内容和之前的不同了，这个时候:\n\n(*下文中，我们使用“有关 tab”来表示受 serviceWorker 控制的页面*，刷新均指普通刷新(F5/CommandR)并不指Hard Reload)\n\n* 这个新的 serviceWorker 就会进入到一个 “waiting to activate” 的状态，并且只要我们不关闭这个网站的所有tab(更准确地说，是这个 serviceWorker 控制的所有页面)，新的 serviceWorker 始终不会进入替换原有的进入到 running 状态(就算我们只打开了一个有关 tab，直接刷新也不会让新的替换旧的)。\n\n* 如果我们多次更新了 serviceWorker 并且没有关闭当前的 tab 页面，那么新的 serviceWorker 就会挤掉原先处于第二顺位(waiting to activate)的serviceWorker，变成`waiting to activate`状态\n\n也就是说，我们只有关闭当前旧的 serviceWorker 控制的所有页面 的所有tab，之后浏览器才会把旧的 serviveWorker 移除掉，换成新的，再打开相应的页面就会使用新的了。\n\n当然，也有一个特殊情况：如果我们在新的 serviceWorker 使用了`self.skipWaiting();`，像这样：\n\n```\nself.addEventListener('install', function(event) {\n    self.skipWaiting();\n});\n```\n\n这个时候，要分为以下两种情况：\n\n* 如果当前我们只打开了一个有关 tab，这个时候，我们直接刷新，发现新的已经替换掉旧的了。\n* 如果我们当前打开了若干有关 tab，这个时候，无论我们刷新多少次，新的也不会替换掉旧的，只有我们一个一个关掉tab(或者跳转走)只剩下最后一个了，这个时候刷新，会让新的替换旧的(也就是上一种情况)\n\nChrome 的这种机制，防止了同一个页面先后被新旧两个不同的 serviceWorker 接管的情况出现。\n\n#### 手动更新\n\n虽然说，在页面每次进入的时候浏览器都会检查一遍 serviceWorker 是否更新，但如果我们想要手动更新 serviceWorker 也没有问题：\n\n```\nnavigator.serviceWorker.register(\"/sw.js\").then(reg => {\n  reg.update();\n  // 或者 一段时间之后更新\n});\n```\n\n这个时候如果 serviceWorker 变化了，那么会重新触发 install 执行一遍 install 的回调函数，如果没有变，就不会触发这个生命周期。\n\n#### install 生命周期钩子\n\n我们一般会在 sw.js 中，添加`install`的回调，一般在回调中，我们会进行缓存处理操作，像这样：\n\n```\nself.addEventListener('install', function(event) {\n    console.log('[sw2] serviceWorker Installed successfully', event)\n\n    event.waitUntil(\n        caches.open('mysite-static-v1').then(function(cache) {\n            return cache.addAll([\n                '/stylesheets/style.css',\n                '/javascripts/common.39c462651d449a73b5bb.js',\n            ]);\n        })\n    )\n}    \n```\n\n如果我们新打开一个页面，如果之前有 serviceWorker，那么会触发`install`，如果之前没有， 那么在 serviceWorker 装载后会触发 `install`。\n\n如果我们刷新页面，serviceWorker 和之前没有变化或者 serviceWorker 已经处在 `waiting to activate`，不会触发`install`，如果有变化，会触发`install`，但不会接管页面(上文中提到)。\n\n#### activate 生命周期钩子\n\nactivate 在什么时候被触发呢？\n\n如果当前页面没有 serviceworker ，那么会在 install 之后触发。\n\n如果当前页面有 serviceWorker，并且有 serviceWorker更新，新的 serviceWorker 只会触发 install ，不会触发 activate\n\n换句话说，当前变成 active 的 serviceWorker 才会被触发这个生命周期钩子\n\n\n### serviceWorker 代理请求\n\nserviceWorker 代理请求相对来说比较好理解，以下是一个很简单的例子：\n\n```\nself.addEventListener('install', function(event) {\n    console.log('[sw2] serviceWorker Installed successfully', event)\n\n    event.waitUntil(\n        caches.open('mysite-static-v1').then(function(cache) {\n            return cache.addAll([\n                '/stylesheets/style.css',\n                '/javascripts/common.39c462651d449a73b5bb.js',\n            ]);\n        })\n    );\n});\n\nself.addEventListener('fetch', function(event) {\n    console.log('Handling fetch event for', event.request.url);\n    // console.log('[sw2]fetch but do nothing')\n\n    event.respondWith(\n        // caches.match() will look for a cache entry in all of the caches available to the service worker.\n        // It's an alternative to first opening a specific named cache and then matching on that.\n        caches.match(event.request).then(function(response) {\n            if (response) {\n                console.log('Found response in cache:', response);\n\n                return response;\n            }\n\n            console.log('No response found in cache. About to fetch from network...');\n\n            // event.request will always have the proper mode set ('cors, 'no-cors', etc.) so we don't\n            // have to hardcode 'no-cors' like we do when fetch()ing in the install handler.\n            return fetch(event.request).then(function(response) {\n                console.log('Response from network is:', response);\n\n                return response;\n            }).catch(function(error) {\n                // This catch() will handle exceptions thrown from the fetch() operation.\n                // Note that a HTTP error response (e.g. 404) will NOT trigger an exception.\n                // It will return a normal response object that has the appropriate error code set.\n                console.error('Fetching failed:', error);\n\n                throw error;\n            });\n        })\n    );\n});\n```\n\n有两点要注意的：\n\n我们如果这样代理了，哪怕没有 cache 命中，实际上也会在控制台写from serviceWorker，而那些真正由serviceWorker发出的请求也会显示，有一个齿轮图标，如下图：\n\n![](https://www.10000h.top/images/sw_1.png)\n\n第二点就是我们如果在 fetch 的 listener 里面 do nothing， 也不会导致这个请求直接假死掉的。\n\n另外，通过上面的代码我们发现，实际上由于现在我们习惯给我们的文件资源加上 hash，所以我们基本上不可能手动输入需要缓存的文件列表，现在大多数情况下，我们都是借助 webpack 插件，完成这部分工作。\n\n### serviceWorker 和 页面之间的通信\n\nserviceWorker向页面发消息：\n\n```\nsw.js:\n\nself.clients.matchAll().then(clients => {\n    clients.forEach(client => {\n        console.log('%c [sw message]', 'color:#00aa00', client)\n        client.postMessage(\"This message is from serviceWorker\")\n    })\n})\n\n主页面:\n\nnavigator.serviceWorker.addEventListener('message', function (event) {\n    console.log('[Main] receive from serviceWorker:', event.data, event)\n});\n```\n\n当然，这里面是有坑的：\n\n* 主界面的事件监听需要等serviceWorker注册完毕后，所以一般`navigator.serviceWorker.register`的回调到来之后再进行注册(或者延迟足够的时间)。\n* 如果在主界面事件监听还没有注册成功的时候 serviceWorker 发送消息，自然是收不到的。如果我们把 serviceWorker 直接写在 install 的回调中，也是不能被正常收到的。\n\n从页面向 serviceWorker 发送消息：\n\n```\n主页面:\n\nnavigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage('hello serviceWorker');\n\nsw.js:\nself.addEventListener('message', function (event) {\n    console.log(\"[sw from main]\",event.data); // 输出：'sw.updatedone'\n});\n```\n\n同样的，这也要求主界面的代码需要等到serviceWorker注册完毕后触发，另外还有一点值得注意， serviceWorker 的事件绑定代码要求主界面的serviceWorker已经注册完毕后才可以。\n\n也就是说，如果当前页面没有该serviceWorker 第一次注册是不会收到主界面接收到的消息的。\n\n记住，只有当前已经在 active 的 serviceWorker， 才能和主页面收发消息等。\n\n**以上就是和 serviceWorker 有关的一些内容，在下一篇文章中，我会对PWA 添加至主屏幕等功能进行总结**\n\n","source":"_posts/PWA实践-serviceWorker生命周期、请求代理与通信.md","raw":"---\ntitle: '[PWA实践]serviceWorker生命周期、请求代理与通信'\ntags:\n  - PWA\nabbrlink: 3297459013\ndate: 2018-02-11 15:05:43\n---\n\n本文主要讲 serviceWorker 生命周期和挂载、卸载等问题，适合对 serviceWorker 的作用有所了解但是具体细节不是特别清楚的读者\n\n**以下所有分析基于 Chrome V63**\n\n### serviceWorker的挂载\n\n先来一段代码感受serviceWorker注册:\n\n```\nif ('serviceWorker' in navigator) {\n      window.addEventListener('load', function () {\n          navigator.serviceWorker.register('/sw.js', {scope: '/'})\n              .then(function (registration) {\n                  // 注册成功\n                  console.log('ServiceWorker registration successful with scope: ', registration.scope);\n              })\n              .catch(function (err) {\n                  // 注册失败:(\n                  console.log('ServiceWorker registration failed: ', err);\n              });\n      });\n}\n```\n通过上述代码，我们定义在`/sw.js`里的内容就会生效(对于当前页面之前没有 serviceWorker 的情况而言，我们注册的 serviceWorker 肯定会生效，如果当前页面已经有了我们之前注册的 serviceWorker，这个时候涉及到 serviceWorker的更新机制，下文详述)\n\n如果我们在`sw.js`没有变化的情况下刷新这个页面，每次还是会有注册成功的回调以及相应的log输出，但是这个时候浏览器发现我们的 serviceWorker 并没有发生变化，并不会重置一遍 serviceWorker\n\n### serviceWorker更新\n\n我们如果想更新一个 serviceWorker，根据我们的一般web开发策略，可能会想到以下几种策略：\n\n* 仅变更文件名(比如把`sw.js`变成`sw-v2.js`或者加一个hash)\n* 仅变更文件内容(仅仅更新`sw.js`的内容，文件名不变)\n* 同时变更：同时执行以上两条\n\n在这里，我可以很负责的告诉你，**变更serviceWorker文件名绝对不是一个好的实践**，浏览器判断 serviceWorker 是否相同基本和文件名没有关系，甚至有可能还会造成浏览器抛出404异常(因为找不到原来的文件名对应的文件了)。\n\n所以我们只需要变更内容即可，实际上，我们每次打开或者刷新该页面，浏览器都会重新请求一遍 serviceWorker 的定义文件，如果发现文件内容和之前的不同了，这个时候:\n\n(*下文中，我们使用“有关 tab”来表示受 serviceWorker 控制的页面*，刷新均指普通刷新(F5/CommandR)并不指Hard Reload)\n\n* 这个新的 serviceWorker 就会进入到一个 “waiting to activate” 的状态，并且只要我们不关闭这个网站的所有tab(更准确地说，是这个 serviceWorker 控制的所有页面)，新的 serviceWorker 始终不会进入替换原有的进入到 running 状态(就算我们只打开了一个有关 tab，直接刷新也不会让新的替换旧的)。\n\n* 如果我们多次更新了 serviceWorker 并且没有关闭当前的 tab 页面，那么新的 serviceWorker 就会挤掉原先处于第二顺位(waiting to activate)的serviceWorker，变成`waiting to activate`状态\n\n也就是说，我们只有关闭当前旧的 serviceWorker 控制的所有页面 的所有tab，之后浏览器才会把旧的 serviveWorker 移除掉，换成新的，再打开相应的页面就会使用新的了。\n\n当然，也有一个特殊情况：如果我们在新的 serviceWorker 使用了`self.skipWaiting();`，像这样：\n\n```\nself.addEventListener('install', function(event) {\n    self.skipWaiting();\n});\n```\n\n这个时候，要分为以下两种情况：\n\n* 如果当前我们只打开了一个有关 tab，这个时候，我们直接刷新，发现新的已经替换掉旧的了。\n* 如果我们当前打开了若干有关 tab，这个时候，无论我们刷新多少次，新的也不会替换掉旧的，只有我们一个一个关掉tab(或者跳转走)只剩下最后一个了，这个时候刷新，会让新的替换旧的(也就是上一种情况)\n\nChrome 的这种机制，防止了同一个页面先后被新旧两个不同的 serviceWorker 接管的情况出现。\n\n#### 手动更新\n\n虽然说，在页面每次进入的时候浏览器都会检查一遍 serviceWorker 是否更新，但如果我们想要手动更新 serviceWorker 也没有问题：\n\n```\nnavigator.serviceWorker.register(\"/sw.js\").then(reg => {\n  reg.update();\n  // 或者 一段时间之后更新\n});\n```\n\n这个时候如果 serviceWorker 变化了，那么会重新触发 install 执行一遍 install 的回调函数，如果没有变，就不会触发这个生命周期。\n\n#### install 生命周期钩子\n\n我们一般会在 sw.js 中，添加`install`的回调，一般在回调中，我们会进行缓存处理操作，像这样：\n\n```\nself.addEventListener('install', function(event) {\n    console.log('[sw2] serviceWorker Installed successfully', event)\n\n    event.waitUntil(\n        caches.open('mysite-static-v1').then(function(cache) {\n            return cache.addAll([\n                '/stylesheets/style.css',\n                '/javascripts/common.39c462651d449a73b5bb.js',\n            ]);\n        })\n    )\n}    \n```\n\n如果我们新打开一个页面，如果之前有 serviceWorker，那么会触发`install`，如果之前没有， 那么在 serviceWorker 装载后会触发 `install`。\n\n如果我们刷新页面，serviceWorker 和之前没有变化或者 serviceWorker 已经处在 `waiting to activate`，不会触发`install`，如果有变化，会触发`install`，但不会接管页面(上文中提到)。\n\n#### activate 生命周期钩子\n\nactivate 在什么时候被触发呢？\n\n如果当前页面没有 serviceworker ，那么会在 install 之后触发。\n\n如果当前页面有 serviceWorker，并且有 serviceWorker更新，新的 serviceWorker 只会触发 install ，不会触发 activate\n\n换句话说，当前变成 active 的 serviceWorker 才会被触发这个生命周期钩子\n\n\n### serviceWorker 代理请求\n\nserviceWorker 代理请求相对来说比较好理解，以下是一个很简单的例子：\n\n```\nself.addEventListener('install', function(event) {\n    console.log('[sw2] serviceWorker Installed successfully', event)\n\n    event.waitUntil(\n        caches.open('mysite-static-v1').then(function(cache) {\n            return cache.addAll([\n                '/stylesheets/style.css',\n                '/javascripts/common.39c462651d449a73b5bb.js',\n            ]);\n        })\n    );\n});\n\nself.addEventListener('fetch', function(event) {\n    console.log('Handling fetch event for', event.request.url);\n    // console.log('[sw2]fetch but do nothing')\n\n    event.respondWith(\n        // caches.match() will look for a cache entry in all of the caches available to the service worker.\n        // It's an alternative to first opening a specific named cache and then matching on that.\n        caches.match(event.request).then(function(response) {\n            if (response) {\n                console.log('Found response in cache:', response);\n\n                return response;\n            }\n\n            console.log('No response found in cache. About to fetch from network...');\n\n            // event.request will always have the proper mode set ('cors, 'no-cors', etc.) so we don't\n            // have to hardcode 'no-cors' like we do when fetch()ing in the install handler.\n            return fetch(event.request).then(function(response) {\n                console.log('Response from network is:', response);\n\n                return response;\n            }).catch(function(error) {\n                // This catch() will handle exceptions thrown from the fetch() operation.\n                // Note that a HTTP error response (e.g. 404) will NOT trigger an exception.\n                // It will return a normal response object that has the appropriate error code set.\n                console.error('Fetching failed:', error);\n\n                throw error;\n            });\n        })\n    );\n});\n```\n\n有两点要注意的：\n\n我们如果这样代理了，哪怕没有 cache 命中，实际上也会在控制台写from serviceWorker，而那些真正由serviceWorker发出的请求也会显示，有一个齿轮图标，如下图：\n\n![](https://www.10000h.top/images/sw_1.png)\n\n第二点就是我们如果在 fetch 的 listener 里面 do nothing， 也不会导致这个请求直接假死掉的。\n\n另外，通过上面的代码我们发现，实际上由于现在我们习惯给我们的文件资源加上 hash，所以我们基本上不可能手动输入需要缓存的文件列表，现在大多数情况下，我们都是借助 webpack 插件，完成这部分工作。\n\n### serviceWorker 和 页面之间的通信\n\nserviceWorker向页面发消息：\n\n```\nsw.js:\n\nself.clients.matchAll().then(clients => {\n    clients.forEach(client => {\n        console.log('%c [sw message]', 'color:#00aa00', client)\n        client.postMessage(\"This message is from serviceWorker\")\n    })\n})\n\n主页面:\n\nnavigator.serviceWorker.addEventListener('message', function (event) {\n    console.log('[Main] receive from serviceWorker:', event.data, event)\n});\n```\n\n当然，这里面是有坑的：\n\n* 主界面的事件监听需要等serviceWorker注册完毕后，所以一般`navigator.serviceWorker.register`的回调到来之后再进行注册(或者延迟足够的时间)。\n* 如果在主界面事件监听还没有注册成功的时候 serviceWorker 发送消息，自然是收不到的。如果我们把 serviceWorker 直接写在 install 的回调中，也是不能被正常收到的。\n\n从页面向 serviceWorker 发送消息：\n\n```\n主页面:\n\nnavigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage('hello serviceWorker');\n\nsw.js:\nself.addEventListener('message', function (event) {\n    console.log(\"[sw from main]\",event.data); // 输出：'sw.updatedone'\n});\n```\n\n同样的，这也要求主界面的代码需要等到serviceWorker注册完毕后触发，另外还有一点值得注意， serviceWorker 的事件绑定代码要求主界面的serviceWorker已经注册完毕后才可以。\n\n也就是说，如果当前页面没有该serviceWorker 第一次注册是不会收到主界面接收到的消息的。\n\n记住，只有当前已经在 active 的 serviceWorker， 才能和主页面收发消息等。\n\n**以上就是和 serviceWorker 有关的一些内容，在下一篇文章中，我会对PWA 添加至主屏幕等功能进行总结**\n\n","slug":"PWA实践-serviceWorker生命周期、请求代理与通信","published":1,"updated":"2021-12-23T05:50:07.539Z","_id":"ckxijpqsm000dd3mrdymvgz7c","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要讲 serviceWorker 生命周期和挂载、卸载等问题，适合对 serviceWorker 的作用有所了解但是具体细节不是特别清楚的读者</p>\n<p><strong>以下所有分析基于 Chrome V63</strong></p>\n<h3 id=\"serviceWorker的挂载\"><a href=\"#serviceWorker的挂载\" class=\"headerlink\" title=\"serviceWorker的挂载\"></a>serviceWorker的挂载</h3><p>先来一段代码感受serviceWorker注册:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">&#x27;serviceWorker&#x27;</span> <span class=\"keyword\">in</span> navigator) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          navigator.serviceWorker.register(<span class=\"string\">&#x27;/sw.js&#x27;</span>, &#123;<span class=\"attr\">scope</span>: <span class=\"string\">&#x27;/&#x27;</span>&#125;)</span><br><span class=\"line\">              .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">registration</span>) </span>&#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 注册成功</span></span><br><span class=\"line\">                  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ServiceWorker registration successful with scope: &#x27;</span>, registration.scope);</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">              .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 注册失败:(</span></span><br><span class=\"line\">                  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ServiceWorker registration failed: &#x27;</span>, err);</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述代码，我们定义在<code>/sw.js</code>里的内容就会生效(对于当前页面之前没有 serviceWorker 的情况而言，我们注册的 serviceWorker 肯定会生效，如果当前页面已经有了我们之前注册的 serviceWorker，这个时候涉及到 serviceWorker的更新机制，下文详述)</p>\n<p>如果我们在<code>sw.js</code>没有变化的情况下刷新这个页面，每次还是会有注册成功的回调以及相应的log输出，但是这个时候浏览器发现我们的 serviceWorker 并没有发生变化，并不会重置一遍 serviceWorker</p>\n<h3 id=\"serviceWorker更新\"><a href=\"#serviceWorker更新\" class=\"headerlink\" title=\"serviceWorker更新\"></a>serviceWorker更新</h3><p>我们如果想更新一个 serviceWorker，根据我们的一般web开发策略，可能会想到以下几种策略：</p>\n<ul>\n<li>仅变更文件名(比如把<code>sw.js</code>变成<code>sw-v2.js</code>或者加一个hash)</li>\n<li>仅变更文件内容(仅仅更新<code>sw.js</code>的内容，文件名不变)</li>\n<li>同时变更：同时执行以上两条</li>\n</ul>\n<p>在这里，我可以很负责的告诉你，<strong>变更serviceWorker文件名绝对不是一个好的实践</strong>，浏览器判断 serviceWorker 是否相同基本和文件名没有关系，甚至有可能还会造成浏览器抛出404异常(因为找不到原来的文件名对应的文件了)。</p>\n<p>所以我们只需要变更内容即可，实际上，我们每次打开或者刷新该页面，浏览器都会重新请求一遍 serviceWorker 的定义文件，如果发现文件内容和之前的不同了，这个时候:</p>\n<p>(<em>下文中，我们使用“有关 tab”来表示受 serviceWorker 控制的页面</em>，刷新均指普通刷新(F5/CommandR)并不指Hard Reload)</p>\n<ul>\n<li><p>这个新的 serviceWorker 就会进入到一个 “waiting to activate” 的状态，并且只要我们不关闭这个网站的所有tab(更准确地说，是这个 serviceWorker 控制的所有页面)，新的 serviceWorker 始终不会进入替换原有的进入到 running 状态(就算我们只打开了一个有关 tab，直接刷新也不会让新的替换旧的)。</p>\n</li>\n<li><p>如果我们多次更新了 serviceWorker 并且没有关闭当前的 tab 页面，那么新的 serviceWorker 就会挤掉原先处于第二顺位(waiting to activate)的serviceWorker，变成<code>waiting to activate</code>状态</p>\n</li>\n</ul>\n<p>也就是说，我们只有关闭当前旧的 serviceWorker 控制的所有页面 的所有tab，之后浏览器才会把旧的 serviveWorker 移除掉，换成新的，再打开相应的页面就会使用新的了。</p>\n<p>当然，也有一个特殊情况：如果我们在新的 serviceWorker 使用了<code>self.skipWaiting();</code>，像这样：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">self</span>.addEventListener(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(event)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">self</span>.skipWaiting();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，要分为以下两种情况：</p>\n<ul>\n<li>如果当前我们只打开了一个有关 tab，这个时候，我们直接刷新，发现新的已经替换掉旧的了。</li>\n<li>如果我们当前打开了若干有关 tab，这个时候，无论我们刷新多少次，新的也不会替换掉旧的，只有我们一个一个关掉tab(或者跳转走)只剩下最后一个了，这个时候刷新，会让新的替换旧的(也就是上一种情况)</li>\n</ul>\n<p>Chrome 的这种机制，防止了同一个页面先后被新旧两个不同的 serviceWorker 接管的情况出现。</p>\n<h4 id=\"手动更新\"><a href=\"#手动更新\" class=\"headerlink\" title=\"手动更新\"></a>手动更新</h4><p>虽然说，在页面每次进入的时候浏览器都会检查一遍 serviceWorker 是否更新，但如果我们想要手动更新 serviceWorker 也没有问题：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">navigator.serviceWorker.register(<span class=\"string\">&quot;/sw.js&quot;</span>).then(<span class=\"keyword\">reg</span> =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">reg</span>.<span class=\"keyword\">update</span>();</span><br><span class=\"line\">  <span class=\"comment\">// 或者 一段时间之后更新</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候如果 serviceWorker 变化了，那么会重新触发 install 执行一遍 install 的回调函数，如果没有变，就不会触发这个生命周期。</p>\n<h4 id=\"install-生命周期钩子\"><a href=\"#install-生命周期钩子\" class=\"headerlink\" title=\"install 生命周期钩子\"></a>install 生命周期钩子</h4><p>我们一般会在 sw.js 中，添加<code>install</code>的回调，一般在回调中，我们会进行缓存处理操作，像这样：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">self</span>.addEventListener(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(event)</span></span> &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;[sw2] serviceWorker Installed successfully&#x27;</span>, event)</span><br><span class=\"line\"></span><br><span class=\"line\">    event.waitUntil(</span><br><span class=\"line\">        caches.<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;mysite-static-v1&#x27;</span>).<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(cache)</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache.addAll([</span><br><span class=\"line\">                <span class=\"string\">&#x27;/stylesheets/style.css&#x27;</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;/javascripts/common.39c462651d449a73b5bb.js&#x27;</span>,</span><br><span class=\"line\">            ]);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n\n<p>如果我们新打开一个页面，如果之前有 serviceWorker，那么会触发<code>install</code>，如果之前没有， 那么在 serviceWorker 装载后会触发 <code>install</code>。</p>\n<p>如果我们刷新页面，serviceWorker 和之前没有变化或者 serviceWorker 已经处在 <code>waiting to activate</code>，不会触发<code>install</code>，如果有变化，会触发<code>install</code>，但不会接管页面(上文中提到)。</p>\n<h4 id=\"activate-生命周期钩子\"><a href=\"#activate-生命周期钩子\" class=\"headerlink\" title=\"activate 生命周期钩子\"></a>activate 生命周期钩子</h4><p>activate 在什么时候被触发呢？</p>\n<p>如果当前页面没有 serviceworker ，那么会在 install 之后触发。</p>\n<p>如果当前页面有 serviceWorker，并且有 serviceWorker更新，新的 serviceWorker 只会触发 install ，不会触发 activate</p>\n<p>换句话说，当前变成 active 的 serviceWorker 才会被触发这个生命周期钩子</p>\n<h3 id=\"serviceWorker-代理请求\"><a href=\"#serviceWorker-代理请求\" class=\"headerlink\" title=\"serviceWorker 代理请求\"></a>serviceWorker 代理请求</h3><p>serviceWorker 代理请求相对来说比较好理解，以下是一个很简单的例子：</p>\n<figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(event)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;[sw2] serviceWorker Installed successfully&#x27;</span>, event)</span><br><span class=\"line\"></span><br><span class=\"line\">    event.waitUntil(</span><br><span class=\"line\">        caches.open(<span class=\"string\">&#x27;mysite-static-v1&#x27;</span>).<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(cache)</span> &#123;</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache.addAll([</span><br><span class=\"line\">                <span class=\"string\">&#x27;/stylesheets/style.css&#x27;</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;/javascripts/common.39c462651d449a73b5bb.js&#x27;</span>,</span><br><span class=\"line\">            ]);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">&#x27;fetch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(event)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;Handling fetch event for&#x27;</span>, event.request.url);</span><br><span class=\"line\">    <span class=\"comment\">// console.log(&#x27;[sw2]fetch but do nothing&#x27;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    event.respondWith(</span><br><span class=\"line\">        <span class=\"comment\">// caches.match() will look for a cache entry in all of the caches available to the service worker.</span></span><br><span class=\"line\">        <span class=\"comment\">// It&#x27;s an alternative to first opening a specific named cache and then matching on that.</span></span><br><span class=\"line\">        caches.match(event.request).<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (response) &#123;</span><br><span class=\"line\">                console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;Found response in cache:&#x27;</span>, response);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;No response found in cache. About to fetch from network...&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// event.request will always have the proper mode set (&#x27;cors, &#x27;no-cors&#x27;, etc.) so we don&#x27;t</span></span><br><span class=\"line\">            <span class=\"comment\">// have to hardcode &#x27;no-cors&#x27; like we do when fetch()ing in the install handler.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> fetch(event.request).<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">                console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;Response from network is:&#x27;</span>, response);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">            &#125;).<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">                <span class=\"comment\">// This catch() will handle exceptions thrown from the fetch() operation.</span></span><br><span class=\"line\">                <span class=\"comment\">// Note that a HTTP error response (e.g. 404) will NOT trigger an exception.</span></span><br><span class=\"line\">                <span class=\"comment\">// It will return a normal response object that has the appropriate error code set.</span></span><br><span class=\"line\">                console.<span class=\"built_in\">error</span>(<span class=\"string\">&#x27;Fetching failed:&#x27;</span>, <span class=\"built_in\">error</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                throw <span class=\"built_in\">error</span>;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>有两点要注意的：</p>\n<p>我们如果这样代理了，哪怕没有 cache 命中，实际上也会在控制台写from serviceWorker，而那些真正由serviceWorker发出的请求也会显示，有一个齿轮图标，如下图：</p>\n<p><img src=\"https://www.10000h.top/images/sw_1.png\"></p>\n<p>第二点就是我们如果在 fetch 的 listener 里面 do nothing， 也不会导致这个请求直接假死掉的。</p>\n<p>另外，通过上面的代码我们发现，实际上由于现在我们习惯给我们的文件资源加上 hash，所以我们基本上不可能手动输入需要缓存的文件列表，现在大多数情况下，我们都是借助 webpack 插件，完成这部分工作。</p>\n<h3 id=\"serviceWorker-和-页面之间的通信\"><a href=\"#serviceWorker-和-页面之间的通信\" class=\"headerlink\" title=\"serviceWorker 和 页面之间的通信\"></a>serviceWorker 和 页面之间的通信</h3><p>serviceWorker向页面发消息：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sw<span class=\"selector-class\">.js</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">self.clients.<span class=\"built_in\">matchAll</span>().<span class=\"built_in\">then</span>(clients =&gt; &#123;</span><br><span class=\"line\">    clients.<span class=\"built_in\">forEach</span>(client =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;%c [sw message]&#x27;</span>, <span class=\"string\">&#x27;color:#00aa00&#x27;</span>, client)</span><br><span class=\"line\">        client.<span class=\"built_in\">postMessage</span>(<span class=\"string\">&quot;This message is from serviceWorker&quot;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">主页面:</span><br><span class=\"line\"></span><br><span class=\"line\">navigator.serviceWorker.<span class=\"built_in\">addEventListener</span>(<span class=\"string\">&#x27;message&#x27;</span>, function (event) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;[Main] receive from serviceWorker:&#x27;</span>, event.data, event)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>当然，这里面是有坑的：</p>\n<ul>\n<li>主界面的事件监听需要等serviceWorker注册完毕后，所以一般<code>navigator.serviceWorker.register</code>的回调到来之后再进行注册(或者延迟足够的时间)。</li>\n<li>如果在主界面事件监听还没有注册成功的时候 serviceWorker 发送消息，自然是收不到的。如果我们把 serviceWorker 直接写在 install 的回调中，也是不能被正常收到的。</li>\n</ul>\n<p>从页面向 serviceWorker 发送消息：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主页面:</span><br><span class=\"line\"></span><br><span class=\"line\">navigator.serviceWorker.controller<span class=\"operator\"> &amp;&amp; </span>navigator.serviceWorker.controller.post<span class=\"constructor\">Message(&#x27;<span class=\"params\">hello</span> <span class=\"params\">serviceWorker</span>&#x27;)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">sw.js:</span><br><span class=\"line\">self.add<span class=\"constructor\">EventListener(&#x27;<span class=\"params\">message</span>&#x27;, <span class=\"params\">function</span> (<span class=\"params\">event</span>)</span> &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">&quot;[sw from main]&quot;</span>,event.data); <span class=\"comment\">// 输出：&#x27;sw.updatedone&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>同样的，这也要求主界面的代码需要等到serviceWorker注册完毕后触发，另外还有一点值得注意， serviceWorker 的事件绑定代码要求主界面的serviceWorker已经注册完毕后才可以。</p>\n<p>也就是说，如果当前页面没有该serviceWorker 第一次注册是不会收到主界面接收到的消息的。</p>\n<p>记住，只有当前已经在 active 的 serviceWorker， 才能和主页面收发消息等。</p>\n<p><strong>以上就是和 serviceWorker 有关的一些内容，在下一篇文章中，我会对PWA 添加至主屏幕等功能进行总结</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文主要讲 serviceWorker 生命周期和挂载、卸载等问题，适合对 serviceWorker 的作用有所了解但是具体细节不是特别清楚的读者</p>\n<p><strong>以下所有分析基于 Chrome V63</strong></p>\n<h3 id=\"serviceWorker的挂载\"><a href=\"#serviceWorker的挂载\" class=\"headerlink\" title=\"serviceWorker的挂载\"></a>serviceWorker的挂载</h3><p>先来一段代码感受serviceWorker注册:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">&#x27;serviceWorker&#x27;</span> <span class=\"keyword\">in</span> navigator) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          navigator.serviceWorker.register(<span class=\"string\">&#x27;/sw.js&#x27;</span>, &#123;<span class=\"attr\">scope</span>: <span class=\"string\">&#x27;/&#x27;</span>&#125;)</span><br><span class=\"line\">              .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">registration</span>) </span>&#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 注册成功</span></span><br><span class=\"line\">                  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ServiceWorker registration successful with scope: &#x27;</span>, registration.scope);</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">              .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 注册失败:(</span></span><br><span class=\"line\">                  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ServiceWorker registration failed: &#x27;</span>, err);</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述代码，我们定义在<code>/sw.js</code>里的内容就会生效(对于当前页面之前没有 serviceWorker 的情况而言，我们注册的 serviceWorker 肯定会生效，如果当前页面已经有了我们之前注册的 serviceWorker，这个时候涉及到 serviceWorker的更新机制，下文详述)</p>\n<p>如果我们在<code>sw.js</code>没有变化的情况下刷新这个页面，每次还是会有注册成功的回调以及相应的log输出，但是这个时候浏览器发现我们的 serviceWorker 并没有发生变化，并不会重置一遍 serviceWorker</p>\n<h3 id=\"serviceWorker更新\"><a href=\"#serviceWorker更新\" class=\"headerlink\" title=\"serviceWorker更新\"></a>serviceWorker更新</h3><p>我们如果想更新一个 serviceWorker，根据我们的一般web开发策略，可能会想到以下几种策略：</p>\n<ul>\n<li>仅变更文件名(比如把<code>sw.js</code>变成<code>sw-v2.js</code>或者加一个hash)</li>\n<li>仅变更文件内容(仅仅更新<code>sw.js</code>的内容，文件名不变)</li>\n<li>同时变更：同时执行以上两条</li>\n</ul>\n<p>在这里，我可以很负责的告诉你，<strong>变更serviceWorker文件名绝对不是一个好的实践</strong>，浏览器判断 serviceWorker 是否相同基本和文件名没有关系，甚至有可能还会造成浏览器抛出404异常(因为找不到原来的文件名对应的文件了)。</p>\n<p>所以我们只需要变更内容即可，实际上，我们每次打开或者刷新该页面，浏览器都会重新请求一遍 serviceWorker 的定义文件，如果发现文件内容和之前的不同了，这个时候:</p>\n<p>(<em>下文中，我们使用“有关 tab”来表示受 serviceWorker 控制的页面</em>，刷新均指普通刷新(F5/CommandR)并不指Hard Reload)</p>\n<ul>\n<li><p>这个新的 serviceWorker 就会进入到一个 “waiting to activate” 的状态，并且只要我们不关闭这个网站的所有tab(更准确地说，是这个 serviceWorker 控制的所有页面)，新的 serviceWorker 始终不会进入替换原有的进入到 running 状态(就算我们只打开了一个有关 tab，直接刷新也不会让新的替换旧的)。</p>\n</li>\n<li><p>如果我们多次更新了 serviceWorker 并且没有关闭当前的 tab 页面，那么新的 serviceWorker 就会挤掉原先处于第二顺位(waiting to activate)的serviceWorker，变成<code>waiting to activate</code>状态</p>\n</li>\n</ul>\n<p>也就是说，我们只有关闭当前旧的 serviceWorker 控制的所有页面 的所有tab，之后浏览器才会把旧的 serviveWorker 移除掉，换成新的，再打开相应的页面就会使用新的了。</p>\n<p>当然，也有一个特殊情况：如果我们在新的 serviceWorker 使用了<code>self.skipWaiting();</code>，像这样：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">self</span>.addEventListener(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(event)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">self</span>.skipWaiting();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，要分为以下两种情况：</p>\n<ul>\n<li>如果当前我们只打开了一个有关 tab，这个时候，我们直接刷新，发现新的已经替换掉旧的了。</li>\n<li>如果我们当前打开了若干有关 tab，这个时候，无论我们刷新多少次，新的也不会替换掉旧的，只有我们一个一个关掉tab(或者跳转走)只剩下最后一个了，这个时候刷新，会让新的替换旧的(也就是上一种情况)</li>\n</ul>\n<p>Chrome 的这种机制，防止了同一个页面先后被新旧两个不同的 serviceWorker 接管的情况出现。</p>\n<h4 id=\"手动更新\"><a href=\"#手动更新\" class=\"headerlink\" title=\"手动更新\"></a>手动更新</h4><p>虽然说，在页面每次进入的时候浏览器都会检查一遍 serviceWorker 是否更新，但如果我们想要手动更新 serviceWorker 也没有问题：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">navigator.serviceWorker.register(<span class=\"string\">&quot;/sw.js&quot;</span>).then(<span class=\"keyword\">reg</span> =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">reg</span>.<span class=\"keyword\">update</span>();</span><br><span class=\"line\">  <span class=\"comment\">// 或者 一段时间之后更新</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候如果 serviceWorker 变化了，那么会重新触发 install 执行一遍 install 的回调函数，如果没有变，就不会触发这个生命周期。</p>\n<h4 id=\"install-生命周期钩子\"><a href=\"#install-生命周期钩子\" class=\"headerlink\" title=\"install 生命周期钩子\"></a>install 生命周期钩子</h4><p>我们一般会在 sw.js 中，添加<code>install</code>的回调，一般在回调中，我们会进行缓存处理操作，像这样：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">self</span>.addEventListener(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(event)</span></span> &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;[sw2] serviceWorker Installed successfully&#x27;</span>, event)</span><br><span class=\"line\"></span><br><span class=\"line\">    event.waitUntil(</span><br><span class=\"line\">        caches.<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;mysite-static-v1&#x27;</span>).<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(cache)</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache.addAll([</span><br><span class=\"line\">                <span class=\"string\">&#x27;/stylesheets/style.css&#x27;</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;/javascripts/common.39c462651d449a73b5bb.js&#x27;</span>,</span><br><span class=\"line\">            ]);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n\n<p>如果我们新打开一个页面，如果之前有 serviceWorker，那么会触发<code>install</code>，如果之前没有， 那么在 serviceWorker 装载后会触发 <code>install</code>。</p>\n<p>如果我们刷新页面，serviceWorker 和之前没有变化或者 serviceWorker 已经处在 <code>waiting to activate</code>，不会触发<code>install</code>，如果有变化，会触发<code>install</code>，但不会接管页面(上文中提到)。</p>\n<h4 id=\"activate-生命周期钩子\"><a href=\"#activate-生命周期钩子\" class=\"headerlink\" title=\"activate 生命周期钩子\"></a>activate 生命周期钩子</h4><p>activate 在什么时候被触发呢？</p>\n<p>如果当前页面没有 serviceworker ，那么会在 install 之后触发。</p>\n<p>如果当前页面有 serviceWorker，并且有 serviceWorker更新，新的 serviceWorker 只会触发 install ，不会触发 activate</p>\n<p>换句话说，当前变成 active 的 serviceWorker 才会被触发这个生命周期钩子</p>\n<h3 id=\"serviceWorker-代理请求\"><a href=\"#serviceWorker-代理请求\" class=\"headerlink\" title=\"serviceWorker 代理请求\"></a>serviceWorker 代理请求</h3><p>serviceWorker 代理请求相对来说比较好理解，以下是一个很简单的例子：</p>\n<figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(event)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;[sw2] serviceWorker Installed successfully&#x27;</span>, event)</span><br><span class=\"line\"></span><br><span class=\"line\">    event.waitUntil(</span><br><span class=\"line\">        caches.open(<span class=\"string\">&#x27;mysite-static-v1&#x27;</span>).<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(cache)</span> &#123;</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache.addAll([</span><br><span class=\"line\">                <span class=\"string\">&#x27;/stylesheets/style.css&#x27;</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;/javascripts/common.39c462651d449a73b5bb.js&#x27;</span>,</span><br><span class=\"line\">            ]);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">&#x27;fetch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(event)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;Handling fetch event for&#x27;</span>, event.request.url);</span><br><span class=\"line\">    <span class=\"comment\">// console.log(&#x27;[sw2]fetch but do nothing&#x27;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    event.respondWith(</span><br><span class=\"line\">        <span class=\"comment\">// caches.match() will look for a cache entry in all of the caches available to the service worker.</span></span><br><span class=\"line\">        <span class=\"comment\">// It&#x27;s an alternative to first opening a specific named cache and then matching on that.</span></span><br><span class=\"line\">        caches.match(event.request).<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (response) &#123;</span><br><span class=\"line\">                console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;Found response in cache:&#x27;</span>, response);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;No response found in cache. About to fetch from network...&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// event.request will always have the proper mode set (&#x27;cors, &#x27;no-cors&#x27;, etc.) so we don&#x27;t</span></span><br><span class=\"line\">            <span class=\"comment\">// have to hardcode &#x27;no-cors&#x27; like we do when fetch()ing in the install handler.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> fetch(event.request).<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">                console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;Response from network is:&#x27;</span>, response);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">            &#125;).<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">                <span class=\"comment\">// This catch() will handle exceptions thrown from the fetch() operation.</span></span><br><span class=\"line\">                <span class=\"comment\">// Note that a HTTP error response (e.g. 404) will NOT trigger an exception.</span></span><br><span class=\"line\">                <span class=\"comment\">// It will return a normal response object that has the appropriate error code set.</span></span><br><span class=\"line\">                console.<span class=\"built_in\">error</span>(<span class=\"string\">&#x27;Fetching failed:&#x27;</span>, <span class=\"built_in\">error</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                throw <span class=\"built_in\">error</span>;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>有两点要注意的：</p>\n<p>我们如果这样代理了，哪怕没有 cache 命中，实际上也会在控制台写from serviceWorker，而那些真正由serviceWorker发出的请求也会显示，有一个齿轮图标，如下图：</p>\n<p><img src=\"https://www.10000h.top/images/sw_1.png\"></p>\n<p>第二点就是我们如果在 fetch 的 listener 里面 do nothing， 也不会导致这个请求直接假死掉的。</p>\n<p>另外，通过上面的代码我们发现，实际上由于现在我们习惯给我们的文件资源加上 hash，所以我们基本上不可能手动输入需要缓存的文件列表，现在大多数情况下，我们都是借助 webpack 插件，完成这部分工作。</p>\n<h3 id=\"serviceWorker-和-页面之间的通信\"><a href=\"#serviceWorker-和-页面之间的通信\" class=\"headerlink\" title=\"serviceWorker 和 页面之间的通信\"></a>serviceWorker 和 页面之间的通信</h3><p>serviceWorker向页面发消息：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sw<span class=\"selector-class\">.js</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">self.clients.<span class=\"built_in\">matchAll</span>().<span class=\"built_in\">then</span>(clients =&gt; &#123;</span><br><span class=\"line\">    clients.<span class=\"built_in\">forEach</span>(client =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;%c [sw message]&#x27;</span>, <span class=\"string\">&#x27;color:#00aa00&#x27;</span>, client)</span><br><span class=\"line\">        client.<span class=\"built_in\">postMessage</span>(<span class=\"string\">&quot;This message is from serviceWorker&quot;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">主页面:</span><br><span class=\"line\"></span><br><span class=\"line\">navigator.serviceWorker.<span class=\"built_in\">addEventListener</span>(<span class=\"string\">&#x27;message&#x27;</span>, function (event) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">&#x27;[Main] receive from serviceWorker:&#x27;</span>, event.data, event)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>当然，这里面是有坑的：</p>\n<ul>\n<li>主界面的事件监听需要等serviceWorker注册完毕后，所以一般<code>navigator.serviceWorker.register</code>的回调到来之后再进行注册(或者延迟足够的时间)。</li>\n<li>如果在主界面事件监听还没有注册成功的时候 serviceWorker 发送消息，自然是收不到的。如果我们把 serviceWorker 直接写在 install 的回调中，也是不能被正常收到的。</li>\n</ul>\n<p>从页面向 serviceWorker 发送消息：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主页面:</span><br><span class=\"line\"></span><br><span class=\"line\">navigator.serviceWorker.controller<span class=\"operator\"> &amp;&amp; </span>navigator.serviceWorker.controller.post<span class=\"constructor\">Message(&#x27;<span class=\"params\">hello</span> <span class=\"params\">serviceWorker</span>&#x27;)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">sw.js:</span><br><span class=\"line\">self.add<span class=\"constructor\">EventListener(&#x27;<span class=\"params\">message</span>&#x27;, <span class=\"params\">function</span> (<span class=\"params\">event</span>)</span> &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">&quot;[sw from main]&quot;</span>,event.data); <span class=\"comment\">// 输出：&#x27;sw.updatedone&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>同样的，这也要求主界面的代码需要等到serviceWorker注册完毕后触发，另外还有一点值得注意， serviceWorker 的事件绑定代码要求主界面的serviceWorker已经注册完毕后才可以。</p>\n<p>也就是说，如果当前页面没有该serviceWorker 第一次注册是不会收到主界面接收到的消息的。</p>\n<p>记住，只有当前已经在 active 的 serviceWorker， 才能和主页面收发消息等。</p>\n<p><strong>以上就是和 serviceWorker 有关的一些内容，在下一篇文章中，我会对PWA 添加至主屏幕等功能进行总结</strong></p>\n"},{"layout":"阿里云服务器ecs","title":"centOS7.2搭建nginx环境以及负载均衡","date":"2016-08-03T13:16:24.000Z","_content":" 之所以要整理出这篇文章，是因为1是搭建环境的过程中会遇到大大小小各种问题，2是网上目前也没有关于centos7.2搭建nginx环境的问题整理，因此在这里记录。\n\n前置工作就不赘述了，首先`ssh root@115.29.102.81` (换成你们自己的公网IP)登陆进入到自己的服务器命令行，之后开始基本的安装：\n\n**1.添加资源**\n\n添加CentOS 7 Nginx yum资源库,打开终端,使用以下命令(没有换行):\n\n```\nsudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\n\n```\n\n**2.安装Nginx**\n\n在你的CentOS 7 服务器中使用yum命令从Nginx源服务器中获取来安装Nginx：\n>*这里有一个需要注意的地方，尽量不要用网上的下载源码包然后再传到服务器上的方式进行安装，因为nginx已经不算是简单的Linux了，做了很多扩展，这个时候如果你用源码包安装会出现各种各样的问题，尽量用已经封装好的rpm\\yum进行安装*\n```\nsudo yum install -y nginx\n```\nNginx将完成安装在你的CentOS 7 服务器中。\n\n**3.启动Nginx**\n\n刚安装的Nginx不会自行启动。运行Nginx:\n```\nsudo systemctl start nginx.service\n```\n如果一切进展顺利的话，现在你可以通过你的域名或IP来访问你的Web页面来预览一下Nginx的默认页面\n\n>当然，这里一般很可能会无法访问的。\n\n我们先不急于解决我们的问题，先看看nginx的基本配置：\n\n\nNginx配置信息\n```\n网站文件存放默认目录\n\n/usr/share/nginx/html\n网站默认站点配置\n\n/etc/nginx/conf.d/default.conf\n自定义Nginx站点配置文件存放目录,自己在这里也可以定义别的名字的.conf，这个的作用以后再说。\n\n/etc/nginx/conf.d/\nNginx全局配置\n\n/etc/nginx/nginx.conf\n在这里你可以改变设置用户运行Nginx守护程序进程一样,和工作进程的数量得到了Nginx正在运行,等等。\n```\nLinux查看公网IP\n\n您可以运行以下命令来显示你的服务器的公共IP地址:(这个其实没用，不是公网IP)\n```\nip addr show eth0 | grep inet | awk '{ print $2; }' | sed 's/\\/.*$//'\n```\n___\n好了，这个时候我们再来看看可能遇到的问题：无法在公网访问。\n\n这个时候首先看看配置文件default.conf对不对，一个正确的例子：\n(域名要先进行解析到响应的IP)\n```\nserver {\n    listen       80;\n    server_name  nginx.310058.cn;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/log/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n```\n\n确定文件没问题了，看看这个时候是不是开启了nginx进程：\n\n```\n ps -ef | grep nginx\n```\n\n应该会输出一个或者多个进程，如果没有的话就开启或者重启试试看。\n\n这个时候接下来再试试在服务器上：\n```\nping  115.29.102.81\ntelnet 115.29.102.81 80\nwget nginx.310058.cn\n```\n如果有的命令没有就直接yum安装下:\n```\nyum -y install telnet\n```\n如果都可以的话，之后在本机尝试以上三行。如果没有命令也要安装下：\n```\nbrew install wget\n```\n\n发现很可能本机telnet不通，而服务器telnet通。\n这个时候就是**防火墙**的问题。\n\n####centos7.2防火墙\n\n由于centos 7版本以后默认使用firewalld后，网上关于iptables的设置方法已经不管用了，所以根本就别想用配置iptables做啥，根本没用。\n\n查看下防火墙状态：\n```\n[root@iZ28dcsp7egZ conf.d]# systemctl status firewalld  \n● firewalld.service - firewalld - dynamic firewall daemon\n   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)\n   Active: active (running) since Wed 2016-08-03 12:06:44 CST; 2h 49min ago\n Main PID: 424 (firewalld)\n   CGroup: /system.slice/firewalld.service\n           └─424 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid\n\nAug 03 12:06:41 iZ28dcsp7egZ systemd[1]: Starting firewalld - dynamic firewall daemon...\nAug 03 12:06:44 iZ28dcsp7egZ systemd[1]: Started firewalld - dynamic firewall daemon.\n```\n\n增加80端口的权限：\n```\nfirewall-cmd --zone=public --add-port=80/tcp --permanent  \n```\n \n 别忘了更新防火墙的配置：\n```\nfirewall-cmd --reload\n```\n这个时候再`restart  nginx.service` 一下就会发现应该好了。\n\n\nnginx 停止：\n\n```\nservice nginx restart\n也可以重启nginx\n\nkill -QUIT 进程号  \n#从容停止\n\nkill -TERM 进程号\n#或者\nkill -INT 进程号\n#快速停止\n\np-kill -9 nginx\n强制停止\n\nnginx -t \n#验证配置文件 前提是进入相应的配置的目录（自己实际测试的时候发现没有进入相应的配置目录也是可以的）\n\nnginx -s reload\n#重启\n\nkill -HUP 进程号\n#重启的另外一种方式\n```\n\n官方文档地址：\nhttps://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html#sec-Introduction_to_firewalld\n\n附1:一个简单的负载均衡的实现:\nweight默认是1，自己也可以更改。\n```\nupstream mypro {\n\t\t\t\tip_hash;\n                server 111.13.100.92 weight=2;\n                server 183.232.41.1;\n                server 42.156.140.7;\n                }\n\n        server {\n                listen 8090;\n                location / {\n                proxy_pass http://mypro;\n                }\n        }\n\n```\n\n\n附2:防火墙基本学习：\n\n``` \n\n1、firewalld简介\nfirewalld是centos7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念\n \nfirewalld有图形界面和工具界面，由于我在服务器上使用，图形界面请参照官方文档，本文以字符界面做介绍\n \nfirewalld的字符界面管理工具是 firewall-cmd \n \nfirewalld默认配置文件有两个：/usr/lib/firewalld/ （系统配置，尽量不要修改）和 /etc/firewalld/ （用户配置地址）\n \nzone概念：\n硬件防火墙默认一般有三个区，firewalld引入这一概念系统默认存在以下区域（根据文档自己理解，如果有误请指正）：\ndrop：默认丢弃所有包\nblock：拒绝所有外部连接，允许内部发起的连接\npublic：指定外部连接可以进入\nexternal：这个不太明白，功能上和上面相同，允许指定的外部连接\ndmz：和硬件防火墙一样，受限制的公共连接可以进入\nwork：工作区，概念和workgoup一样，也是指定的外部连接允许\nhome：类似家庭组\ninternal：信任所有连接\n对防火墙不算太熟悉，还没想明白public、external、dmz、work、home从功能上都需要自定义允许连接，具体使用上的区别还需高人指点\n \n2、安装firewalld\nroot执行 # yum install firewalld firewall-config\n \n3、运行、停止、禁用firewalld\n启动：# systemctl start  firewalld\n查看状态：# systemctl status firewalld 或者 firewall-cmd --state\n停止：# systemctl disable firewalld\n禁用：# systemctl stop firewalld\n \n4、配置firewalld\n查看版本：$ firewall-cmd --version\n查看帮助：$ firewall-cmd --help\n查看设置：\n                显示状态：$ firewall-cmd --state\n                查看区域信息: $ firewall-cmd --get-active-zones\n                查看指定接口所属区域：$ firewall-cmd --get-zone-of-interface=eth0\n拒绝所有包：# firewall-cmd --panic-on\n取消拒绝状态：# firewall-cmd --panic-off\n查看是否拒绝：$ firewall-cmd --query-panic\n \n更新防火墙规则：# firewall-cmd --reload\n                            # firewall-cmd --complete-reload\n    两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务\n \n将接口添加到区域，默认接口都在public\n# firewall-cmd --zone=public --add-interface=eth0\n永久生效再加上 --permanent 然后reload防火墙\n \n设置默认接口区域\n# firewall-cmd --set-default-zone=public\n立即生效无需重启\n \n打开端口（貌似这个才最常用）\n查看所有打开的端口：\n# firewall-cmd --zone=dmz --list-ports\n加入一个端口到区域：\n# firewall-cmd --zone=dmz --add-port=8080/tcp\n若要永久生效方法同上\n \n打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档\n# firewall-cmd --zone=work --add-service=smtp\n \n移除服务\n# firewall-cmd --zone=work --remove-service=smtp\n \n还有端口转发功能、自定义复杂规则功能、lockdown，由于还没用到，以后再学习\n\n```\n","source":"_posts/centOS7-2搭建nginx环境以及负载均衡.md","raw":"---\nlayout: 阿里云服务器ecs\ntitle: centOS7.2搭建nginx环境以及负载均衡\ndate: 2016-08-03 21:16:24\ntags:\n    - centOS\n    - nginx\n---\n 之所以要整理出这篇文章，是因为1是搭建环境的过程中会遇到大大小小各种问题，2是网上目前也没有关于centos7.2搭建nginx环境的问题整理，因此在这里记录。\n\n前置工作就不赘述了，首先`ssh root@115.29.102.81` (换成你们自己的公网IP)登陆进入到自己的服务器命令行，之后开始基本的安装：\n\n**1.添加资源**\n\n添加CentOS 7 Nginx yum资源库,打开终端,使用以下命令(没有换行):\n\n```\nsudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\n\n```\n\n**2.安装Nginx**\n\n在你的CentOS 7 服务器中使用yum命令从Nginx源服务器中获取来安装Nginx：\n>*这里有一个需要注意的地方，尽量不要用网上的下载源码包然后再传到服务器上的方式进行安装，因为nginx已经不算是简单的Linux了，做了很多扩展，这个时候如果你用源码包安装会出现各种各样的问题，尽量用已经封装好的rpm\\yum进行安装*\n```\nsudo yum install -y nginx\n```\nNginx将完成安装在你的CentOS 7 服务器中。\n\n**3.启动Nginx**\n\n刚安装的Nginx不会自行启动。运行Nginx:\n```\nsudo systemctl start nginx.service\n```\n如果一切进展顺利的话，现在你可以通过你的域名或IP来访问你的Web页面来预览一下Nginx的默认页面\n\n>当然，这里一般很可能会无法访问的。\n\n我们先不急于解决我们的问题，先看看nginx的基本配置：\n\n\nNginx配置信息\n```\n网站文件存放默认目录\n\n/usr/share/nginx/html\n网站默认站点配置\n\n/etc/nginx/conf.d/default.conf\n自定义Nginx站点配置文件存放目录,自己在这里也可以定义别的名字的.conf，这个的作用以后再说。\n\n/etc/nginx/conf.d/\nNginx全局配置\n\n/etc/nginx/nginx.conf\n在这里你可以改变设置用户运行Nginx守护程序进程一样,和工作进程的数量得到了Nginx正在运行,等等。\n```\nLinux查看公网IP\n\n您可以运行以下命令来显示你的服务器的公共IP地址:(这个其实没用，不是公网IP)\n```\nip addr show eth0 | grep inet | awk '{ print $2; }' | sed 's/\\/.*$//'\n```\n___\n好了，这个时候我们再来看看可能遇到的问题：无法在公网访问。\n\n这个时候首先看看配置文件default.conf对不对，一个正确的例子：\n(域名要先进行解析到响应的IP)\n```\nserver {\n    listen       80;\n    server_name  nginx.310058.cn;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/log/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n```\n\n确定文件没问题了，看看这个时候是不是开启了nginx进程：\n\n```\n ps -ef | grep nginx\n```\n\n应该会输出一个或者多个进程，如果没有的话就开启或者重启试试看。\n\n这个时候接下来再试试在服务器上：\n```\nping  115.29.102.81\ntelnet 115.29.102.81 80\nwget nginx.310058.cn\n```\n如果有的命令没有就直接yum安装下:\n```\nyum -y install telnet\n```\n如果都可以的话，之后在本机尝试以上三行。如果没有命令也要安装下：\n```\nbrew install wget\n```\n\n发现很可能本机telnet不通，而服务器telnet通。\n这个时候就是**防火墙**的问题。\n\n####centos7.2防火墙\n\n由于centos 7版本以后默认使用firewalld后，网上关于iptables的设置方法已经不管用了，所以根本就别想用配置iptables做啥，根本没用。\n\n查看下防火墙状态：\n```\n[root@iZ28dcsp7egZ conf.d]# systemctl status firewalld  \n● firewalld.service - firewalld - dynamic firewall daemon\n   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)\n   Active: active (running) since Wed 2016-08-03 12:06:44 CST; 2h 49min ago\n Main PID: 424 (firewalld)\n   CGroup: /system.slice/firewalld.service\n           └─424 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid\n\nAug 03 12:06:41 iZ28dcsp7egZ systemd[1]: Starting firewalld - dynamic firewall daemon...\nAug 03 12:06:44 iZ28dcsp7egZ systemd[1]: Started firewalld - dynamic firewall daemon.\n```\n\n增加80端口的权限：\n```\nfirewall-cmd --zone=public --add-port=80/tcp --permanent  \n```\n \n 别忘了更新防火墙的配置：\n```\nfirewall-cmd --reload\n```\n这个时候再`restart  nginx.service` 一下就会发现应该好了。\n\n\nnginx 停止：\n\n```\nservice nginx restart\n也可以重启nginx\n\nkill -QUIT 进程号  \n#从容停止\n\nkill -TERM 进程号\n#或者\nkill -INT 进程号\n#快速停止\n\np-kill -9 nginx\n强制停止\n\nnginx -t \n#验证配置文件 前提是进入相应的配置的目录（自己实际测试的时候发现没有进入相应的配置目录也是可以的）\n\nnginx -s reload\n#重启\n\nkill -HUP 进程号\n#重启的另外一种方式\n```\n\n官方文档地址：\nhttps://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html#sec-Introduction_to_firewalld\n\n附1:一个简单的负载均衡的实现:\nweight默认是1，自己也可以更改。\n```\nupstream mypro {\n\t\t\t\tip_hash;\n                server 111.13.100.92 weight=2;\n                server 183.232.41.1;\n                server 42.156.140.7;\n                }\n\n        server {\n                listen 8090;\n                location / {\n                proxy_pass http://mypro;\n                }\n        }\n\n```\n\n\n附2:防火墙基本学习：\n\n``` \n\n1、firewalld简介\nfirewalld是centos7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念\n \nfirewalld有图形界面和工具界面，由于我在服务器上使用，图形界面请参照官方文档，本文以字符界面做介绍\n \nfirewalld的字符界面管理工具是 firewall-cmd \n \nfirewalld默认配置文件有两个：/usr/lib/firewalld/ （系统配置，尽量不要修改）和 /etc/firewalld/ （用户配置地址）\n \nzone概念：\n硬件防火墙默认一般有三个区，firewalld引入这一概念系统默认存在以下区域（根据文档自己理解，如果有误请指正）：\ndrop：默认丢弃所有包\nblock：拒绝所有外部连接，允许内部发起的连接\npublic：指定外部连接可以进入\nexternal：这个不太明白，功能上和上面相同，允许指定的外部连接\ndmz：和硬件防火墙一样，受限制的公共连接可以进入\nwork：工作区，概念和workgoup一样，也是指定的外部连接允许\nhome：类似家庭组\ninternal：信任所有连接\n对防火墙不算太熟悉，还没想明白public、external、dmz、work、home从功能上都需要自定义允许连接，具体使用上的区别还需高人指点\n \n2、安装firewalld\nroot执行 # yum install firewalld firewall-config\n \n3、运行、停止、禁用firewalld\n启动：# systemctl start  firewalld\n查看状态：# systemctl status firewalld 或者 firewall-cmd --state\n停止：# systemctl disable firewalld\n禁用：# systemctl stop firewalld\n \n4、配置firewalld\n查看版本：$ firewall-cmd --version\n查看帮助：$ firewall-cmd --help\n查看设置：\n                显示状态：$ firewall-cmd --state\n                查看区域信息: $ firewall-cmd --get-active-zones\n                查看指定接口所属区域：$ firewall-cmd --get-zone-of-interface=eth0\n拒绝所有包：# firewall-cmd --panic-on\n取消拒绝状态：# firewall-cmd --panic-off\n查看是否拒绝：$ firewall-cmd --query-panic\n \n更新防火墙规则：# firewall-cmd --reload\n                            # firewall-cmd --complete-reload\n    两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务\n \n将接口添加到区域，默认接口都在public\n# firewall-cmd --zone=public --add-interface=eth0\n永久生效再加上 --permanent 然后reload防火墙\n \n设置默认接口区域\n# firewall-cmd --set-default-zone=public\n立即生效无需重启\n \n打开端口（貌似这个才最常用）\n查看所有打开的端口：\n# firewall-cmd --zone=dmz --list-ports\n加入一个端口到区域：\n# firewall-cmd --zone=dmz --add-port=8080/tcp\n若要永久生效方法同上\n \n打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档\n# firewall-cmd --zone=work --add-service=smtp\n \n移除服务\n# firewall-cmd --zone=work --remove-service=smtp\n \n还有端口转发功能、自定义复杂规则功能、lockdown，由于还没用到，以后再学习\n\n```\n","slug":"centOS7-2搭建nginx环境以及负载均衡","published":1,"updated":"2021-12-23T01:51:10.324Z","comments":1,"photos":[],"link":"","_id":"ckxijpqsn000fd3mrekp5c9f6","content":"<p> 之所以要整理出这篇文章，是因为1是搭建环境的过程中会遇到大大小小各种问题，2是网上目前也没有关于centos7.2搭建nginx环境的问题整理，因此在这里记录。</p>\n<p>前置工作就不赘述了，首先<code>ssh root@115.29.102.81</code> (换成你们自己的公网IP)登陆进入到自己的服务器命令行，之后开始基本的安装：</p>\n<p><strong>1.添加资源</strong></p>\n<p>添加CentOS 7 Nginx yum资源库,打开终端,使用以下命令(没有换行):</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm -Uvh http:<span class=\"regexp\">//</span>nginx.org<span class=\"regexp\">/packages/</span>centos<span class=\"regexp\">/7/</span>noarch<span class=\"regexp\">/RPMS/</span>nginx-release-centos-<span class=\"number\">7</span>-<span class=\"number\">0</span>.el7.ngx.noarch.rpm</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>2.安装Nginx</strong></p>\n<p>在你的CentOS 7 服务器中使用yum命令从Nginx源服务器中获取来安装Nginx：</p>\n<blockquote>\n<p><em>这里有一个需要注意的地方，尽量不要用网上的下载源码包然后再传到服务器上的方式进行安装，因为nginx已经不算是简单的Linux了，做了很多扩展，这个时候如果你用源码包安装会出现各种各样的问题，尽量用已经封装好的rpm\\yum进行安装</em></p>\n</blockquote>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum <span class=\"keyword\">install</span> -y nginx</span><br></pre></td></tr></table></figure>\n<p>Nginx将完成安装在你的CentOS 7 服务器中。</p>\n<p><strong>3.启动Nginx</strong></p>\n<p>刚安装的Nginx不会自行启动。运行Nginx:</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl <span class=\"literal\">start</span> nginx.service</span><br></pre></td></tr></table></figure>\n<p>如果一切进展顺利的话，现在你可以通过你的域名或IP来访问你的Web页面来预览一下Nginx的默认页面</p>\n<blockquote>\n<p>当然，这里一般很可能会无法访问的。</p>\n</blockquote>\n<p>我们先不急于解决我们的问题，先看看nginx的基本配置：</p>\n<p>Nginx配置信息</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网站文件存放默认目录</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">/usr/</span>share<span class=\"regexp\">/nginx/</span>html</span><br><span class=\"line\">网站默认站点配置</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">/etc/</span>nginx<span class=\"regexp\">/conf.d/</span><span class=\"keyword\">default</span>.conf</span><br><span class=\"line\">自定义Nginx站点配置文件存放目录,自己在这里也可以定义别的名字的.conf，这个的作用以后再说。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">/etc/</span>nginx<span class=\"regexp\">/conf.d/</span></span><br><span class=\"line\">Nginx全局配置</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">/etc/</span>nginx/nginx.conf</span><br><span class=\"line\">在这里你可以改变设置用户运行Nginx守护程序进程一样,和工作进程的数量得到了Nginx正在运行,等等。</span><br></pre></td></tr></table></figure>\n<p>Linux查看公网IP</p>\n<p>您可以运行以下命令来显示你的服务器的公共IP地址:(这个其实没用，不是公网IP)</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip addr <span class=\"keyword\">show</span> eth0 | grep inet | awk <span class=\"string\">&#x27;&#123; print <span class=\"subst\">$2</span>; &#125;&#x27;</span> | sed <span class=\"string\">&#x27;s/\\/.*$//&#x27;</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>好了，这个时候我们再来看看可能遇到的问题：无法在公网访问。</p>\n<p>这个时候首先看看配置文件default.conf对不对，一个正确的例子：<br>(域名要先进行解析到响应的IP)</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">listen</span>       <span class=\"number\">80</span>;</span><br><span class=\"line\">    server_name  nginx<span class=\"number\">.310058</span>.cn;</span><br><span class=\"line\"></span><br><span class=\"line\">    #charset koi8-r;</span><br><span class=\"line\">    #access_log  /var/<span class=\"keyword\">log</span>/nginx/<span class=\"keyword\">log</span>/host.<span class=\"keyword\">access</span>.<span class=\"keyword\">log</span>  main;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">location</span> / &#123;</span><br><span class=\"line\">        root   /usr/<span class=\"keyword\">share</span>/nginx/html;</span><br><span class=\"line\">        <span class=\"keyword\">index</span>  <span class=\"keyword\">index</span>.html <span class=\"keyword\">index</span>.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #error_page  <span class=\"number\">404</span>              /<span class=\"number\">404.</span>html;</span><br><span class=\"line\"></span><br><span class=\"line\">    # redirect <span class=\"keyword\">server</span> error pages <span class=\"keyword\">to</span> the static page /<span class=\"number\">50</span>x.html</span><br><span class=\"line\">    #</span><br><span class=\"line\">    error_page   <span class=\"number\">500</span> <span class=\"number\">502</span> <span class=\"number\">503</span> <span class=\"number\">504</span>  /<span class=\"number\">50</span>x.html;</span><br><span class=\"line\">    <span class=\"keyword\">location</span> = /<span class=\"number\">50</span>x.html &#123;</span><br><span class=\"line\">        root   /usr/<span class=\"keyword\">share</span>/nginx/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # proxy the PHP scripts <span class=\"keyword\">to</span> Apache listening <span class=\"keyword\">on</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">80</span></span><br><span class=\"line\">    #</span><br><span class=\"line\">    #<span class=\"keyword\">location</span> ~ \\.php$ &#123;</span><br><span class=\"line\">    #    proxy_pass   http://<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # pass the PHP scripts <span class=\"keyword\">to</span> FastCGI <span class=\"keyword\">server</span> listening <span class=\"keyword\">on</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">9000</span></span><br><span class=\"line\">    #</span><br><span class=\"line\">    #<span class=\"keyword\">location</span> ~ \\.php$ &#123;</span><br><span class=\"line\">    #    root           html;</span><br><span class=\"line\">    #    fastcgi_pass   <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">9000</span>;</span><br><span class=\"line\">    #    fastcgi_index  <span class=\"keyword\">index</span>.php;</span><br><span class=\"line\">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class=\"line\">    #    <span class=\"keyword\">include</span>        fastcgi_params;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # deny <span class=\"keyword\">access</span> <span class=\"keyword\">to</span> .htaccess files, <span class=\"keyword\">if</span> Apach<span class=\"string\">e&#x27;s document root</span></span><br><span class=\"line\"><span class=\"string\">    # concurs with nginx&#x27;</span>s one</span><br><span class=\"line\">    #</span><br><span class=\"line\">    #<span class=\"keyword\">location</span> ~ /\\.ht &#123;</span><br><span class=\"line\">    #    deny  <span class=\"keyword\">all</span>;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>确定文件没问题了，看看这个时候是不是开启了nginx进程：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ps</span> -ef | <span class=\"keyword\">grep</span> nginx</span><br></pre></td></tr></table></figure>\n\n<p>应该会输出一个或者多个进程，如果没有的话就开启或者重启试试看。</p>\n<p>这个时候接下来再试试在服务器上：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">ping</span>  <span class=\"number\">115.29.102.81</span></span><br><span class=\"line\"><span class=\"attribute\">telnet</span> <span class=\"number\">115.29.102.81</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"attribute\">wget</span> nginx.<span class=\"number\">310058</span>.cn</span><br></pre></td></tr></table></figure>\n<p>如果有的命令没有就直接yum安装下:</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y <span class=\"keyword\">install</span> telnet</span><br></pre></td></tr></table></figure>\n<p>如果都可以的话，之后在本机尝试以上三行。如果没有命令也要安装下：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">brew </span><span class=\"keyword\">install </span>wget</span><br></pre></td></tr></table></figure>\n\n<p>发现很可能本机telnet不通，而服务器telnet通。<br>这个时候就是<strong>防火墙</strong>的问题。</p>\n<p>####centos7.2防火墙</p>\n<p>由于centos 7版本以后默认使用firewalld后，网上关于iptables的设置方法已经不管用了，所以根本就别想用配置iptables做啥，根本没用。</p>\n<p>查看下防火墙状态：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ28dcsp7egZ conf.d]<span class=\"comment\"># systemctl status firewalld  </span></span><br><span class=\"line\">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class=\"line\">   Loaded: loaded (<span class=\"regexp\">/usr/</span>lib<span class=\"regexp\">/systemd/</span>system/firewalld.service; enabled; vendor preset: enabled)</span><br><span class=\"line\">   Active: active (running) since Wed <span class=\"number\">2016</span>-<span class=\"number\">08</span>-<span class=\"number\">03</span> <span class=\"number\">12</span>:<span class=\"number\">06</span>:<span class=\"number\">44</span> CST; <span class=\"number\">2</span>h <span class=\"number\">49</span>min ago</span><br><span class=\"line\"> Main PID: <span class=\"number\">424</span> (firewalld)</span><br><span class=\"line\">   CGroup: <span class=\"regexp\">/system.slice/</span>firewalld.service</span><br><span class=\"line\">           └─<span class=\"number\">424</span> <span class=\"regexp\">/usr/</span>bin<span class=\"regexp\">/python -Es /u</span>sr<span class=\"regexp\">/sbin/</span>firewalld --nofork --nopid</span><br><span class=\"line\"></span><br><span class=\"line\">Aug <span class=\"number\">03</span> <span class=\"number\">12</span>:<span class=\"number\">06</span>:<span class=\"number\">41</span> iZ28dcsp7egZ systemd[<span class=\"number\">1</span>]: Starting firewalld - dynamic firewall daemon...</span><br><span class=\"line\">Aug <span class=\"number\">03</span> <span class=\"number\">12</span>:<span class=\"number\">06</span>:<span class=\"number\">44</span> iZ28dcsp7egZ systemd[<span class=\"number\">1</span>]: Started firewalld - dynamic firewall daemon.</span><br></pre></td></tr></table></figure>\n\n<p>增加80端口的权限：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd <span class=\"attribute\">--zone</span>=public <span class=\"attribute\">--add-port</span>=80/tcp --permanent  </span><br></pre></td></tr></table></figure>\n<p> 别忘了更新防火墙的配置：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd <span class=\"comment\">--reload</span></span><br></pre></td></tr></table></figure>\n<p>这个时候再<code>restart  nginx.service</code> 一下就会发现应该好了。</p>\n<p>nginx 停止：</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx restart</span><br><span class=\"line\">也可以重启nginx</span><br><span class=\"line\"></span><br><span class=\"line\">kill -QUIT 进程号  </span><br><span class=\"line\"><span class=\"meta\">#从容停止</span></span><br><span class=\"line\"></span><br><span class=\"line\">kill -TERM 进程号</span><br><span class=\"line\"><span class=\"meta\">#或者</span></span><br><span class=\"line\">kill -INT 进程号</span><br><span class=\"line\"><span class=\"meta\">#快速停止</span></span><br><span class=\"line\"></span><br><span class=\"line\">p-kill <span class=\"number\">-9</span> nginx</span><br><span class=\"line\">强制停止</span><br><span class=\"line\"></span><br><span class=\"line\">nginx -t </span><br><span class=\"line\"><span class=\"meta\">#验证配置文件 前提是进入相应的配置的目录（自己实际测试的时候发现没有进入相应的配置目录也是可以的）</span></span><br><span class=\"line\"></span><br><span class=\"line\">nginx -s reload</span><br><span class=\"line\"><span class=\"meta\">#重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">kill -HUP 进程号</span><br><span class=\"line\"><span class=\"meta\">#重启的另外一种方式</span></span><br></pre></td></tr></table></figure>\n\n<p>官方文档地址：<br><a href=\"https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html#sec-Introduction_to_firewalld\">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html#sec-Introduction_to_firewalld</a></p>\n<p>附1:一个简单的负载均衡的实现:<br>weight默认是1，自己也可以更改。</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream mypro &#123;</span><br><span class=\"line\">\t\t\t\tip_hash;</span><br><span class=\"line\">                <span class=\"keyword\">server</span> <span class=\"number\">111.13</span><span class=\"number\">.100</span><span class=\"number\">.92</span> weight=<span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">server</span> <span class=\"number\">183.232</span><span class=\"number\">.41</span><span class=\"number\">.1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">server</span> <span class=\"number\">42.156</span><span class=\"number\">.140</span><span class=\"number\">.7</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">server</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">listen</span> <span class=\"number\">8090</span>;</span><br><span class=\"line\">                <span class=\"keyword\">location</span> / &#123;</span><br><span class=\"line\">                proxy_pass http://mypro;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>附2:防火墙基本学习：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>、firewalld简介</span><br><span class=\"line\">firewalld是centos7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“<span class=\"type\">zone</span>”概念</span><br><span class=\"line\"> </span><br><span class=\"line\">firewalld有图形界面和工具界面，由于我在服务器上使用，图形界面请参照官方文档，本文以字符界面做介绍</span><br><span class=\"line\"> </span><br><span class=\"line\">firewalld的字符界面管理工具是 firewall-cmd </span><br><span class=\"line\"> </span><br><span class=\"line\">firewalld默认配置文件有两个：/usr/lib/firewalld/ （系统配置，尽量不要修改）和 /etc/firewalld/ （用户配置地址）</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">zone</span>概念：</span><br><span class=\"line\">硬件防火墙默认一般有三个区，firewalld引入这一概念系统默认存在以下区域（根据文档自己理解，如果有误请指正）：</span><br><span class=\"line\"><span class=\"keyword\">drop</span>：默认丢弃所有包</span><br><span class=\"line\">block：拒绝所有外部连接，允许内部发起的连接</span><br><span class=\"line\"><span class=\"built_in\">public</span>：指定外部连接可以进入</span><br><span class=\"line\"><span class=\"keyword\">external</span>：这个不太明白，功能上和上面相同，允许指定的外部连接</span><br><span class=\"line\">dmz：和硬件防火墙一样，受限制的公共连接可以进入</span><br><span class=\"line\"><span class=\"keyword\">work</span>：工作区，概念和workgoup一样，也是指定的外部连接允许</span><br><span class=\"line\">home：类似家庭组</span><br><span class=\"line\"><span class=\"type\">internal</span>：信任所有连接</span><br><span class=\"line\">对防火墙不算太熟悉，还没想明白<span class=\"built_in\">public</span>、<span class=\"keyword\">external</span>、dmz、<span class=\"keyword\">work</span>、home从功能上都需要自定义允许连接，具体使用上的区别还需高人指点</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"number\">2</span>、安装firewalld</span><br><span class=\"line\">root执行 # yum install firewalld firewall-config</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"number\">3</span>、运行、停止、禁用firewalld</span><br><span class=\"line\">启动：# systemctl <span class=\"keyword\">start</span>  firewalld</span><br><span class=\"line\">查看状态：# systemctl status firewalld 或者 firewall-cmd <span class=\"comment\">--state</span></span><br><span class=\"line\">停止：# systemctl <span class=\"keyword\">disable</span> firewalld</span><br><span class=\"line\">禁用：# systemctl stop firewalld</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"number\">4</span>、配置firewalld</span><br><span class=\"line\">查看版本：$ firewall-cmd <span class=\"comment\">--version</span></span><br><span class=\"line\">查看帮助：$ firewall-cmd <span class=\"comment\">--help</span></span><br><span class=\"line\">查看设置：</span><br><span class=\"line\">                显示状态：$ firewall-cmd <span class=\"comment\">--state</span></span><br><span class=\"line\">                查看区域信息: $ firewall-cmd <span class=\"comment\">--get-active-zones</span></span><br><span class=\"line\">                查看指定接口所属区域：$ firewall-cmd <span class=\"comment\">--get-zone-of-interface=eth0</span></span><br><span class=\"line\">拒绝所有包：# firewall-cmd <span class=\"comment\">--panic-on</span></span><br><span class=\"line\">取消拒绝状态：# firewall-cmd <span class=\"comment\">--panic-off</span></span><br><span class=\"line\">查看是否拒绝：$ firewall-cmd <span class=\"comment\">--query-panic</span></span><br><span class=\"line\"> </span><br><span class=\"line\">更新防火墙规则：# firewall-cmd <span class=\"comment\">--reload</span></span><br><span class=\"line\">                            # firewall-cmd <span class=\"comment\">--complete-reload</span></span><br><span class=\"line\">    两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务</span><br><span class=\"line\"> </span><br><span class=\"line\">将接口添加到区域，默认接口都在<span class=\"built_in\">public</span></span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--zone=public --add-interface=eth0</span></span><br><span class=\"line\">永久生效再加上 <span class=\"comment\">--permanent 然后reload防火墙</span></span><br><span class=\"line\"> </span><br><span class=\"line\">设置默认接口区域</span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--set-default-zone=public</span></span><br><span class=\"line\">立即生效无需重启</span><br><span class=\"line\"> </span><br><span class=\"line\">打开端口（貌似这个才最常用）</span><br><span class=\"line\">查看所有打开的端口：</span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--zone=dmz --list-ports</span></span><br><span class=\"line\">加入一个端口到区域：</span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--zone=dmz --add-port=8080/tcp</span></span><br><span class=\"line\">若要永久生效方法同上</span><br><span class=\"line\"> </span><br><span class=\"line\">打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档</span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--zone=work --add-service=smtp</span></span><br><span class=\"line\"> </span><br><span class=\"line\">移除服务</span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--zone=work --remove-service=smtp</span></span><br><span class=\"line\"> </span><br><span class=\"line\">还有端口转发功能、自定义复杂规则功能、lockdown，由于还没用到，以后再学习</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p> 之所以要整理出这篇文章，是因为1是搭建环境的过程中会遇到大大小小各种问题，2是网上目前也没有关于centos7.2搭建nginx环境的问题整理，因此在这里记录。</p>\n<p>前置工作就不赘述了，首先<code>ssh root@115.29.102.81</code> (换成你们自己的公网IP)登陆进入到自己的服务器命令行，之后开始基本的安装：</p>\n<p><strong>1.添加资源</strong></p>\n<p>添加CentOS 7 Nginx yum资源库,打开终端,使用以下命令(没有换行):</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm -Uvh http:<span class=\"regexp\">//</span>nginx.org<span class=\"regexp\">/packages/</span>centos<span class=\"regexp\">/7/</span>noarch<span class=\"regexp\">/RPMS/</span>nginx-release-centos-<span class=\"number\">7</span>-<span class=\"number\">0</span>.el7.ngx.noarch.rpm</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>2.安装Nginx</strong></p>\n<p>在你的CentOS 7 服务器中使用yum命令从Nginx源服务器中获取来安装Nginx：</p>\n<blockquote>\n<p><em>这里有一个需要注意的地方，尽量不要用网上的下载源码包然后再传到服务器上的方式进行安装，因为nginx已经不算是简单的Linux了，做了很多扩展，这个时候如果你用源码包安装会出现各种各样的问题，尽量用已经封装好的rpm\\yum进行安装</em></p>\n</blockquote>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum <span class=\"keyword\">install</span> -y nginx</span><br></pre></td></tr></table></figure>\n<p>Nginx将完成安装在你的CentOS 7 服务器中。</p>\n<p><strong>3.启动Nginx</strong></p>\n<p>刚安装的Nginx不会自行启动。运行Nginx:</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl <span class=\"literal\">start</span> nginx.service</span><br></pre></td></tr></table></figure>\n<p>如果一切进展顺利的话，现在你可以通过你的域名或IP来访问你的Web页面来预览一下Nginx的默认页面</p>\n<blockquote>\n<p>当然，这里一般很可能会无法访问的。</p>\n</blockquote>\n<p>我们先不急于解决我们的问题，先看看nginx的基本配置：</p>\n<p>Nginx配置信息</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网站文件存放默认目录</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">/usr/</span>share<span class=\"regexp\">/nginx/</span>html</span><br><span class=\"line\">网站默认站点配置</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">/etc/</span>nginx<span class=\"regexp\">/conf.d/</span><span class=\"keyword\">default</span>.conf</span><br><span class=\"line\">自定义Nginx站点配置文件存放目录,自己在这里也可以定义别的名字的.conf，这个的作用以后再说。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">/etc/</span>nginx<span class=\"regexp\">/conf.d/</span></span><br><span class=\"line\">Nginx全局配置</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">/etc/</span>nginx/nginx.conf</span><br><span class=\"line\">在这里你可以改变设置用户运行Nginx守护程序进程一样,和工作进程的数量得到了Nginx正在运行,等等。</span><br></pre></td></tr></table></figure>\n<p>Linux查看公网IP</p>\n<p>您可以运行以下命令来显示你的服务器的公共IP地址:(这个其实没用，不是公网IP)</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip addr <span class=\"keyword\">show</span> eth0 | grep inet | awk <span class=\"string\">&#x27;&#123; print <span class=\"subst\">$2</span>; &#125;&#x27;</span> | sed <span class=\"string\">&#x27;s/\\/.*$//&#x27;</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>好了，这个时候我们再来看看可能遇到的问题：无法在公网访问。</p>\n<p>这个时候首先看看配置文件default.conf对不对，一个正确的例子：<br>(域名要先进行解析到响应的IP)</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">listen</span>       <span class=\"number\">80</span>;</span><br><span class=\"line\">    server_name  nginx<span class=\"number\">.310058</span>.cn;</span><br><span class=\"line\"></span><br><span class=\"line\">    #charset koi8-r;</span><br><span class=\"line\">    #access_log  /var/<span class=\"keyword\">log</span>/nginx/<span class=\"keyword\">log</span>/host.<span class=\"keyword\">access</span>.<span class=\"keyword\">log</span>  main;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">location</span> / &#123;</span><br><span class=\"line\">        root   /usr/<span class=\"keyword\">share</span>/nginx/html;</span><br><span class=\"line\">        <span class=\"keyword\">index</span>  <span class=\"keyword\">index</span>.html <span class=\"keyword\">index</span>.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #error_page  <span class=\"number\">404</span>              /<span class=\"number\">404.</span>html;</span><br><span class=\"line\"></span><br><span class=\"line\">    # redirect <span class=\"keyword\">server</span> error pages <span class=\"keyword\">to</span> the static page /<span class=\"number\">50</span>x.html</span><br><span class=\"line\">    #</span><br><span class=\"line\">    error_page   <span class=\"number\">500</span> <span class=\"number\">502</span> <span class=\"number\">503</span> <span class=\"number\">504</span>  /<span class=\"number\">50</span>x.html;</span><br><span class=\"line\">    <span class=\"keyword\">location</span> = /<span class=\"number\">50</span>x.html &#123;</span><br><span class=\"line\">        root   /usr/<span class=\"keyword\">share</span>/nginx/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # proxy the PHP scripts <span class=\"keyword\">to</span> Apache listening <span class=\"keyword\">on</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">80</span></span><br><span class=\"line\">    #</span><br><span class=\"line\">    #<span class=\"keyword\">location</span> ~ \\.php$ &#123;</span><br><span class=\"line\">    #    proxy_pass   http://<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # pass the PHP scripts <span class=\"keyword\">to</span> FastCGI <span class=\"keyword\">server</span> listening <span class=\"keyword\">on</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">9000</span></span><br><span class=\"line\">    #</span><br><span class=\"line\">    #<span class=\"keyword\">location</span> ~ \\.php$ &#123;</span><br><span class=\"line\">    #    root           html;</span><br><span class=\"line\">    #    fastcgi_pass   <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">9000</span>;</span><br><span class=\"line\">    #    fastcgi_index  <span class=\"keyword\">index</span>.php;</span><br><span class=\"line\">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class=\"line\">    #    <span class=\"keyword\">include</span>        fastcgi_params;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # deny <span class=\"keyword\">access</span> <span class=\"keyword\">to</span> .htaccess files, <span class=\"keyword\">if</span> Apach<span class=\"string\">e&#x27;s document root</span></span><br><span class=\"line\"><span class=\"string\">    # concurs with nginx&#x27;</span>s one</span><br><span class=\"line\">    #</span><br><span class=\"line\">    #<span class=\"keyword\">location</span> ~ /\\.ht &#123;</span><br><span class=\"line\">    #    deny  <span class=\"keyword\">all</span>;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>确定文件没问题了，看看这个时候是不是开启了nginx进程：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ps</span> -ef | <span class=\"keyword\">grep</span> nginx</span><br></pre></td></tr></table></figure>\n\n<p>应该会输出一个或者多个进程，如果没有的话就开启或者重启试试看。</p>\n<p>这个时候接下来再试试在服务器上：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">ping</span>  <span class=\"number\">115.29.102.81</span></span><br><span class=\"line\"><span class=\"attribute\">telnet</span> <span class=\"number\">115.29.102.81</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"attribute\">wget</span> nginx.<span class=\"number\">310058</span>.cn</span><br></pre></td></tr></table></figure>\n<p>如果有的命令没有就直接yum安装下:</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y <span class=\"keyword\">install</span> telnet</span><br></pre></td></tr></table></figure>\n<p>如果都可以的话，之后在本机尝试以上三行。如果没有命令也要安装下：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">brew </span><span class=\"keyword\">install </span>wget</span><br></pre></td></tr></table></figure>\n\n<p>发现很可能本机telnet不通，而服务器telnet通。<br>这个时候就是<strong>防火墙</strong>的问题。</p>\n<p>####centos7.2防火墙</p>\n<p>由于centos 7版本以后默认使用firewalld后，网上关于iptables的设置方法已经不管用了，所以根本就别想用配置iptables做啥，根本没用。</p>\n<p>查看下防火墙状态：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ28dcsp7egZ conf.d]<span class=\"comment\"># systemctl status firewalld  </span></span><br><span class=\"line\">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class=\"line\">   Loaded: loaded (<span class=\"regexp\">/usr/</span>lib<span class=\"regexp\">/systemd/</span>system/firewalld.service; enabled; vendor preset: enabled)</span><br><span class=\"line\">   Active: active (running) since Wed <span class=\"number\">2016</span>-<span class=\"number\">08</span>-<span class=\"number\">03</span> <span class=\"number\">12</span>:<span class=\"number\">06</span>:<span class=\"number\">44</span> CST; <span class=\"number\">2</span>h <span class=\"number\">49</span>min ago</span><br><span class=\"line\"> Main PID: <span class=\"number\">424</span> (firewalld)</span><br><span class=\"line\">   CGroup: <span class=\"regexp\">/system.slice/</span>firewalld.service</span><br><span class=\"line\">           └─<span class=\"number\">424</span> <span class=\"regexp\">/usr/</span>bin<span class=\"regexp\">/python -Es /u</span>sr<span class=\"regexp\">/sbin/</span>firewalld --nofork --nopid</span><br><span class=\"line\"></span><br><span class=\"line\">Aug <span class=\"number\">03</span> <span class=\"number\">12</span>:<span class=\"number\">06</span>:<span class=\"number\">41</span> iZ28dcsp7egZ systemd[<span class=\"number\">1</span>]: Starting firewalld - dynamic firewall daemon...</span><br><span class=\"line\">Aug <span class=\"number\">03</span> <span class=\"number\">12</span>:<span class=\"number\">06</span>:<span class=\"number\">44</span> iZ28dcsp7egZ systemd[<span class=\"number\">1</span>]: Started firewalld - dynamic firewall daemon.</span><br></pre></td></tr></table></figure>\n\n<p>增加80端口的权限：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd <span class=\"attribute\">--zone</span>=public <span class=\"attribute\">--add-port</span>=80/tcp --permanent  </span><br></pre></td></tr></table></figure>\n<p> 别忘了更新防火墙的配置：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd <span class=\"comment\">--reload</span></span><br></pre></td></tr></table></figure>\n<p>这个时候再<code>restart  nginx.service</code> 一下就会发现应该好了。</p>\n<p>nginx 停止：</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx restart</span><br><span class=\"line\">也可以重启nginx</span><br><span class=\"line\"></span><br><span class=\"line\">kill -QUIT 进程号  </span><br><span class=\"line\"><span class=\"meta\">#从容停止</span></span><br><span class=\"line\"></span><br><span class=\"line\">kill -TERM 进程号</span><br><span class=\"line\"><span class=\"meta\">#或者</span></span><br><span class=\"line\">kill -INT 进程号</span><br><span class=\"line\"><span class=\"meta\">#快速停止</span></span><br><span class=\"line\"></span><br><span class=\"line\">p-kill <span class=\"number\">-9</span> nginx</span><br><span class=\"line\">强制停止</span><br><span class=\"line\"></span><br><span class=\"line\">nginx -t </span><br><span class=\"line\"><span class=\"meta\">#验证配置文件 前提是进入相应的配置的目录（自己实际测试的时候发现没有进入相应的配置目录也是可以的）</span></span><br><span class=\"line\"></span><br><span class=\"line\">nginx -s reload</span><br><span class=\"line\"><span class=\"meta\">#重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">kill -HUP 进程号</span><br><span class=\"line\"><span class=\"meta\">#重启的另外一种方式</span></span><br></pre></td></tr></table></figure>\n\n<p>官方文档地址：<br><a href=\"https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html#sec-Introduction_to_firewalld\">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html#sec-Introduction_to_firewalld</a></p>\n<p>附1:一个简单的负载均衡的实现:<br>weight默认是1，自己也可以更改。</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream mypro &#123;</span><br><span class=\"line\">\t\t\t\tip_hash;</span><br><span class=\"line\">                <span class=\"keyword\">server</span> <span class=\"number\">111.13</span><span class=\"number\">.100</span><span class=\"number\">.92</span> weight=<span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">server</span> <span class=\"number\">183.232</span><span class=\"number\">.41</span><span class=\"number\">.1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">server</span> <span class=\"number\">42.156</span><span class=\"number\">.140</span><span class=\"number\">.7</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">server</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">listen</span> <span class=\"number\">8090</span>;</span><br><span class=\"line\">                <span class=\"keyword\">location</span> / &#123;</span><br><span class=\"line\">                proxy_pass http://mypro;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>附2:防火墙基本学习：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>、firewalld简介</span><br><span class=\"line\">firewalld是centos7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“<span class=\"type\">zone</span>”概念</span><br><span class=\"line\"> </span><br><span class=\"line\">firewalld有图形界面和工具界面，由于我在服务器上使用，图形界面请参照官方文档，本文以字符界面做介绍</span><br><span class=\"line\"> </span><br><span class=\"line\">firewalld的字符界面管理工具是 firewall-cmd </span><br><span class=\"line\"> </span><br><span class=\"line\">firewalld默认配置文件有两个：/usr/lib/firewalld/ （系统配置，尽量不要修改）和 /etc/firewalld/ （用户配置地址）</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">zone</span>概念：</span><br><span class=\"line\">硬件防火墙默认一般有三个区，firewalld引入这一概念系统默认存在以下区域（根据文档自己理解，如果有误请指正）：</span><br><span class=\"line\"><span class=\"keyword\">drop</span>：默认丢弃所有包</span><br><span class=\"line\">block：拒绝所有外部连接，允许内部发起的连接</span><br><span class=\"line\"><span class=\"built_in\">public</span>：指定外部连接可以进入</span><br><span class=\"line\"><span class=\"keyword\">external</span>：这个不太明白，功能上和上面相同，允许指定的外部连接</span><br><span class=\"line\">dmz：和硬件防火墙一样，受限制的公共连接可以进入</span><br><span class=\"line\"><span class=\"keyword\">work</span>：工作区，概念和workgoup一样，也是指定的外部连接允许</span><br><span class=\"line\">home：类似家庭组</span><br><span class=\"line\"><span class=\"type\">internal</span>：信任所有连接</span><br><span class=\"line\">对防火墙不算太熟悉，还没想明白<span class=\"built_in\">public</span>、<span class=\"keyword\">external</span>、dmz、<span class=\"keyword\">work</span>、home从功能上都需要自定义允许连接，具体使用上的区别还需高人指点</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"number\">2</span>、安装firewalld</span><br><span class=\"line\">root执行 # yum install firewalld firewall-config</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"number\">3</span>、运行、停止、禁用firewalld</span><br><span class=\"line\">启动：# systemctl <span class=\"keyword\">start</span>  firewalld</span><br><span class=\"line\">查看状态：# systemctl status firewalld 或者 firewall-cmd <span class=\"comment\">--state</span></span><br><span class=\"line\">停止：# systemctl <span class=\"keyword\">disable</span> firewalld</span><br><span class=\"line\">禁用：# systemctl stop firewalld</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"number\">4</span>、配置firewalld</span><br><span class=\"line\">查看版本：$ firewall-cmd <span class=\"comment\">--version</span></span><br><span class=\"line\">查看帮助：$ firewall-cmd <span class=\"comment\">--help</span></span><br><span class=\"line\">查看设置：</span><br><span class=\"line\">                显示状态：$ firewall-cmd <span class=\"comment\">--state</span></span><br><span class=\"line\">                查看区域信息: $ firewall-cmd <span class=\"comment\">--get-active-zones</span></span><br><span class=\"line\">                查看指定接口所属区域：$ firewall-cmd <span class=\"comment\">--get-zone-of-interface=eth0</span></span><br><span class=\"line\">拒绝所有包：# firewall-cmd <span class=\"comment\">--panic-on</span></span><br><span class=\"line\">取消拒绝状态：# firewall-cmd <span class=\"comment\">--panic-off</span></span><br><span class=\"line\">查看是否拒绝：$ firewall-cmd <span class=\"comment\">--query-panic</span></span><br><span class=\"line\"> </span><br><span class=\"line\">更新防火墙规则：# firewall-cmd <span class=\"comment\">--reload</span></span><br><span class=\"line\">                            # firewall-cmd <span class=\"comment\">--complete-reload</span></span><br><span class=\"line\">    两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务</span><br><span class=\"line\"> </span><br><span class=\"line\">将接口添加到区域，默认接口都在<span class=\"built_in\">public</span></span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--zone=public --add-interface=eth0</span></span><br><span class=\"line\">永久生效再加上 <span class=\"comment\">--permanent 然后reload防火墙</span></span><br><span class=\"line\"> </span><br><span class=\"line\">设置默认接口区域</span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--set-default-zone=public</span></span><br><span class=\"line\">立即生效无需重启</span><br><span class=\"line\"> </span><br><span class=\"line\">打开端口（貌似这个才最常用）</span><br><span class=\"line\">查看所有打开的端口：</span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--zone=dmz --list-ports</span></span><br><span class=\"line\">加入一个端口到区域：</span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--zone=dmz --add-port=8080/tcp</span></span><br><span class=\"line\">若要永久生效方法同上</span><br><span class=\"line\"> </span><br><span class=\"line\">打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档</span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--zone=work --add-service=smtp</span></span><br><span class=\"line\"> </span><br><span class=\"line\">移除服务</span><br><span class=\"line\"># firewall-cmd <span class=\"comment\">--zone=work --remove-service=smtp</span></span><br><span class=\"line\"> </span><br><span class=\"line\">还有端口转发功能、自定义复杂规则功能、lockdown，由于还没用到，以后再学习</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"github笔记","abbrlink":1017553822,"date":"2021-12-23T05:00:00.000Z","_content":"\n> github 能干啥 ？它是一个工具，具体来说是版本管理工具。基于这个出发点去思考的话，github似乎也就是做一些版本管理的事儿。\n\n1. 前言\n> 首先，你得确保电脑上安装了github。安装方法有很多,github[官方网站](https://www.github.com)\n\n2. 常用命令\n~~~ bash\n# 初始化\ngit init\n\n# 配置信息\ngit config --global user.email \"your@example.com\"\ngit config --global user.name \"your name\"\n\n# 查看当前的状态\ngit status\n\n# 添加所有文件\ngit add .\n\n# 添加指定文件\ngit add xxx.lua\n\n# 提交\ngit commit -m \"日志信息\"\n\n# 推送\ngit push\n\n# 拉取\ngit pull\n\n# 查看日志\ngit log \n\n# 查看日志ref\ngit reflog\n\n# 回滚\ngit reset --hard <[git log]后面的全贴上>\n\n# 回滚\ngit reset --hard <[git reflog]前面的全贴上>\n\n\n# 分支\n#1.切换分支\ngit checkout master\n\n#2.合并分支\ngit merge dev\n\n#3.删除分支\ngit branch -d bug\n\n#4.查看当前分支\ngit branch\n\n#5.创建分支\ngit branch bug\n\n# github克隆/推送\n\n#1.给远程仓库起别名\ngit remote add origin  远程仓库地址\n\n#2.推送\ngit push\ngit push -u origin 分支\n\n#3.克隆代码\ngit clone 远程仓库地址\n\n#4.切换分支\ngit checkout 分支\n\n#5.资源拉取\ngit pull\ngit pull origin 分支\n\ngit fetch origin dev\ngit merge origin/dev\n\ngit rebase -i 版本号\ngit rebase -i HEAD ~3\npick > s\n\ngit log --graph --pertty=format:\"%h %s\"\n\ngit pull origin dev\n\ngit fetch origin dev\ngit rebase origin/dev\n\n# 变基\ngit rebase 分支\n\n# 解决完冲突之后\ngit rebase --continue\n\n# Beyond Compare\n# 1.安装Beyond Compare3\n\n# 2.配置信息\ngit config --local merge.tool bc3\ngit config --local mergetool.path '/usr/local/bin/bcomp'\ngit config --local mergetool.keepBackup false\n\n# 3.应用bc3解决冲突\ngit mergetool\n\n# tag\ngit tag -a v2 -m \"tag信息\"\ngit push origin --tags\n\n#维护\ngit clone -b v2 地址\n\n#配置\n1.本项目生效 /项目/.git/config\ngit config --local user.name\ngit config --local user.emal\n\n2.全局 ~/.gitconfig\ngit config --global user.name\ngit config --global user.emal\n\n3.系统 /etc/.gitconfig (sudo权限)\ngit config --system user.name\ngit config --system user.emal\n\n# 免密登录\n# 1.URL\n# 原始地址 https://github.com/yourname/project.git\n# 修改地址 https://用户名:密码@github.coim/yourname/project.git\n\ngit remote add origin https://用户名:密码@github.coim/yourname/project.git\ngit push origin master\n\n# 2.SSH实现\n# 1.生成公钥和私钥(~/.ssh/id_rsa.pub 目录下 id_rsa.pub 公钥 id_ras私钥)\nssh-keygen -r rsa\n\n# 2.拷贝公钥内容，并设置到github SSH and GPG keys\n\n# 3.在git 本地配置ssh地址\ngit remote add origin git@github.com:yourname/project.git\n\ngit push origin master\n\n# 4.git自动管理凭证\nMac OS X >> 钥匙串\n\n# git忽略文件\n# 在项目根目录下创建 .gitignore\n```\n*.h\nxx.h\naa.lua\n!a.h\nfiles/\n*.py[c|a|d]\n.gitignore\n```\n~~~\n参考gitignore[官方网站](https://github.coim/gitub/gitignore)\n\n3. 生成静态网页\n> 首先得确保已经安装了最新的node.js.\n参考hexo[官方网站](https://hexo.io)\n~~~\n# 检查node.js版本\nnode -v\n\n# 检查npm版本\nnpm -v\n\n# 安装hexo\nnpm install -g hexo-cli\n\n# 新建一个project\nhexo init project\n\n# 进入目录\ncd project\n\n# 初始化\nnpm install\n\n# 启动\nhexo server\n\n# 帮助\nhexo help\n~~~\n\n- 常用命令\n~~~ sh\n# 新建文章\nhexo new \"新建文章名字\"\n\n# 新建页面\nhexo new page \"新建页面名字\"\n\n# 生产静态页面至 public 目录\nhexo generate\n\n# 开启预览访问端口\nhexo server\n\n# 部署到github\nhexo deploy\n\n# 查看帮助\nhexo help\n\n# 查看hexo版本\nhexo version\n~~~\n\n- 命令缩写\n~~~ sh\nhexo n # hexo new\nhexo g # hexo generate\nhexo s # hexo server\nhexo d # hexo deploy\n~~~\n\n- 组合命令\n~~~ sh\nhexo s -g # 生成本地预览\nhexo d -g # 生成并上传到github\n~~~\n\n- 配置文件\n1) 在本地生成 ssh key\n2) 在github的设置里新增 ssh key\n3) 在 _config.yml 文件中新增\n~~~ yml\ndeploy:\n  type: git\n  repository: git@github.com:yourname/yourname.github.io.git\n  branch: master\n~~~\n\n\n[Hexo从0到1搭建技术博客](https://edu.csdn.net/course/detail/35315)\n\n1) 安装hexo-abbrlink插件\n~~~sh\n\tnpm install hexo-abbrlink --save\n~~~\n2) 在 _config.yml 文件中新增\n~~~ yml\n# permalink: :year/:month/:day/:title/\npermalink: posts/:abbrlink.html\nabbrlink:\n  alg: crc32\n  rep: dec\n~~~\n\n4. 任务管理\n\n- issues\n  文档以及任务管理\n\n- wiki\n  在线文档\n","source":"_posts/github_blog.md","raw":"---\ntitle: github笔记\ntags:\n  - git\nabbrlink: 1017553822\ndate: 2021-12-23 13:00:00\n---\n\n> github 能干啥 ？它是一个工具，具体来说是版本管理工具。基于这个出发点去思考的话，github似乎也就是做一些版本管理的事儿。\n\n1. 前言\n> 首先，你得确保电脑上安装了github。安装方法有很多,github[官方网站](https://www.github.com)\n\n2. 常用命令\n~~~ bash\n# 初始化\ngit init\n\n# 配置信息\ngit config --global user.email \"your@example.com\"\ngit config --global user.name \"your name\"\n\n# 查看当前的状态\ngit status\n\n# 添加所有文件\ngit add .\n\n# 添加指定文件\ngit add xxx.lua\n\n# 提交\ngit commit -m \"日志信息\"\n\n# 推送\ngit push\n\n# 拉取\ngit pull\n\n# 查看日志\ngit log \n\n# 查看日志ref\ngit reflog\n\n# 回滚\ngit reset --hard <[git log]后面的全贴上>\n\n# 回滚\ngit reset --hard <[git reflog]前面的全贴上>\n\n\n# 分支\n#1.切换分支\ngit checkout master\n\n#2.合并分支\ngit merge dev\n\n#3.删除分支\ngit branch -d bug\n\n#4.查看当前分支\ngit branch\n\n#5.创建分支\ngit branch bug\n\n# github克隆/推送\n\n#1.给远程仓库起别名\ngit remote add origin  远程仓库地址\n\n#2.推送\ngit push\ngit push -u origin 分支\n\n#3.克隆代码\ngit clone 远程仓库地址\n\n#4.切换分支\ngit checkout 分支\n\n#5.资源拉取\ngit pull\ngit pull origin 分支\n\ngit fetch origin dev\ngit merge origin/dev\n\ngit rebase -i 版本号\ngit rebase -i HEAD ~3\npick > s\n\ngit log --graph --pertty=format:\"%h %s\"\n\ngit pull origin dev\n\ngit fetch origin dev\ngit rebase origin/dev\n\n# 变基\ngit rebase 分支\n\n# 解决完冲突之后\ngit rebase --continue\n\n# Beyond Compare\n# 1.安装Beyond Compare3\n\n# 2.配置信息\ngit config --local merge.tool bc3\ngit config --local mergetool.path '/usr/local/bin/bcomp'\ngit config --local mergetool.keepBackup false\n\n# 3.应用bc3解决冲突\ngit mergetool\n\n# tag\ngit tag -a v2 -m \"tag信息\"\ngit push origin --tags\n\n#维护\ngit clone -b v2 地址\n\n#配置\n1.本项目生效 /项目/.git/config\ngit config --local user.name\ngit config --local user.emal\n\n2.全局 ~/.gitconfig\ngit config --global user.name\ngit config --global user.emal\n\n3.系统 /etc/.gitconfig (sudo权限)\ngit config --system user.name\ngit config --system user.emal\n\n# 免密登录\n# 1.URL\n# 原始地址 https://github.com/yourname/project.git\n# 修改地址 https://用户名:密码@github.coim/yourname/project.git\n\ngit remote add origin https://用户名:密码@github.coim/yourname/project.git\ngit push origin master\n\n# 2.SSH实现\n# 1.生成公钥和私钥(~/.ssh/id_rsa.pub 目录下 id_rsa.pub 公钥 id_ras私钥)\nssh-keygen -r rsa\n\n# 2.拷贝公钥内容，并设置到github SSH and GPG keys\n\n# 3.在git 本地配置ssh地址\ngit remote add origin git@github.com:yourname/project.git\n\ngit push origin master\n\n# 4.git自动管理凭证\nMac OS X >> 钥匙串\n\n# git忽略文件\n# 在项目根目录下创建 .gitignore\n```\n*.h\nxx.h\naa.lua\n!a.h\nfiles/\n*.py[c|a|d]\n.gitignore\n```\n~~~\n参考gitignore[官方网站](https://github.coim/gitub/gitignore)\n\n3. 生成静态网页\n> 首先得确保已经安装了最新的node.js.\n参考hexo[官方网站](https://hexo.io)\n~~~\n# 检查node.js版本\nnode -v\n\n# 检查npm版本\nnpm -v\n\n# 安装hexo\nnpm install -g hexo-cli\n\n# 新建一个project\nhexo init project\n\n# 进入目录\ncd project\n\n# 初始化\nnpm install\n\n# 启动\nhexo server\n\n# 帮助\nhexo help\n~~~\n\n- 常用命令\n~~~ sh\n# 新建文章\nhexo new \"新建文章名字\"\n\n# 新建页面\nhexo new page \"新建页面名字\"\n\n# 生产静态页面至 public 目录\nhexo generate\n\n# 开启预览访问端口\nhexo server\n\n# 部署到github\nhexo deploy\n\n# 查看帮助\nhexo help\n\n# 查看hexo版本\nhexo version\n~~~\n\n- 命令缩写\n~~~ sh\nhexo n # hexo new\nhexo g # hexo generate\nhexo s # hexo server\nhexo d # hexo deploy\n~~~\n\n- 组合命令\n~~~ sh\nhexo s -g # 生成本地预览\nhexo d -g # 生成并上传到github\n~~~\n\n- 配置文件\n1) 在本地生成 ssh key\n2) 在github的设置里新增 ssh key\n3) 在 _config.yml 文件中新增\n~~~ yml\ndeploy:\n  type: git\n  repository: git@github.com:yourname/yourname.github.io.git\n  branch: master\n~~~\n\n\n[Hexo从0到1搭建技术博客](https://edu.csdn.net/course/detail/35315)\n\n1) 安装hexo-abbrlink插件\n~~~sh\n\tnpm install hexo-abbrlink --save\n~~~\n2) 在 _config.yml 文件中新增\n~~~ yml\n# permalink: :year/:month/:day/:title/\npermalink: posts/:abbrlink.html\nabbrlink:\n  alg: crc32\n  rep: dec\n~~~\n\n4. 任务管理\n\n- issues\n  文档以及任务管理\n\n- wiki\n  在线文档\n","slug":"github_blog","published":1,"updated":"2021-12-23T06:03:51.961Z","_id":"ckxijpqsq000id3mr32gaa9oo","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>github 能干啥 ？它是一个工具，具体来说是版本管理工具。基于这个出发点去思考的话，github似乎也就是做一些版本管理的事儿。</p>\n</blockquote>\n<ol>\n<li><p>前言</p>\n<blockquote>\n<p>首先，你得确保电脑上安装了github。安装方法有很多,github<a href=\"https://www.github.com/\">官方网站</a></p>\n</blockquote>\n</li>\n<li><p>常用命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化</span></span><br><span class=\"line\">git init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置信息</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;your@example.com&quot;</span></span><br><span class=\"line\">git config --global user.name <span class=\"string\">&quot;your name&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前的状态</span></span><br><span class=\"line\">git status</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加所有文件</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加指定文件</span></span><br><span class=\"line\">git add xxx.lua</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交</span></span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;日志信息&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推送</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取</span></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看日志</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看日志ref</span></span><br><span class=\"line\">git reflog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回滚</span></span><br><span class=\"line\">git reset --hard &lt;[git <span class=\"built_in\">log</span>]后面的全贴上&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回滚</span></span><br><span class=\"line\">git reset --hard &lt;[git reflog]前面的全贴上&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分支</span></span><br><span class=\"line\"><span class=\"comment\">#1.切换分支</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2.合并分支</span></span><br><span class=\"line\">git merge dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3.删除分支</span></span><br><span class=\"line\">git branch -d bug</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#4.查看当前分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#5.创建分支</span></span><br><span class=\"line\">git branch bug</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># github克隆/推送</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#1.给远程仓库起别名</span></span><br><span class=\"line\">git remote add origin  远程仓库地址</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2.推送</span></span><br><span class=\"line\">git push</span><br><span class=\"line\">git push -u origin 分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3.克隆代码</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> 远程仓库地址</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#4.切换分支</span></span><br><span class=\"line\">git checkout 分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#5.资源拉取</span></span><br><span class=\"line\">git pull</span><br><span class=\"line\">git pull origin 分支</span><br><span class=\"line\"></span><br><span class=\"line\">git fetch origin dev</span><br><span class=\"line\">git merge origin/dev</span><br><span class=\"line\"></span><br><span class=\"line\">git rebase -i 版本号</span><br><span class=\"line\">git rebase -i HEAD ~3</span><br><span class=\"line\">pick &gt; s</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --graph --pertty=format:<span class=\"string\">&quot;%h %s&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">git pull origin dev</span><br><span class=\"line\"></span><br><span class=\"line\">git fetch origin dev</span><br><span class=\"line\">git rebase origin/dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 变基</span></span><br><span class=\"line\">git rebase 分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解决完冲突之后</span></span><br><span class=\"line\">git rebase --<span class=\"built_in\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Beyond Compare</span></span><br><span class=\"line\"><span class=\"comment\"># 1.安装Beyond Compare3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.配置信息</span></span><br><span class=\"line\">git config --<span class=\"built_in\">local</span> merge.tool bc3</span><br><span class=\"line\">git config --<span class=\"built_in\">local</span> mergetool.path <span class=\"string\">&#x27;/usr/local/bin/bcomp&#x27;</span></span><br><span class=\"line\">git config --<span class=\"built_in\">local</span> mergetool.keepBackup <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.应用bc3解决冲突</span></span><br><span class=\"line\">git mergetool</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># tag</span></span><br><span class=\"line\">git tag -a v2 -m <span class=\"string\">&quot;tag信息&quot;</span></span><br><span class=\"line\">git push origin --tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#维护</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> -b v2 地址</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#配置</span></span><br><span class=\"line\">1.本项目生效 /项目/.git/config</span><br><span class=\"line\">git config --<span class=\"built_in\">local</span> user.name</span><br><span class=\"line\">git config --<span class=\"built_in\">local</span> user.emal</span><br><span class=\"line\"></span><br><span class=\"line\">2.全局 ~/.gitconfig</span><br><span class=\"line\">git config --global user.name</span><br><span class=\"line\">git config --global user.emal</span><br><span class=\"line\"></span><br><span class=\"line\">3.系统 /etc/.gitconfig (sudo权限)</span><br><span class=\"line\">git config --system user.name</span><br><span class=\"line\">git config --system user.emal</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 免密登录</span></span><br><span class=\"line\"><span class=\"comment\"># 1.URL</span></span><br><span class=\"line\"><span class=\"comment\"># 原始地址 https://github.com/yourname/project.git</span></span><br><span class=\"line\"><span class=\"comment\"># 修改地址 https://用户名:密码@github.coim/yourname/project.git</span></span><br><span class=\"line\"></span><br><span class=\"line\">git remote add origin https://用户名:密码@github.coim/yourname/project.git</span><br><span class=\"line\">git push origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.SSH实现</span></span><br><span class=\"line\"><span class=\"comment\"># 1.生成公钥和私钥(~/.ssh/id_rsa.pub 目录下 id_rsa.pub 公钥 id_ras私钥)</span></span><br><span class=\"line\">ssh-keygen -r rsa</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.拷贝公钥内容，并设置到github SSH and GPG keys</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.在git 本地配置ssh地址</span></span><br><span class=\"line\">git remote add origin git@github.com:yourname/project.git</span><br><span class=\"line\"></span><br><span class=\"line\">git push origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.git自动管理凭证</span></span><br><span class=\"line\">Mac OS X &gt;&gt; 钥匙串</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># git忽略文件</span></span><br><span class=\"line\"><span class=\"comment\"># 在项目根目录下创建 .gitignore</span></span><br><span class=\"line\">```</span><br><span class=\"line\">*.h</span><br><span class=\"line\">xx.h</span><br><span class=\"line\">aa.lua</span><br><span class=\"line\">!a.h</span><br><span class=\"line\">files/</span><br><span class=\"line\">*.py[c|a|d]</span><br><span class=\"line\">.gitignore</span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n<p>参考gitignore<a href=\"https://github.coim/gitub/gitignore\">官方网站</a></p>\n</li>\n<li><p>生成静态网页</p>\n<blockquote>\n<p>首先得确保已经安装了最新的node.js.<br>参考hexo<a href=\"https://hexo.io/\">官方网站</a></p>\n</blockquote>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># 检查node.js版本</span></span><br><span class=\"line\">node -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 检查npm版本</span></span><br><span class=\"line\">npm -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 安装hexo</span></span><br><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 新建一个project</span></span><br><span class=\"line\">hexo init project</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 进入目录</span></span><br><span class=\"line\">cd project</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 初始化</span></span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 启动</span></span><br><span class=\"line\">hexo server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 帮助</span></span><br><span class=\"line\">hexo help</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li><p>常用命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建文章</span></span><br><span class=\"line\">hexo new <span class=\"string\">&quot;新建文章名字&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建页面</span></span><br><span class=\"line\">hexo new page <span class=\"string\">&quot;新建页面名字&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生产静态页面至 public 目录</span></span><br><span class=\"line\">hexo generate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启预览访问端口</span></span><br><span class=\"line\">hexo server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 部署到github</span></span><br><span class=\"line\">hexo deploy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo <span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看hexo版本</span></span><br><span class=\"line\">hexo version</span><br></pre></td></tr></table></figure></li>\n<li><p>命令缩写</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n <span class=\"comment\"># hexo new</span></span><br><span class=\"line\">hexo g <span class=\"comment\"># hexo generate</span></span><br><span class=\"line\">hexo s <span class=\"comment\"># hexo server</span></span><br><span class=\"line\">hexo d <span class=\"comment\"># hexo deploy</span></span><br></pre></td></tr></table></figure></li>\n<li><p>组合命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s -g <span class=\"comment\"># 生成本地预览</span></span><br><span class=\"line\">hexo d -g <span class=\"comment\"># 生成并上传到github</span></span><br></pre></td></tr></table></figure></li>\n<li><p>配置文件</p>\n</li>\n</ul>\n<ol>\n<li>在本地生成 ssh key</li>\n<li>在github的设置里新增 ssh key</li>\n<li>在 _config.yml 文件中新增<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repository:</span> <span class=\"string\">git@github.com:yourname/yourname.github.io.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><a href=\"https://edu.csdn.net/course/detail/35315\">Hexo从0到1搭建技术博客</a></p>\n<ol>\n<li>安装hexo-abbrlink插件<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></li>\n<li>在 _config.yml 文件中新增<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># permalink: :year/:month/:day/:title/</span></span><br><span class=\"line\"><span class=\"attr\">permalink:</span> <span class=\"string\">posts/:abbrlink.html</span></span><br><span class=\"line\"><span class=\"attr\">abbrlink:</span></span><br><span class=\"line\">  <span class=\"attr\">alg:</span> <span class=\"string\">crc32</span></span><br><span class=\"line\">  <span class=\"attr\">rep:</span> <span class=\"string\">dec</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<ol start=\"4\">\n<li>任务管理</li>\n</ol>\n<ul>\n<li><p>issues<br>文档以及任务管理</p>\n</li>\n<li><p>wiki<br>在线文档</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>github 能干啥 ？它是一个工具，具体来说是版本管理工具。基于这个出发点去思考的话，github似乎也就是做一些版本管理的事儿。</p>\n</blockquote>\n<ol>\n<li><p>前言</p>\n<blockquote>\n<p>首先，你得确保电脑上安装了github。安装方法有很多,github<a href=\"https://www.github.com/\">官方网站</a></p>\n</blockquote>\n</li>\n<li><p>常用命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化</span></span><br><span class=\"line\">git init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置信息</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;your@example.com&quot;</span></span><br><span class=\"line\">git config --global user.name <span class=\"string\">&quot;your name&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前的状态</span></span><br><span class=\"line\">git status</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加所有文件</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加指定文件</span></span><br><span class=\"line\">git add xxx.lua</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交</span></span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;日志信息&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推送</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取</span></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看日志</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看日志ref</span></span><br><span class=\"line\">git reflog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回滚</span></span><br><span class=\"line\">git reset --hard &lt;[git <span class=\"built_in\">log</span>]后面的全贴上&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回滚</span></span><br><span class=\"line\">git reset --hard &lt;[git reflog]前面的全贴上&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分支</span></span><br><span class=\"line\"><span class=\"comment\">#1.切换分支</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2.合并分支</span></span><br><span class=\"line\">git merge dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3.删除分支</span></span><br><span class=\"line\">git branch -d bug</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#4.查看当前分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#5.创建分支</span></span><br><span class=\"line\">git branch bug</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># github克隆/推送</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#1.给远程仓库起别名</span></span><br><span class=\"line\">git remote add origin  远程仓库地址</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2.推送</span></span><br><span class=\"line\">git push</span><br><span class=\"line\">git push -u origin 分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3.克隆代码</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> 远程仓库地址</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#4.切换分支</span></span><br><span class=\"line\">git checkout 分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#5.资源拉取</span></span><br><span class=\"line\">git pull</span><br><span class=\"line\">git pull origin 分支</span><br><span class=\"line\"></span><br><span class=\"line\">git fetch origin dev</span><br><span class=\"line\">git merge origin/dev</span><br><span class=\"line\"></span><br><span class=\"line\">git rebase -i 版本号</span><br><span class=\"line\">git rebase -i HEAD ~3</span><br><span class=\"line\">pick &gt; s</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --graph --pertty=format:<span class=\"string\">&quot;%h %s&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">git pull origin dev</span><br><span class=\"line\"></span><br><span class=\"line\">git fetch origin dev</span><br><span class=\"line\">git rebase origin/dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 变基</span></span><br><span class=\"line\">git rebase 分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解决完冲突之后</span></span><br><span class=\"line\">git rebase --<span class=\"built_in\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Beyond Compare</span></span><br><span class=\"line\"><span class=\"comment\"># 1.安装Beyond Compare3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.配置信息</span></span><br><span class=\"line\">git config --<span class=\"built_in\">local</span> merge.tool bc3</span><br><span class=\"line\">git config --<span class=\"built_in\">local</span> mergetool.path <span class=\"string\">&#x27;/usr/local/bin/bcomp&#x27;</span></span><br><span class=\"line\">git config --<span class=\"built_in\">local</span> mergetool.keepBackup <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.应用bc3解决冲突</span></span><br><span class=\"line\">git mergetool</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># tag</span></span><br><span class=\"line\">git tag -a v2 -m <span class=\"string\">&quot;tag信息&quot;</span></span><br><span class=\"line\">git push origin --tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#维护</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> -b v2 地址</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#配置</span></span><br><span class=\"line\">1.本项目生效 /项目/.git/config</span><br><span class=\"line\">git config --<span class=\"built_in\">local</span> user.name</span><br><span class=\"line\">git config --<span class=\"built_in\">local</span> user.emal</span><br><span class=\"line\"></span><br><span class=\"line\">2.全局 ~/.gitconfig</span><br><span class=\"line\">git config --global user.name</span><br><span class=\"line\">git config --global user.emal</span><br><span class=\"line\"></span><br><span class=\"line\">3.系统 /etc/.gitconfig (sudo权限)</span><br><span class=\"line\">git config --system user.name</span><br><span class=\"line\">git config --system user.emal</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 免密登录</span></span><br><span class=\"line\"><span class=\"comment\"># 1.URL</span></span><br><span class=\"line\"><span class=\"comment\"># 原始地址 https://github.com/yourname/project.git</span></span><br><span class=\"line\"><span class=\"comment\"># 修改地址 https://用户名:密码@github.coim/yourname/project.git</span></span><br><span class=\"line\"></span><br><span class=\"line\">git remote add origin https://用户名:密码@github.coim/yourname/project.git</span><br><span class=\"line\">git push origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.SSH实现</span></span><br><span class=\"line\"><span class=\"comment\"># 1.生成公钥和私钥(~/.ssh/id_rsa.pub 目录下 id_rsa.pub 公钥 id_ras私钥)</span></span><br><span class=\"line\">ssh-keygen -r rsa</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.拷贝公钥内容，并设置到github SSH and GPG keys</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.在git 本地配置ssh地址</span></span><br><span class=\"line\">git remote add origin git@github.com:yourname/project.git</span><br><span class=\"line\"></span><br><span class=\"line\">git push origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.git自动管理凭证</span></span><br><span class=\"line\">Mac OS X &gt;&gt; 钥匙串</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># git忽略文件</span></span><br><span class=\"line\"><span class=\"comment\"># 在项目根目录下创建 .gitignore</span></span><br><span class=\"line\">```</span><br><span class=\"line\">*.h</span><br><span class=\"line\">xx.h</span><br><span class=\"line\">aa.lua</span><br><span class=\"line\">!a.h</span><br><span class=\"line\">files/</span><br><span class=\"line\">*.py[c|a|d]</span><br><span class=\"line\">.gitignore</span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n<p>参考gitignore<a href=\"https://github.coim/gitub/gitignore\">官方网站</a></p>\n</li>\n<li><p>生成静态网页</p>\n<blockquote>\n<p>首先得确保已经安装了最新的node.js.<br>参考hexo<a href=\"https://hexo.io/\">官方网站</a></p>\n</blockquote>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># 检查node.js版本</span></span><br><span class=\"line\">node -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 检查npm版本</span></span><br><span class=\"line\">npm -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 安装hexo</span></span><br><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 新建一个project</span></span><br><span class=\"line\">hexo init project</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 进入目录</span></span><br><span class=\"line\">cd project</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 初始化</span></span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 启动</span></span><br><span class=\"line\">hexo server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 帮助</span></span><br><span class=\"line\">hexo help</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li><p>常用命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建文章</span></span><br><span class=\"line\">hexo new <span class=\"string\">&quot;新建文章名字&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建页面</span></span><br><span class=\"line\">hexo new page <span class=\"string\">&quot;新建页面名字&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生产静态页面至 public 目录</span></span><br><span class=\"line\">hexo generate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启预览访问端口</span></span><br><span class=\"line\">hexo server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 部署到github</span></span><br><span class=\"line\">hexo deploy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo <span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看hexo版本</span></span><br><span class=\"line\">hexo version</span><br></pre></td></tr></table></figure></li>\n<li><p>命令缩写</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n <span class=\"comment\"># hexo new</span></span><br><span class=\"line\">hexo g <span class=\"comment\"># hexo generate</span></span><br><span class=\"line\">hexo s <span class=\"comment\"># hexo server</span></span><br><span class=\"line\">hexo d <span class=\"comment\"># hexo deploy</span></span><br></pre></td></tr></table></figure></li>\n<li><p>组合命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s -g <span class=\"comment\"># 生成本地预览</span></span><br><span class=\"line\">hexo d -g <span class=\"comment\"># 生成并上传到github</span></span><br></pre></td></tr></table></figure></li>\n<li><p>配置文件</p>\n</li>\n</ul>\n<ol>\n<li>在本地生成 ssh key</li>\n<li>在github的设置里新增 ssh key</li>\n<li>在 _config.yml 文件中新增<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repository:</span> <span class=\"string\">git@github.com:yourname/yourname.github.io.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><a href=\"https://edu.csdn.net/course/detail/35315\">Hexo从0到1搭建技术博客</a></p>\n<ol>\n<li>安装hexo-abbrlink插件<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></li>\n<li>在 _config.yml 文件中新增<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># permalink: :year/:month/:day/:title/</span></span><br><span class=\"line\"><span class=\"attr\">permalink:</span> <span class=\"string\">posts/:abbrlink.html</span></span><br><span class=\"line\"><span class=\"attr\">abbrlink:</span></span><br><span class=\"line\">  <span class=\"attr\">alg:</span> <span class=\"string\">crc32</span></span><br><span class=\"line\">  <span class=\"attr\">rep:</span> <span class=\"string\">dec</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<ol start=\"4\">\n<li>任务管理</li>\n</ol>\n<ul>\n<li><p>issues<br>文档以及任务管理</p>\n</li>\n<li><p>wiki<br>在线文档</p>\n</li>\n</ul>\n"},{"title":"qlc解决了什么问题","abbrlink":3048909287,"date":"2019-02-16T11:17:31.000Z","_content":"\n### 目前遇到的问题\n\n作为一名前端工程师，陆陆续续负责了不少项目，这些项目中，有一些是正在迭代的，其他同事同时在负责的项目，但是也有不少项目，要么就是老旧项目维护的同事已经离职或转岗了的，要么就是新项目从 0 开始的，再加上前端代码积累速度和迭代速度都比较快，其中暴露了不少问题。\n\n我身边的大多数程序员都有一个特点，就是喜欢把具体的东西抽象化，我们通常会抽象出公共的函数或方法、公共的类或HOC，放在一起，集中在项目的某一个文件夹下，叫做 js 文件夹或 lib 文件夹（以下我们用 js 文件夹代表公共函数文件夹 ）。\n\n这样做的确带来了很多便利，但同时也有一些隐患：\n\n* js 文件夹下代码越来越多，而且大多数鹅厂小伙伴的作风是 0 文档 0 注释，这给新接手项目的同学熟悉项目带来了极大的麻烦。\n* 不同项目都有自己的 js 文件夹，在开发一个新项目时，我们通常的做法是：\n\t* 直接将原有项目的 js 文件夹拷贝到新项目中，这样在新项目中，我们也可以直接使用这些公共函数了。\n\t* 将原有项目的部分 js 文件拷贝到新项目中，并且随着新项目的开发，增量拷贝。\n\t* 以上两种做法，本质区别不大，前者会直接给新项目增加很多无用代码（原有项目中所谓的公共函数在新项目中并不一定会用到），而对这两种方式，如果我们要修复一个 bug，修改或升级公共代码中的一个文件，那么我们就要一个一个的，将修复好的文件拷贝到不同的项目中，如果项目多了并且已经交由不同的人维护了，这简直是一个灾难。\n* 由于公共 js 文件夹下内容比较多，并且有的开发同学习惯以 'urlUtils.js'、'strUtils.js' 这种方式来整合一些小的函数集，这样会造成函数重复的隐患（毕竟我们一个文件一行行的去分析目前的公共库已经有了哪些能力是不现实的），我观察过之前自己接手的一个不算复杂的项目（潘多拉），其仅仅是从 url 解析 query 这种功能函数，就有多达 3个(甚至更多)，分布在 js 文件夹以及 node_modules 里面，这显然是不同的维护人员由于信息不对称重复引入的。\n* 对于怎么样才能算作“公共”函数，目前是缺乏一个 review 过程的，任何项目开发人员，几乎都可以无限制地在公共 js 文件夹下增加内容，并在之后被携带着拷贝到其他项目中，这其中有些函数，也许并不适合在这里。\n\n### 问题归纳与解决\n\n实际上，总结下来，我们需要解决三个痛点：\n\n* 以低成本的方式增加高可读性的文档，方便新接手项目的同学熟悉。\n* 解决跨项目之间的公共函数复用和更新维护困难的问题。\n* 增加必要的 review 环节，对公共函数库的必要性和代码正确性进行 review。\n\n就第一个问题而言，其实现在的前端文档工具链已经极大降低了写文档的成本了，利用 [jsdoc](http://usejsdoc.org/) 或 [esdoc](https://esdoc.org/) 等文档生成工具，我们基本上已经不需要手动写文档，而是在写代码的同时写注释，就可以自动生成文档，并且配合相关的编辑器插件，一部分注释都可以自动生成。\n\n但是目前我经历的大多数项目还是没有文档，这里可能是由于以下四个原因：\n\n* 部分同学并不知道有 esdoc、jsdoc 这种比较好用的文档生成工具。\n* 开发组中没有人去推动，文档不属于 KPI 和考核的内容，加之时间紧迭代快，缺乏前人栽树的动力。\n* 虽然现在的文档生成工具比较简单了，但一般还是需要一定的配置，也有一点上手成本。\n* 生成的文档不能十分满足需求，例如 esdoc 默认只能生成 html 格式的文档，在编辑器里面没法直接看。\n\n针对第一个问题，qlc 做出了一些努力：\n\n* 0 配置，全自动化生成文档，甚至集成到了其他开发流程中，命令行也不用敲。\n* 基于 esdoc 以及开源插件二次开发，可以选择性生成 html 和 markdown 格式的文档，注重文档体验。\n* 基于 esdoc 注释写作成本更低，更能节省时间。\n\n>跟 jsdoc 相比，esdoc 使用方式比较简单，不需要严格使用标签，而且能够支持搜索，并且官方资料更为齐全。\n\n至此，使用 qlc 生成文档，已经非常简单了。\n\n第二、第三个问题实际上是公共函数库的维护问题，qlc 也设计了对应的流程，着力解决该问题：\n\n* 首先有一个远程公共库（基于 git）。\n* 对于某一个项目而言，可以从远程库中下拉所需要的公共函数/类，并自动生成文档。\n* 如果我们对某一个项目增加了一个公共函数并且认为可以为更多的项目所用，命令行上传到远程库自动触发 MR，维护人员 review 通过后即可供其他项目使用。\n* 修复或更新某一个公共函数之后，我们只需同步到远程库，其他项目维护人员在命令行工具的辅助下同步即可。\n\n### 更多\n\n到此，你是否认为 qlc 给你带来了一定的价值呢，可以到 qlc 的官方仓库查看更多的[文档细节](https://git.code.oa.com/qlc/qlc)\n\n\n\n\n\n","source":"_posts/qlc解决了什么问题.md","raw":"---\ntitle: qlc解决了什么问题\ntags:\n  - javascript\nabbrlink: 3048909287\ndate: 2019-02-16 19:17:31\n---\n\n### 目前遇到的问题\n\n作为一名前端工程师，陆陆续续负责了不少项目，这些项目中，有一些是正在迭代的，其他同事同时在负责的项目，但是也有不少项目，要么就是老旧项目维护的同事已经离职或转岗了的，要么就是新项目从 0 开始的，再加上前端代码积累速度和迭代速度都比较快，其中暴露了不少问题。\n\n我身边的大多数程序员都有一个特点，就是喜欢把具体的东西抽象化，我们通常会抽象出公共的函数或方法、公共的类或HOC，放在一起，集中在项目的某一个文件夹下，叫做 js 文件夹或 lib 文件夹（以下我们用 js 文件夹代表公共函数文件夹 ）。\n\n这样做的确带来了很多便利，但同时也有一些隐患：\n\n* js 文件夹下代码越来越多，而且大多数鹅厂小伙伴的作风是 0 文档 0 注释，这给新接手项目的同学熟悉项目带来了极大的麻烦。\n* 不同项目都有自己的 js 文件夹，在开发一个新项目时，我们通常的做法是：\n\t* 直接将原有项目的 js 文件夹拷贝到新项目中，这样在新项目中，我们也可以直接使用这些公共函数了。\n\t* 将原有项目的部分 js 文件拷贝到新项目中，并且随着新项目的开发，增量拷贝。\n\t* 以上两种做法，本质区别不大，前者会直接给新项目增加很多无用代码（原有项目中所谓的公共函数在新项目中并不一定会用到），而对这两种方式，如果我们要修复一个 bug，修改或升级公共代码中的一个文件，那么我们就要一个一个的，将修复好的文件拷贝到不同的项目中，如果项目多了并且已经交由不同的人维护了，这简直是一个灾难。\n* 由于公共 js 文件夹下内容比较多，并且有的开发同学习惯以 'urlUtils.js'、'strUtils.js' 这种方式来整合一些小的函数集，这样会造成函数重复的隐患（毕竟我们一个文件一行行的去分析目前的公共库已经有了哪些能力是不现实的），我观察过之前自己接手的一个不算复杂的项目（潘多拉），其仅仅是从 url 解析 query 这种功能函数，就有多达 3个(甚至更多)，分布在 js 文件夹以及 node_modules 里面，这显然是不同的维护人员由于信息不对称重复引入的。\n* 对于怎么样才能算作“公共”函数，目前是缺乏一个 review 过程的，任何项目开发人员，几乎都可以无限制地在公共 js 文件夹下增加内容，并在之后被携带着拷贝到其他项目中，这其中有些函数，也许并不适合在这里。\n\n### 问题归纳与解决\n\n实际上，总结下来，我们需要解决三个痛点：\n\n* 以低成本的方式增加高可读性的文档，方便新接手项目的同学熟悉。\n* 解决跨项目之间的公共函数复用和更新维护困难的问题。\n* 增加必要的 review 环节，对公共函数库的必要性和代码正确性进行 review。\n\n就第一个问题而言，其实现在的前端文档工具链已经极大降低了写文档的成本了，利用 [jsdoc](http://usejsdoc.org/) 或 [esdoc](https://esdoc.org/) 等文档生成工具，我们基本上已经不需要手动写文档，而是在写代码的同时写注释，就可以自动生成文档，并且配合相关的编辑器插件，一部分注释都可以自动生成。\n\n但是目前我经历的大多数项目还是没有文档，这里可能是由于以下四个原因：\n\n* 部分同学并不知道有 esdoc、jsdoc 这种比较好用的文档生成工具。\n* 开发组中没有人去推动，文档不属于 KPI 和考核的内容，加之时间紧迭代快，缺乏前人栽树的动力。\n* 虽然现在的文档生成工具比较简单了，但一般还是需要一定的配置，也有一点上手成本。\n* 生成的文档不能十分满足需求，例如 esdoc 默认只能生成 html 格式的文档，在编辑器里面没法直接看。\n\n针对第一个问题，qlc 做出了一些努力：\n\n* 0 配置，全自动化生成文档，甚至集成到了其他开发流程中，命令行也不用敲。\n* 基于 esdoc 以及开源插件二次开发，可以选择性生成 html 和 markdown 格式的文档，注重文档体验。\n* 基于 esdoc 注释写作成本更低，更能节省时间。\n\n>跟 jsdoc 相比，esdoc 使用方式比较简单，不需要严格使用标签，而且能够支持搜索，并且官方资料更为齐全。\n\n至此，使用 qlc 生成文档，已经非常简单了。\n\n第二、第三个问题实际上是公共函数库的维护问题，qlc 也设计了对应的流程，着力解决该问题：\n\n* 首先有一个远程公共库（基于 git）。\n* 对于某一个项目而言，可以从远程库中下拉所需要的公共函数/类，并自动生成文档。\n* 如果我们对某一个项目增加了一个公共函数并且认为可以为更多的项目所用，命令行上传到远程库自动触发 MR，维护人员 review 通过后即可供其他项目使用。\n* 修复或更新某一个公共函数之后，我们只需同步到远程库，其他项目维护人员在命令行工具的辅助下同步即可。\n\n### 更多\n\n到此，你是否认为 qlc 给你带来了一定的价值呢，可以到 qlc 的官方仓库查看更多的[文档细节](https://git.code.oa.com/qlc/qlc)\n\n\n\n\n\n","slug":"qlc解决了什么问题","published":1,"updated":"2021-12-23T05:50:07.541Z","_id":"ckxijpqsr000kd3mr0pjn8426","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"目前遇到的问题\"><a href=\"#目前遇到的问题\" class=\"headerlink\" title=\"目前遇到的问题\"></a>目前遇到的问题</h3><p>作为一名前端工程师，陆陆续续负责了不少项目，这些项目中，有一些是正在迭代的，其他同事同时在负责的项目，但是也有不少项目，要么就是老旧项目维护的同事已经离职或转岗了的，要么就是新项目从 0 开始的，再加上前端代码积累速度和迭代速度都比较快，其中暴露了不少问题。</p>\n<p>我身边的大多数程序员都有一个特点，就是喜欢把具体的东西抽象化，我们通常会抽象出公共的函数或方法、公共的类或HOC，放在一起，集中在项目的某一个文件夹下，叫做 js 文件夹或 lib 文件夹（以下我们用 js 文件夹代表公共函数文件夹 ）。</p>\n<p>这样做的确带来了很多便利，但同时也有一些隐患：</p>\n<ul>\n<li>js 文件夹下代码越来越多，而且大多数鹅厂小伙伴的作风是 0 文档 0 注释，这给新接手项目的同学熟悉项目带来了极大的麻烦。</li>\n<li>不同项目都有自己的 js 文件夹，在开发一个新项目时，我们通常的做法是：<ul>\n<li>直接将原有项目的 js 文件夹拷贝到新项目中，这样在新项目中，我们也可以直接使用这些公共函数了。</li>\n<li>将原有项目的部分 js 文件拷贝到新项目中，并且随着新项目的开发，增量拷贝。</li>\n<li>以上两种做法，本质区别不大，前者会直接给新项目增加很多无用代码（原有项目中所谓的公共函数在新项目中并不一定会用到），而对这两种方式，如果我们要修复一个 bug，修改或升级公共代码中的一个文件，那么我们就要一个一个的，将修复好的文件拷贝到不同的项目中，如果项目多了并且已经交由不同的人维护了，这简直是一个灾难。</li>\n</ul>\n</li>\n<li>由于公共 js 文件夹下内容比较多，并且有的开发同学习惯以 ‘urlUtils.js’、’strUtils.js’ 这种方式来整合一些小的函数集，这样会造成函数重复的隐患（毕竟我们一个文件一行行的去分析目前的公共库已经有了哪些能力是不现实的），我观察过之前自己接手的一个不算复杂的项目（潘多拉），其仅仅是从 url 解析 query 这种功能函数，就有多达 3个(甚至更多)，分布在 js 文件夹以及 node_modules 里面，这显然是不同的维护人员由于信息不对称重复引入的。</li>\n<li>对于怎么样才能算作“公共”函数，目前是缺乏一个 review 过程的，任何项目开发人员，几乎都可以无限制地在公共 js 文件夹下增加内容，并在之后被携带着拷贝到其他项目中，这其中有些函数，也许并不适合在这里。</li>\n</ul>\n<h3 id=\"问题归纳与解决\"><a href=\"#问题归纳与解决\" class=\"headerlink\" title=\"问题归纳与解决\"></a>问题归纳与解决</h3><p>实际上，总结下来，我们需要解决三个痛点：</p>\n<ul>\n<li>以低成本的方式增加高可读性的文档，方便新接手项目的同学熟悉。</li>\n<li>解决跨项目之间的公共函数复用和更新维护困难的问题。</li>\n<li>增加必要的 review 环节，对公共函数库的必要性和代码正确性进行 review。</li>\n</ul>\n<p>就第一个问题而言，其实现在的前端文档工具链已经极大降低了写文档的成本了，利用 <a href=\"http://usejsdoc.org/\">jsdoc</a> 或 <a href=\"https://esdoc.org/\">esdoc</a> 等文档生成工具，我们基本上已经不需要手动写文档，而是在写代码的同时写注释，就可以自动生成文档，并且配合相关的编辑器插件，一部分注释都可以自动生成。</p>\n<p>但是目前我经历的大多数项目还是没有文档，这里可能是由于以下四个原因：</p>\n<ul>\n<li>部分同学并不知道有 esdoc、jsdoc 这种比较好用的文档生成工具。</li>\n<li>开发组中没有人去推动，文档不属于 KPI 和考核的内容，加之时间紧迭代快，缺乏前人栽树的动力。</li>\n<li>虽然现在的文档生成工具比较简单了，但一般还是需要一定的配置，也有一点上手成本。</li>\n<li>生成的文档不能十分满足需求，例如 esdoc 默认只能生成 html 格式的文档，在编辑器里面没法直接看。</li>\n</ul>\n<p>针对第一个问题，qlc 做出了一些努力：</p>\n<ul>\n<li>0 配置，全自动化生成文档，甚至集成到了其他开发流程中，命令行也不用敲。</li>\n<li>基于 esdoc 以及开源插件二次开发，可以选择性生成 html 和 markdown 格式的文档，注重文档体验。</li>\n<li>基于 esdoc 注释写作成本更低，更能节省时间。</li>\n</ul>\n<blockquote>\n<p>跟 jsdoc 相比，esdoc 使用方式比较简单，不需要严格使用标签，而且能够支持搜索，并且官方资料更为齐全。</p>\n</blockquote>\n<p>至此，使用 qlc 生成文档，已经非常简单了。</p>\n<p>第二、第三个问题实际上是公共函数库的维护问题，qlc 也设计了对应的流程，着力解决该问题：</p>\n<ul>\n<li>首先有一个远程公共库（基于 git）。</li>\n<li>对于某一个项目而言，可以从远程库中下拉所需要的公共函数/类，并自动生成文档。</li>\n<li>如果我们对某一个项目增加了一个公共函数并且认为可以为更多的项目所用，命令行上传到远程库自动触发 MR，维护人员 review 通过后即可供其他项目使用。</li>\n<li>修复或更新某一个公共函数之后，我们只需同步到远程库，其他项目维护人员在命令行工具的辅助下同步即可。</li>\n</ul>\n<h3 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h3><p>到此，你是否认为 qlc 给你带来了一定的价值呢，可以到 qlc 的官方仓库查看更多的<a href=\"https://git.code.oa.com/qlc/qlc\">文档细节</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"目前遇到的问题\"><a href=\"#目前遇到的问题\" class=\"headerlink\" title=\"目前遇到的问题\"></a>目前遇到的问题</h3><p>作为一名前端工程师，陆陆续续负责了不少项目，这些项目中，有一些是正在迭代的，其他同事同时在负责的项目，但是也有不少项目，要么就是老旧项目维护的同事已经离职或转岗了的，要么就是新项目从 0 开始的，再加上前端代码积累速度和迭代速度都比较快，其中暴露了不少问题。</p>\n<p>我身边的大多数程序员都有一个特点，就是喜欢把具体的东西抽象化，我们通常会抽象出公共的函数或方法、公共的类或HOC，放在一起，集中在项目的某一个文件夹下，叫做 js 文件夹或 lib 文件夹（以下我们用 js 文件夹代表公共函数文件夹 ）。</p>\n<p>这样做的确带来了很多便利，但同时也有一些隐患：</p>\n<ul>\n<li>js 文件夹下代码越来越多，而且大多数鹅厂小伙伴的作风是 0 文档 0 注释，这给新接手项目的同学熟悉项目带来了极大的麻烦。</li>\n<li>不同项目都有自己的 js 文件夹，在开发一个新项目时，我们通常的做法是：<ul>\n<li>直接将原有项目的 js 文件夹拷贝到新项目中，这样在新项目中，我们也可以直接使用这些公共函数了。</li>\n<li>将原有项目的部分 js 文件拷贝到新项目中，并且随着新项目的开发，增量拷贝。</li>\n<li>以上两种做法，本质区别不大，前者会直接给新项目增加很多无用代码（原有项目中所谓的公共函数在新项目中并不一定会用到），而对这两种方式，如果我们要修复一个 bug，修改或升级公共代码中的一个文件，那么我们就要一个一个的，将修复好的文件拷贝到不同的项目中，如果项目多了并且已经交由不同的人维护了，这简直是一个灾难。</li>\n</ul>\n</li>\n<li>由于公共 js 文件夹下内容比较多，并且有的开发同学习惯以 ‘urlUtils.js’、’strUtils.js’ 这种方式来整合一些小的函数集，这样会造成函数重复的隐患（毕竟我们一个文件一行行的去分析目前的公共库已经有了哪些能力是不现实的），我观察过之前自己接手的一个不算复杂的项目（潘多拉），其仅仅是从 url 解析 query 这种功能函数，就有多达 3个(甚至更多)，分布在 js 文件夹以及 node_modules 里面，这显然是不同的维护人员由于信息不对称重复引入的。</li>\n<li>对于怎么样才能算作“公共”函数，目前是缺乏一个 review 过程的，任何项目开发人员，几乎都可以无限制地在公共 js 文件夹下增加内容，并在之后被携带着拷贝到其他项目中，这其中有些函数，也许并不适合在这里。</li>\n</ul>\n<h3 id=\"问题归纳与解决\"><a href=\"#问题归纳与解决\" class=\"headerlink\" title=\"问题归纳与解决\"></a>问题归纳与解决</h3><p>实际上，总结下来，我们需要解决三个痛点：</p>\n<ul>\n<li>以低成本的方式增加高可读性的文档，方便新接手项目的同学熟悉。</li>\n<li>解决跨项目之间的公共函数复用和更新维护困难的问题。</li>\n<li>增加必要的 review 环节，对公共函数库的必要性和代码正确性进行 review。</li>\n</ul>\n<p>就第一个问题而言，其实现在的前端文档工具链已经极大降低了写文档的成本了，利用 <a href=\"http://usejsdoc.org/\">jsdoc</a> 或 <a href=\"https://esdoc.org/\">esdoc</a> 等文档生成工具，我们基本上已经不需要手动写文档，而是在写代码的同时写注释，就可以自动生成文档，并且配合相关的编辑器插件，一部分注释都可以自动生成。</p>\n<p>但是目前我经历的大多数项目还是没有文档，这里可能是由于以下四个原因：</p>\n<ul>\n<li>部分同学并不知道有 esdoc、jsdoc 这种比较好用的文档生成工具。</li>\n<li>开发组中没有人去推动，文档不属于 KPI 和考核的内容，加之时间紧迭代快，缺乏前人栽树的动力。</li>\n<li>虽然现在的文档生成工具比较简单了，但一般还是需要一定的配置，也有一点上手成本。</li>\n<li>生成的文档不能十分满足需求，例如 esdoc 默认只能生成 html 格式的文档，在编辑器里面没法直接看。</li>\n</ul>\n<p>针对第一个问题，qlc 做出了一些努力：</p>\n<ul>\n<li>0 配置，全自动化生成文档，甚至集成到了其他开发流程中，命令行也不用敲。</li>\n<li>基于 esdoc 以及开源插件二次开发，可以选择性生成 html 和 markdown 格式的文档，注重文档体验。</li>\n<li>基于 esdoc 注释写作成本更低，更能节省时间。</li>\n</ul>\n<blockquote>\n<p>跟 jsdoc 相比，esdoc 使用方式比较简单，不需要严格使用标签，而且能够支持搜索，并且官方资料更为齐全。</p>\n</blockquote>\n<p>至此，使用 qlc 生成文档，已经非常简单了。</p>\n<p>第二、第三个问题实际上是公共函数库的维护问题，qlc 也设计了对应的流程，着力解决该问题：</p>\n<ul>\n<li>首先有一个远程公共库（基于 git）。</li>\n<li>对于某一个项目而言，可以从远程库中下拉所需要的公共函数/类，并自动生成文档。</li>\n<li>如果我们对某一个项目增加了一个公共函数并且认为可以为更多的项目所用，命令行上传到远程库自动触发 MR，维护人员 review 通过后即可供其他项目使用。</li>\n<li>修复或更新某一个公共函数之后，我们只需同步到远程库，其他项目维护人员在命令行工具的辅助下同步即可。</li>\n</ul>\n<h3 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h3><p>到此，你是否认为 qlc 给你带来了一定的价值呢，可以到 qlc 的官方仓库查看更多的<a href=\"https://git.code.oa.com/qlc/qlc\">文档细节</a></p>\n"},{"title":"web应用开发与部署——你必须掌握的内容","abbrlink":202056454,"date":"2019-06-16T14:09:20.000Z","_content":"\n\n\n本文基于笔者在腾讯的项目经验，从真实场景出发分析一个中型 Web 应用从立项到上线稳定运行的平稳解决方案，力求既不太空泛以至于看完了仍然找不到落地的点，也尽量不会特别纠结于个别细节导致没有相关使用经历的同学无法感同身受，而是从宏观到方法论，分析整个流程中我们需要用到的工具、方法与规范，给大家提供一个参考。\n\n本文适合具有一定经验的初中级前端开发者，如果有相关问题，也欢迎与我交流。\n\n目录\n\n* 项目构建的搭建，关键词：**webpack**、**react/vue cli**，**steamer**，**组件库**\n* 代码的规范约束，关键词：**typescript**、**eslint**、**prettier**\n* 测试与测试部署，关键词：**测试部署方案**、**docker**\n* 日志查看与脚本错误的监控，关键词：**sentry**、**vconsole**、**mlogger**\n* 版本发布更新，关键词：**发布系统**、**灰度发布**\n* 访问量实时监控\n\n### 起步：项目构建的搭建\n\n#### 使用 webpack 搭建脚手架\n\n目前在一般的项目中，我们都会使用 webpack 作为搭建开发环境的基础，而 react 和 vue 也各自提供了 cli 工具用于开发一个中小型项目，react 提供了 eject 功能让我们可以更加自由的配置 webpack，而 vue 脚手架虽然没有提供类似命令，但是借助 webpack 工具链我们几乎也可以自由定制每一个角落。\n\n不过，这里我的建议是，如果是个人项目或小型项目，我们可以基于 react 或 vue 的脚手架进行更改使用，对于一个具备一定规模的项目团队，建议还是自己维护一套单独的 webpack 构建环境，原因如下：\n\n* 由于我们一般需要在项目中接入各类司内工具、支持高级API和语法、同时支持 react/vue、构建目录定制化等各类工作，实际上 80% 以上的工作我们都需要在模版之上自行添加，这个时候我们再用脚手架带来的收益已经非常小了，反而还会受制于项目的初始目录结构。\n\n我们在自定义脚手架的 webpack 构建的时候，也需要梳理出一定的目录规范与约束，这样也有利于提高后期脚手架的可维护性和扩展性，一般来说，我们也要对脚手架中的公共部分和项目私有部分进行分离，对于一个具体项目而言，可以不用改动 webpack 的项目公共部分，这样也有利于减少不同项目之间的切换成本，对于我们目前的项目，一般会有如下两个目录：\n\n```\n- project\n\t- project.js\n- config\n\t- feature\n\t- plugins\n\t- rules\n\t- script.js\n\t- webpack.base.js \t\n```\n\n对于一个项目，只需更改 project 下的配置。\n\n这里我也推荐一个前同事做的[steamer研发体系](https://github.com/steamerjs)，在从中也可以找到很多相关参考，最简单的方式，就是直接在[steamer-simple](https://github.com/steamerjs/steamer-simple) 的基础上进行扩展。\n\n#### 定制生成目录\n\n生成目录的格式，这里需要单独讲一下。\n\n一般来说，我们生成目录的格式都是要跟发布系统进行结合的，不过也有的时候，我们做项目的时候还没有明确要接入发布系统，或者尚不知道发布系统的格式要求，但是一般情况下我们应当遵循下面的约定：\n\n* js/css/img 等资源文件和 html 文件分离，前者发布到 CDN，后者发布到 http 服务器。\n* html 中引入的文件地址，应当是在构建过程中更新的 CDN 地址，而不是相对路径地址。\n* 如果有离线包（offline 能力需要对应的客户端 webview 支持）等，需要单独一个目录。\n\n对于我们目前的项目而言，一般情况下会有三个生成目录：\n\n```\n- cdn\n- offline # 需要客户端支持该能力\n- webserver\n```\n\n如果一开始我们把所有内容生成到一个目录中了，这给我们后期的改动和维护，都带来很大的隐患。\n\n#### 组件库\n\n组件库这一部分，适合项目开始变得复杂的情况下进行启动，而不建议一开始进行过渡设计，建设组件库能够通过组件复用降低我们的开发成本，同时，组件库也需要专人维护，保持更新。\n\n### 开发：代码的规范约束\n\n对于 js 文件的代码格式，诸如要不要分号、两个还是四个字符缩进等，一只争议不断，本文也不对此进行讨论，但是对于一个团队的项目集合（而不是单个项目）而言，代码风格的统一，是一个非常有必要而且必须要做的事情。\n\n#### typescript\n\n关于 typescript 的相关文章实在太多了，这里也不对此进行详细的说明，其对代码的可读性、规范约束、降低报错风险等都有很好的改进，对于越复杂的项目其效果越明显。\n\n另外， [typescript 入门教程](https://ts.xcatliu.com/)的作者也在我们团队中，这里我想说，如果现在还没有开始使用 typescript，请开始学习并使用 typescript 吧。\n\n#### eslint 与 prettier\n\n除了 typescript 以外，在代码格式方面还建议使用 eslint 和 prettier 来进行代码格式的约束，这里虽然 eslint 和 prettier 两者在某些情景下会有些重叠，但是两者的侧重点不同，eslint 侧重于代码质量的检查并且给出提示，在某种层面上，可以看作是 typescript 的补充，而 prettier 在格式化代码方面更具有优势，并且 prettier 在设计之初就考虑了和 eslint 的集成，所以你可以完全放心的在项目中使用两者，而不用担心出现无法解决的冲突。\n\n另外，eslint 社区中已经形成了很多种最佳实践，而我们团队也设计出了自己的一套 eslint 规则，可以按需[取用](https://github.com/AlloyTeam/eslint-config-alloy)\n\np.s. 目前 tslint 后续计划不在维护，转向 eslint 增强，因此我们在项目中可以不再使用 tslint。\n\n以上这几种代码风格方面的约束，适合项目之初即开始约束，这样在中后期会有巨大的时间成本的节省和效率的提升。\n\n### 协作：使用 git\n\n使用 git 进行协作这里其实包括两个点，使用 git 管理项目与自建 gitlab，后者是一个比较基础性的工作，并且实际上难度并不大，我认为每一个公司都可以使用自建的 gitlab 进行版本管理，这个实际上难度并不大，并且可以有效的保护公司的代码财产，如果你所在的公司还没有，那么这也是你的机会。\n\n在具体的使用 git 中，对于git的分支/TAG管理、PR规范、提交文件约束等都应当有一套合理的流程，这里我对几点比较重要的进行说明：\n\n* 锁定主干与分支开发，我们在日常开发中禁止直接提交主干，而是只能在分支中进行开发，并且通过 MR 的方式提交到主干。\n* git hooks 检查：我们应该通过 git hooks 进行必要的检查，比如自动化测试、eslint 检查、以及一些项目中必要的检查。\n* MR 检查与 Code Review，这里建议在 Merge Request 的时候做两件事情，一件是 Code Review，不过这个在某些特殊情况下不具备条件，尤其是团队人力紧张的时候，另外一个则是 MR 的 HOOK 触发检查，这个一般需要借助一些持续集成工具来完成，可以说是我们代码在合并主干之前的最后一个关卡。\n\n### 测试：测试与测试部署\n\n测试是代码开发中重要的一个环节，但实际上对于前端开发来说，前端开发工程师一般较少书写测试用例，也并没有专业的测试开发工程师来辅助工作，不过，一般会有配备系统测试工程师在黑盒的情况下进行冒烟测试和功能测试以及整体链路的验收，俗称“点点点”。而这个时候，前端开发要做的就是把程序代码部署到测试服务器上，同时提供一个尽可能真实的场景供测试进行测试。\n\n在笔者经历的项目中，虽然也使用了单元测试、端对端测试，不过这一部分体系并不十分完备，并且可能也不是大多数前端开发者感兴趣的内容，所以这里主要总结如何进行高效的测试部署与发布对接。\n\n一般来说，我们一般会有一台到多台 Linux 测试机，供测试环境部署使用，对于前端项目而言，一般不需要特殊环境，可以进行 webpack 构建以及有 nginx 进行转发即可。\n\n而测试环境的部署，如果是让我们手动登录去部署，显然是不合理的，如果我们纯粹使用 CI 来完成这件事，则对 CI 工具的能力和项目人员素质有一定要求，并且不具备可视化管理能力，容易出错，这里我建议可以维护一个可视化系统来进行测试环境的部署和管理，其整个环节应该是这样的：\n\n```\n本地代码 -> gitlab -> 测试系统部署 -> 对接发布系统 \n```\n\n这里的测试系统，实际上是从 gitlab 拉取代码，并且本地执行 build 命令（一般是 `npm run build`）并把构建结果存储在 nginx 可代理的目录即可，出于系统完备性考虑，一般我们会有多台测试机，这里我建议一般拿其中的一台作为构建机，其他的测试机仅提供 nginx 代理能力即可，我们在一台构建机中进行构建，并且将构建结果通过系统命令发送到其他的测试机。\n\n一台构建机可以服务于所有的项目，这里还可能涉及到 webpack、nodejs 版本的维护，我们需要约束各个测试项目构建处在一个相对独立的环境中，我们也可以使用过 Docker 来进行构建，保证隔离。\n\n构建完成后，一般我们借助 Fiddler、Charles、Whistle 等任意一款代理工具，即可以进行测试。\n\n### 监控：日志查看与脚本错误的监控\n\n对于前端项目而言，即使我们已经使用了 typescript、eslint 并且也有了一些测试脚本和系统测试工程师进行的功能测试，我们还是免不了会出现 js 脚本错误，特别是 js 代码的运行环境和设备的多样化，很多错误我们并没有发现，但是产品、运营同学却出现了，或者到了线上在用户设备上出现了。\n\n所以，有两个事情我们必须要做：\n\n1. 日志查看功能（手机端）：现在我们写的大多数 TO C 页面都是在手机端进行，查看 console 非常不方便，我们需要一个线上实时查看 console 的工具。\n2. 我们需要脚本错误日志统计系统来进行错误统计管理与具体错误查看。\n\n对于第一个功能，进行细分，我们需要做这样几件事情：\n\n* 嵌入一个 console 和 网络请求查看器，并且只在特殊情况下才能触发（比如连续点击标题十次、或者使用特定交互手势）\n* 在触发查看器的时候，可以将日志完整地进行上传并分析。\n* 同时可以对该用户进行染色，会自动上传并记录该用户一定时间内后续刷新后操作的全部日志。\n\n不过这里并没有完全实现以上三点的开源库推荐，可以在 [vconsole](https://github.com/Tencent/vConsole) 或者 [mlogger](https://github.com/AlloyTeam/MLogger) 的基础上进行适当扩展，完成相关功能。\n\n对于第二个功能，我们需要一个完整的统计分析与管理的错误系统，这个如果自行开发的话，难度会比较大，这里强烈推荐 [sentry](https://sentry.io/welcome/)，可以非常方便的使用 Docker 部署到服务器端，并且拥有非常强大的日志错误分析与处理能力，通过结合 JavaScript 的 sourcemap ，可以给我们的错误定位带来极大的方便。\n\n总之，日志查看与脚本错误监控，是比较重要但是同时容易被忽视的地方，很多时候，我们的系统在线上使用了几个月了，真正有问题反馈了，我们才会考虑加上这些功能，但这个时候通常已经造成了损失。\n\n### 发布：版本发布更新\n\n发布系统，一般作为前端最后环节的系统，通常会和测试部署系统打通（或合二为一），一般的发布系统的必要功能如下：\n\n* 对于前端的发布，每次只发布有改变的文件，无变动的文件则无需发布。\n* 每次发布先发布 js/css/img 等资源文件，生效之后再发布 html 文件。\n* 发布系统保留线上旧版代码，出问题后可以快速一键回滚。\n\n至于一些其他的日志、报表等辅助性功能，则根据需要满足，这里不再赘述。\n\n#### 灰度发布\n\n灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1-5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量较大的页面。\n\n对于前端的灰度，实际上有以下几种方案：\n\n* 在代码层面进行灰度，即通过 if/else 进行判断，这样无需发布系统关注，也可以自由配置规则、比例与白名单/黑名单。\n* 在入口层面进行灰度，比如 App 内嵌的 H5 则在客户端的对应入口进行回复，这样通常也无需发布系统关注。\n* 通过发布系统，按照比例灰度，比如我们有 10 台 webserver，如果我们先发布 1 台，这样我们的灰度比例为 10%。\n\n### 访问量实时监控\n\n最后一点，我们还需要一个访问量实时监控系统，我们上述有了错误查看与脚本监控系统，但是对于我们的各个页面的访问量、点击率等指标，通常是产品/运营同学比较关心的，同时访问量的波动情况也是项目健康度的一个表征（访问量突然大幅上涨或下跌，一般都有其特定原因），所以我们需要访问量实时监控系统。\n\n而实际上访问量监控系统也有两种不同形态：\n\n* 对于每一个上报 key，只进行数量上的统计\n* 对于每一个上报 key，可以携带一些信息，对携带信息进行统计分析。\n\n通常情况下，前者的功能是实时或者低延时的，而后者由于需要一部分统计分析，通常可以接受非实时情况（一般每天出前一天的报表）。\n\n这部分内容，需要较强的后端接口稳定性，通常前端需要和对应岗位的同学共建。\n\n### 总结\n\n总结下来，我们一个稳定的前端项目，至少涉及到以下环节：\n\n* 完善的项目脚手架与代码约束规范\n* 内部 gitlab\n* 可视化管理的测试部署系统\n* 实时日志查看工具\n* 脚本错误统计管理系统\n* 发布管理系统\n* 访问量实时监控系统\n\n如果你所在的团队哪个环节还没有或者不完善，那么这也是你的机会。\n","source":"_posts/web应用开发与部署——你必须掌握的内容.md","raw":"---\ntitle: web应用开发与部署——你必须掌握的内容\ntags:\n  - 前端构建\nabbrlink: 202056454\ndate: 2019-06-16 22:09:20\n---\n\n\n\n本文基于笔者在腾讯的项目经验，从真实场景出发分析一个中型 Web 应用从立项到上线稳定运行的平稳解决方案，力求既不太空泛以至于看完了仍然找不到落地的点，也尽量不会特别纠结于个别细节导致没有相关使用经历的同学无法感同身受，而是从宏观到方法论，分析整个流程中我们需要用到的工具、方法与规范，给大家提供一个参考。\n\n本文适合具有一定经验的初中级前端开发者，如果有相关问题，也欢迎与我交流。\n\n目录\n\n* 项目构建的搭建，关键词：**webpack**、**react/vue cli**，**steamer**，**组件库**\n* 代码的规范约束，关键词：**typescript**、**eslint**、**prettier**\n* 测试与测试部署，关键词：**测试部署方案**、**docker**\n* 日志查看与脚本错误的监控，关键词：**sentry**、**vconsole**、**mlogger**\n* 版本发布更新，关键词：**发布系统**、**灰度发布**\n* 访问量实时监控\n\n### 起步：项目构建的搭建\n\n#### 使用 webpack 搭建脚手架\n\n目前在一般的项目中，我们都会使用 webpack 作为搭建开发环境的基础，而 react 和 vue 也各自提供了 cli 工具用于开发一个中小型项目，react 提供了 eject 功能让我们可以更加自由的配置 webpack，而 vue 脚手架虽然没有提供类似命令，但是借助 webpack 工具链我们几乎也可以自由定制每一个角落。\n\n不过，这里我的建议是，如果是个人项目或小型项目，我们可以基于 react 或 vue 的脚手架进行更改使用，对于一个具备一定规模的项目团队，建议还是自己维护一套单独的 webpack 构建环境，原因如下：\n\n* 由于我们一般需要在项目中接入各类司内工具、支持高级API和语法、同时支持 react/vue、构建目录定制化等各类工作，实际上 80% 以上的工作我们都需要在模版之上自行添加，这个时候我们再用脚手架带来的收益已经非常小了，反而还会受制于项目的初始目录结构。\n\n我们在自定义脚手架的 webpack 构建的时候，也需要梳理出一定的目录规范与约束，这样也有利于提高后期脚手架的可维护性和扩展性，一般来说，我们也要对脚手架中的公共部分和项目私有部分进行分离，对于一个具体项目而言，可以不用改动 webpack 的项目公共部分，这样也有利于减少不同项目之间的切换成本，对于我们目前的项目，一般会有如下两个目录：\n\n```\n- project\n\t- project.js\n- config\n\t- feature\n\t- plugins\n\t- rules\n\t- script.js\n\t- webpack.base.js \t\n```\n\n对于一个项目，只需更改 project 下的配置。\n\n这里我也推荐一个前同事做的[steamer研发体系](https://github.com/steamerjs)，在从中也可以找到很多相关参考，最简单的方式，就是直接在[steamer-simple](https://github.com/steamerjs/steamer-simple) 的基础上进行扩展。\n\n#### 定制生成目录\n\n生成目录的格式，这里需要单独讲一下。\n\n一般来说，我们生成目录的格式都是要跟发布系统进行结合的，不过也有的时候，我们做项目的时候还没有明确要接入发布系统，或者尚不知道发布系统的格式要求，但是一般情况下我们应当遵循下面的约定：\n\n* js/css/img 等资源文件和 html 文件分离，前者发布到 CDN，后者发布到 http 服务器。\n* html 中引入的文件地址，应当是在构建过程中更新的 CDN 地址，而不是相对路径地址。\n* 如果有离线包（offline 能力需要对应的客户端 webview 支持）等，需要单独一个目录。\n\n对于我们目前的项目而言，一般情况下会有三个生成目录：\n\n```\n- cdn\n- offline # 需要客户端支持该能力\n- webserver\n```\n\n如果一开始我们把所有内容生成到一个目录中了，这给我们后期的改动和维护，都带来很大的隐患。\n\n#### 组件库\n\n组件库这一部分，适合项目开始变得复杂的情况下进行启动，而不建议一开始进行过渡设计，建设组件库能够通过组件复用降低我们的开发成本，同时，组件库也需要专人维护，保持更新。\n\n### 开发：代码的规范约束\n\n对于 js 文件的代码格式，诸如要不要分号、两个还是四个字符缩进等，一只争议不断，本文也不对此进行讨论，但是对于一个团队的项目集合（而不是单个项目）而言，代码风格的统一，是一个非常有必要而且必须要做的事情。\n\n#### typescript\n\n关于 typescript 的相关文章实在太多了，这里也不对此进行详细的说明，其对代码的可读性、规范约束、降低报错风险等都有很好的改进，对于越复杂的项目其效果越明显。\n\n另外， [typescript 入门教程](https://ts.xcatliu.com/)的作者也在我们团队中，这里我想说，如果现在还没有开始使用 typescript，请开始学习并使用 typescript 吧。\n\n#### eslint 与 prettier\n\n除了 typescript 以外，在代码格式方面还建议使用 eslint 和 prettier 来进行代码格式的约束，这里虽然 eslint 和 prettier 两者在某些情景下会有些重叠，但是两者的侧重点不同，eslint 侧重于代码质量的检查并且给出提示，在某种层面上，可以看作是 typescript 的补充，而 prettier 在格式化代码方面更具有优势，并且 prettier 在设计之初就考虑了和 eslint 的集成，所以你可以完全放心的在项目中使用两者，而不用担心出现无法解决的冲突。\n\n另外，eslint 社区中已经形成了很多种最佳实践，而我们团队也设计出了自己的一套 eslint 规则，可以按需[取用](https://github.com/AlloyTeam/eslint-config-alloy)\n\np.s. 目前 tslint 后续计划不在维护，转向 eslint 增强，因此我们在项目中可以不再使用 tslint。\n\n以上这几种代码风格方面的约束，适合项目之初即开始约束，这样在中后期会有巨大的时间成本的节省和效率的提升。\n\n### 协作：使用 git\n\n使用 git 进行协作这里其实包括两个点，使用 git 管理项目与自建 gitlab，后者是一个比较基础性的工作，并且实际上难度并不大，我认为每一个公司都可以使用自建的 gitlab 进行版本管理，这个实际上难度并不大，并且可以有效的保护公司的代码财产，如果你所在的公司还没有，那么这也是你的机会。\n\n在具体的使用 git 中，对于git的分支/TAG管理、PR规范、提交文件约束等都应当有一套合理的流程，这里我对几点比较重要的进行说明：\n\n* 锁定主干与分支开发，我们在日常开发中禁止直接提交主干，而是只能在分支中进行开发，并且通过 MR 的方式提交到主干。\n* git hooks 检查：我们应该通过 git hooks 进行必要的检查，比如自动化测试、eslint 检查、以及一些项目中必要的检查。\n* MR 检查与 Code Review，这里建议在 Merge Request 的时候做两件事情，一件是 Code Review，不过这个在某些特殊情况下不具备条件，尤其是团队人力紧张的时候，另外一个则是 MR 的 HOOK 触发检查，这个一般需要借助一些持续集成工具来完成，可以说是我们代码在合并主干之前的最后一个关卡。\n\n### 测试：测试与测试部署\n\n测试是代码开发中重要的一个环节，但实际上对于前端开发来说，前端开发工程师一般较少书写测试用例，也并没有专业的测试开发工程师来辅助工作，不过，一般会有配备系统测试工程师在黑盒的情况下进行冒烟测试和功能测试以及整体链路的验收，俗称“点点点”。而这个时候，前端开发要做的就是把程序代码部署到测试服务器上，同时提供一个尽可能真实的场景供测试进行测试。\n\n在笔者经历的项目中，虽然也使用了单元测试、端对端测试，不过这一部分体系并不十分完备，并且可能也不是大多数前端开发者感兴趣的内容，所以这里主要总结如何进行高效的测试部署与发布对接。\n\n一般来说，我们一般会有一台到多台 Linux 测试机，供测试环境部署使用，对于前端项目而言，一般不需要特殊环境，可以进行 webpack 构建以及有 nginx 进行转发即可。\n\n而测试环境的部署，如果是让我们手动登录去部署，显然是不合理的，如果我们纯粹使用 CI 来完成这件事，则对 CI 工具的能力和项目人员素质有一定要求，并且不具备可视化管理能力，容易出错，这里我建议可以维护一个可视化系统来进行测试环境的部署和管理，其整个环节应该是这样的：\n\n```\n本地代码 -> gitlab -> 测试系统部署 -> 对接发布系统 \n```\n\n这里的测试系统，实际上是从 gitlab 拉取代码，并且本地执行 build 命令（一般是 `npm run build`）并把构建结果存储在 nginx 可代理的目录即可，出于系统完备性考虑，一般我们会有多台测试机，这里我建议一般拿其中的一台作为构建机，其他的测试机仅提供 nginx 代理能力即可，我们在一台构建机中进行构建，并且将构建结果通过系统命令发送到其他的测试机。\n\n一台构建机可以服务于所有的项目，这里还可能涉及到 webpack、nodejs 版本的维护，我们需要约束各个测试项目构建处在一个相对独立的环境中，我们也可以使用过 Docker 来进行构建，保证隔离。\n\n构建完成后，一般我们借助 Fiddler、Charles、Whistle 等任意一款代理工具，即可以进行测试。\n\n### 监控：日志查看与脚本错误的监控\n\n对于前端项目而言，即使我们已经使用了 typescript、eslint 并且也有了一些测试脚本和系统测试工程师进行的功能测试，我们还是免不了会出现 js 脚本错误，特别是 js 代码的运行环境和设备的多样化，很多错误我们并没有发现，但是产品、运营同学却出现了，或者到了线上在用户设备上出现了。\n\n所以，有两个事情我们必须要做：\n\n1. 日志查看功能（手机端）：现在我们写的大多数 TO C 页面都是在手机端进行，查看 console 非常不方便，我们需要一个线上实时查看 console 的工具。\n2. 我们需要脚本错误日志统计系统来进行错误统计管理与具体错误查看。\n\n对于第一个功能，进行细分，我们需要做这样几件事情：\n\n* 嵌入一个 console 和 网络请求查看器，并且只在特殊情况下才能触发（比如连续点击标题十次、或者使用特定交互手势）\n* 在触发查看器的时候，可以将日志完整地进行上传并分析。\n* 同时可以对该用户进行染色，会自动上传并记录该用户一定时间内后续刷新后操作的全部日志。\n\n不过这里并没有完全实现以上三点的开源库推荐，可以在 [vconsole](https://github.com/Tencent/vConsole) 或者 [mlogger](https://github.com/AlloyTeam/MLogger) 的基础上进行适当扩展，完成相关功能。\n\n对于第二个功能，我们需要一个完整的统计分析与管理的错误系统，这个如果自行开发的话，难度会比较大，这里强烈推荐 [sentry](https://sentry.io/welcome/)，可以非常方便的使用 Docker 部署到服务器端，并且拥有非常强大的日志错误分析与处理能力，通过结合 JavaScript 的 sourcemap ，可以给我们的错误定位带来极大的方便。\n\n总之，日志查看与脚本错误监控，是比较重要但是同时容易被忽视的地方，很多时候，我们的系统在线上使用了几个月了，真正有问题反馈了，我们才会考虑加上这些功能，但这个时候通常已经造成了损失。\n\n### 发布：版本发布更新\n\n发布系统，一般作为前端最后环节的系统，通常会和测试部署系统打通（或合二为一），一般的发布系统的必要功能如下：\n\n* 对于前端的发布，每次只发布有改变的文件，无变动的文件则无需发布。\n* 每次发布先发布 js/css/img 等资源文件，生效之后再发布 html 文件。\n* 发布系统保留线上旧版代码，出问题后可以快速一键回滚。\n\n至于一些其他的日志、报表等辅助性功能，则根据需要满足，这里不再赘述。\n\n#### 灰度发布\n\n灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1-5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量较大的页面。\n\n对于前端的灰度，实际上有以下几种方案：\n\n* 在代码层面进行灰度，即通过 if/else 进行判断，这样无需发布系统关注，也可以自由配置规则、比例与白名单/黑名单。\n* 在入口层面进行灰度，比如 App 内嵌的 H5 则在客户端的对应入口进行回复，这样通常也无需发布系统关注。\n* 通过发布系统，按照比例灰度，比如我们有 10 台 webserver，如果我们先发布 1 台，这样我们的灰度比例为 10%。\n\n### 访问量实时监控\n\n最后一点，我们还需要一个访问量实时监控系统，我们上述有了错误查看与脚本监控系统，但是对于我们的各个页面的访问量、点击率等指标，通常是产品/运营同学比较关心的，同时访问量的波动情况也是项目健康度的一个表征（访问量突然大幅上涨或下跌，一般都有其特定原因），所以我们需要访问量实时监控系统。\n\n而实际上访问量监控系统也有两种不同形态：\n\n* 对于每一个上报 key，只进行数量上的统计\n* 对于每一个上报 key，可以携带一些信息，对携带信息进行统计分析。\n\n通常情况下，前者的功能是实时或者低延时的，而后者由于需要一部分统计分析，通常可以接受非实时情况（一般每天出前一天的报表）。\n\n这部分内容，需要较强的后端接口稳定性，通常前端需要和对应岗位的同学共建。\n\n### 总结\n\n总结下来，我们一个稳定的前端项目，至少涉及到以下环节：\n\n* 完善的项目脚手架与代码约束规范\n* 内部 gitlab\n* 可视化管理的测试部署系统\n* 实时日志查看工具\n* 脚本错误统计管理系统\n* 发布管理系统\n* 访问量实时监控系统\n\n如果你所在的团队哪个环节还没有或者不完善，那么这也是你的机会。\n","slug":"web应用开发与部署——你必须掌握的内容","published":1,"updated":"2021-12-23T05:50:07.542Z","_id":"ckxijpqst000md3mr4xlc87h0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文基于笔者在腾讯的项目经验，从真实场景出发分析一个中型 Web 应用从立项到上线稳定运行的平稳解决方案，力求既不太空泛以至于看完了仍然找不到落地的点，也尽量不会特别纠结于个别细节导致没有相关使用经历的同学无法感同身受，而是从宏观到方法论，分析整个流程中我们需要用到的工具、方法与规范，给大家提供一个参考。</p>\n<p>本文适合具有一定经验的初中级前端开发者，如果有相关问题，也欢迎与我交流。</p>\n<p>目录</p>\n<ul>\n<li>项目构建的搭建，关键词：<strong>webpack</strong>、<strong>react/vue cli</strong>，<strong>steamer</strong>，<strong>组件库</strong></li>\n<li>代码的规范约束，关键词：<strong>typescript</strong>、<strong>eslint</strong>、<strong>prettier</strong></li>\n<li>测试与测试部署，关键词：<strong>测试部署方案</strong>、<strong>docker</strong></li>\n<li>日志查看与脚本错误的监控，关键词：<strong>sentry</strong>、<strong>vconsole</strong>、<strong>mlogger</strong></li>\n<li>版本发布更新，关键词：<strong>发布系统</strong>、<strong>灰度发布</strong></li>\n<li>访问量实时监控</li>\n</ul>\n<h3 id=\"起步：项目构建的搭建\"><a href=\"#起步：项目构建的搭建\" class=\"headerlink\" title=\"起步：项目构建的搭建\"></a>起步：项目构建的搭建</h3><h4 id=\"使用-webpack-搭建脚手架\"><a href=\"#使用-webpack-搭建脚手架\" class=\"headerlink\" title=\"使用 webpack 搭建脚手架\"></a>使用 webpack 搭建脚手架</h4><p>目前在一般的项目中，我们都会使用 webpack 作为搭建开发环境的基础，而 react 和 vue 也各自提供了 cli 工具用于开发一个中小型项目，react 提供了 eject 功能让我们可以更加自由的配置 webpack，而 vue 脚手架虽然没有提供类似命令，但是借助 webpack 工具链我们几乎也可以自由定制每一个角落。</p>\n<p>不过，这里我的建议是，如果是个人项目或小型项目，我们可以基于 react 或 vue 的脚手架进行更改使用，对于一个具备一定规模的项目团队，建议还是自己维护一套单独的 webpack 构建环境，原因如下：</p>\n<ul>\n<li>由于我们一般需要在项目中接入各类司内工具、支持高级API和语法、同时支持 react/vue、构建目录定制化等各类工作，实际上 80% 以上的工作我们都需要在模版之上自行添加，这个时候我们再用脚手架带来的收益已经非常小了，反而还会受制于项目的初始目录结构。</li>\n</ul>\n<p>我们在自定义脚手架的 webpack 构建的时候，也需要梳理出一定的目录规范与约束，这样也有利于提高后期脚手架的可维护性和扩展性，一般来说，我们也要对脚手架中的公共部分和项目私有部分进行分离，对于一个具体项目而言，可以不用改动 webpack 的项目公共部分，这样也有利于减少不同项目之间的切换成本，对于我们目前的项目，一般会有如下两个目录：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> project</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> project.js</span><br><span class=\"line\"><span class=\"bullet\">-</span> config</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> feature</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> plugins</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> rules</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> script.js</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> webpack.base.js \t</span><br></pre></td></tr></table></figure>\n\n<p>对于一个项目，只需更改 project 下的配置。</p>\n<p>这里我也推荐一个前同事做的<a href=\"https://github.com/steamerjs\">steamer研发体系</a>，在从中也可以找到很多相关参考，最简单的方式，就是直接在<a href=\"https://github.com/steamerjs/steamer-simple\">steamer-simple</a> 的基础上进行扩展。</p>\n<h4 id=\"定制生成目录\"><a href=\"#定制生成目录\" class=\"headerlink\" title=\"定制生成目录\"></a>定制生成目录</h4><p>生成目录的格式，这里需要单独讲一下。</p>\n<p>一般来说，我们生成目录的格式都是要跟发布系统进行结合的，不过也有的时候，我们做项目的时候还没有明确要接入发布系统，或者尚不知道发布系统的格式要求，但是一般情况下我们应当遵循下面的约定：</p>\n<ul>\n<li>js/css/img 等资源文件和 html 文件分离，前者发布到 CDN，后者发布到 http 服务器。</li>\n<li>html 中引入的文件地址，应当是在构建过程中更新的 CDN 地址，而不是相对路径地址。</li>\n<li>如果有离线包（offline 能力需要对应的客户端 webview 支持）等，需要单独一个目录。</li>\n</ul>\n<p>对于我们目前的项目而言，一般情况下会有三个生成目录：</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\"> cdn</span></span><br><span class=\"line\"><span class=\"ruby\"></span>-<span class=\"ruby\"> offline <span class=\"comment\"># 需要客户端支持该能力</span></span></span><br><span class=\"line\"><span class=\"ruby\"></span>-<span class=\"ruby\"> webserver</span></span><br></pre></td></tr></table></figure>\n\n<p>如果一开始我们把所有内容生成到一个目录中了，这给我们后期的改动和维护，都带来很大的隐患。</p>\n<h4 id=\"组件库\"><a href=\"#组件库\" class=\"headerlink\" title=\"组件库\"></a>组件库</h4><p>组件库这一部分，适合项目开始变得复杂的情况下进行启动，而不建议一开始进行过渡设计，建设组件库能够通过组件复用降低我们的开发成本，同时，组件库也需要专人维护，保持更新。</p>\n<h3 id=\"开发：代码的规范约束\"><a href=\"#开发：代码的规范约束\" class=\"headerlink\" title=\"开发：代码的规范约束\"></a>开发：代码的规范约束</h3><p>对于 js 文件的代码格式，诸如要不要分号、两个还是四个字符缩进等，一只争议不断，本文也不对此进行讨论，但是对于一个团队的项目集合（而不是单个项目）而言，代码风格的统一，是一个非常有必要而且必须要做的事情。</p>\n<h4 id=\"typescript\"><a href=\"#typescript\" class=\"headerlink\" title=\"typescript\"></a>typescript</h4><p>关于 typescript 的相关文章实在太多了，这里也不对此进行详细的说明，其对代码的可读性、规范约束、降低报错风险等都有很好的改进，对于越复杂的项目其效果越明显。</p>\n<p>另外， <a href=\"https://ts.xcatliu.com/\">typescript 入门教程</a>的作者也在我们团队中，这里我想说，如果现在还没有开始使用 typescript，请开始学习并使用 typescript 吧。</p>\n<h4 id=\"eslint-与-prettier\"><a href=\"#eslint-与-prettier\" class=\"headerlink\" title=\"eslint 与 prettier\"></a>eslint 与 prettier</h4><p>除了 typescript 以外，在代码格式方面还建议使用 eslint 和 prettier 来进行代码格式的约束，这里虽然 eslint 和 prettier 两者在某些情景下会有些重叠，但是两者的侧重点不同，eslint 侧重于代码质量的检查并且给出提示，在某种层面上，可以看作是 typescript 的补充，而 prettier 在格式化代码方面更具有优势，并且 prettier 在设计之初就考虑了和 eslint 的集成，所以你可以完全放心的在项目中使用两者，而不用担心出现无法解决的冲突。</p>\n<p>另外，eslint 社区中已经形成了很多种最佳实践，而我们团队也设计出了自己的一套 eslint 规则，可以按需<a href=\"https://github.com/AlloyTeam/eslint-config-alloy\">取用</a></p>\n<p>p.s. 目前 tslint 后续计划不在维护，转向 eslint 增强，因此我们在项目中可以不再使用 tslint。</p>\n<p>以上这几种代码风格方面的约束，适合项目之初即开始约束，这样在中后期会有巨大的时间成本的节省和效率的提升。</p>\n<h3 id=\"协作：使用-git\"><a href=\"#协作：使用-git\" class=\"headerlink\" title=\"协作：使用 git\"></a>协作：使用 git</h3><p>使用 git 进行协作这里其实包括两个点，使用 git 管理项目与自建 gitlab，后者是一个比较基础性的工作，并且实际上难度并不大，我认为每一个公司都可以使用自建的 gitlab 进行版本管理，这个实际上难度并不大，并且可以有效的保护公司的代码财产，如果你所在的公司还没有，那么这也是你的机会。</p>\n<p>在具体的使用 git 中，对于git的分支/TAG管理、PR规范、提交文件约束等都应当有一套合理的流程，这里我对几点比较重要的进行说明：</p>\n<ul>\n<li>锁定主干与分支开发，我们在日常开发中禁止直接提交主干，而是只能在分支中进行开发，并且通过 MR 的方式提交到主干。</li>\n<li>git hooks 检查：我们应该通过 git hooks 进行必要的检查，比如自动化测试、eslint 检查、以及一些项目中必要的检查。</li>\n<li>MR 检查与 Code Review，这里建议在 Merge Request 的时候做两件事情，一件是 Code Review，不过这个在某些特殊情况下不具备条件，尤其是团队人力紧张的时候，另外一个则是 MR 的 HOOK 触发检查，这个一般需要借助一些持续集成工具来完成，可以说是我们代码在合并主干之前的最后一个关卡。</li>\n</ul>\n<h3 id=\"测试：测试与测试部署\"><a href=\"#测试：测试与测试部署\" class=\"headerlink\" title=\"测试：测试与测试部署\"></a>测试：测试与测试部署</h3><p>测试是代码开发中重要的一个环节，但实际上对于前端开发来说，前端开发工程师一般较少书写测试用例，也并没有专业的测试开发工程师来辅助工作，不过，一般会有配备系统测试工程师在黑盒的情况下进行冒烟测试和功能测试以及整体链路的验收，俗称“点点点”。而这个时候，前端开发要做的就是把程序代码部署到测试服务器上，同时提供一个尽可能真实的场景供测试进行测试。</p>\n<p>在笔者经历的项目中，虽然也使用了单元测试、端对端测试，不过这一部分体系并不十分完备，并且可能也不是大多数前端开发者感兴趣的内容，所以这里主要总结如何进行高效的测试部署与发布对接。</p>\n<p>一般来说，我们一般会有一台到多台 Linux 测试机，供测试环境部署使用，对于前端项目而言，一般不需要特殊环境，可以进行 webpack 构建以及有 nginx 进行转发即可。</p>\n<p>而测试环境的部署，如果是让我们手动登录去部署，显然是不合理的，如果我们纯粹使用 CI 来完成这件事，则对 CI 工具的能力和项目人员素质有一定要求，并且不具备可视化管理能力，容易出错，这里我建议可以维护一个可视化系统来进行测试环境的部署和管理，其整个环节应该是这样的：</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地代码 -&gt; gitlab -&gt; 测试系统部署 -&gt; 对接发布系统 </span><br></pre></td></tr></table></figure>\n\n<p>这里的测试系统，实际上是从 gitlab 拉取代码，并且本地执行 build 命令（一般是 <code>npm run build</code>）并把构建结果存储在 nginx 可代理的目录即可，出于系统完备性考虑，一般我们会有多台测试机，这里我建议一般拿其中的一台作为构建机，其他的测试机仅提供 nginx 代理能力即可，我们在一台构建机中进行构建，并且将构建结果通过系统命令发送到其他的测试机。</p>\n<p>一台构建机可以服务于所有的项目，这里还可能涉及到 webpack、nodejs 版本的维护，我们需要约束各个测试项目构建处在一个相对独立的环境中，我们也可以使用过 Docker 来进行构建，保证隔离。</p>\n<p>构建完成后，一般我们借助 Fiddler、Charles、Whistle 等任意一款代理工具，即可以进行测试。</p>\n<h3 id=\"监控：日志查看与脚本错误的监控\"><a href=\"#监控：日志查看与脚本错误的监控\" class=\"headerlink\" title=\"监控：日志查看与脚本错误的监控\"></a>监控：日志查看与脚本错误的监控</h3><p>对于前端项目而言，即使我们已经使用了 typescript、eslint 并且也有了一些测试脚本和系统测试工程师进行的功能测试，我们还是免不了会出现 js 脚本错误，特别是 js 代码的运行环境和设备的多样化，很多错误我们并没有发现，但是产品、运营同学却出现了，或者到了线上在用户设备上出现了。</p>\n<p>所以，有两个事情我们必须要做：</p>\n<ol>\n<li>日志查看功能（手机端）：现在我们写的大多数 TO C 页面都是在手机端进行，查看 console 非常不方便，我们需要一个线上实时查看 console 的工具。</li>\n<li>我们需要脚本错误日志统计系统来进行错误统计管理与具体错误查看。</li>\n</ol>\n<p>对于第一个功能，进行细分，我们需要做这样几件事情：</p>\n<ul>\n<li>嵌入一个 console 和 网络请求查看器，并且只在特殊情况下才能触发（比如连续点击标题十次、或者使用特定交互手势）</li>\n<li>在触发查看器的时候，可以将日志完整地进行上传并分析。</li>\n<li>同时可以对该用户进行染色，会自动上传并记录该用户一定时间内后续刷新后操作的全部日志。</li>\n</ul>\n<p>不过这里并没有完全实现以上三点的开源库推荐，可以在 <a href=\"https://github.com/Tencent/vConsole\">vconsole</a> 或者 <a href=\"https://github.com/AlloyTeam/MLogger\">mlogger</a> 的基础上进行适当扩展，完成相关功能。</p>\n<p>对于第二个功能，我们需要一个完整的统计分析与管理的错误系统，这个如果自行开发的话，难度会比较大，这里强烈推荐 <a href=\"https://sentry.io/welcome/\">sentry</a>，可以非常方便的使用 Docker 部署到服务器端，并且拥有非常强大的日志错误分析与处理能力，通过结合 JavaScript 的 sourcemap ，可以给我们的错误定位带来极大的方便。</p>\n<p>总之，日志查看与脚本错误监控，是比较重要但是同时容易被忽视的地方，很多时候，我们的系统在线上使用了几个月了，真正有问题反馈了，我们才会考虑加上这些功能，但这个时候通常已经造成了损失。</p>\n<h3 id=\"发布：版本发布更新\"><a href=\"#发布：版本发布更新\" class=\"headerlink\" title=\"发布：版本发布更新\"></a>发布：版本发布更新</h3><p>发布系统，一般作为前端最后环节的系统，通常会和测试部署系统打通（或合二为一），一般的发布系统的必要功能如下：</p>\n<ul>\n<li>对于前端的发布，每次只发布有改变的文件，无变动的文件则无需发布。</li>\n<li>每次发布先发布 js/css/img 等资源文件，生效之后再发布 html 文件。</li>\n<li>发布系统保留线上旧版代码，出问题后可以快速一键回滚。</li>\n</ul>\n<p>至于一些其他的日志、报表等辅助性功能，则根据需要满足，这里不再赘述。</p>\n<h4 id=\"灰度发布\"><a href=\"#灰度发布\" class=\"headerlink\" title=\"灰度发布\"></a>灰度发布</h4><p>灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1-5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量较大的页面。</p>\n<p>对于前端的灰度，实际上有以下几种方案：</p>\n<ul>\n<li>在代码层面进行灰度，即通过 if/else 进行判断，这样无需发布系统关注，也可以自由配置规则、比例与白名单/黑名单。</li>\n<li>在入口层面进行灰度，比如 App 内嵌的 H5 则在客户端的对应入口进行回复，这样通常也无需发布系统关注。</li>\n<li>通过发布系统，按照比例灰度，比如我们有 10 台 webserver，如果我们先发布 1 台，这样我们的灰度比例为 10%。</li>\n</ul>\n<h3 id=\"访问量实时监控\"><a href=\"#访问量实时监控\" class=\"headerlink\" title=\"访问量实时监控\"></a>访问量实时监控</h3><p>最后一点，我们还需要一个访问量实时监控系统，我们上述有了错误查看与脚本监控系统，但是对于我们的各个页面的访问量、点击率等指标，通常是产品/运营同学比较关心的，同时访问量的波动情况也是项目健康度的一个表征（访问量突然大幅上涨或下跌，一般都有其特定原因），所以我们需要访问量实时监控系统。</p>\n<p>而实际上访问量监控系统也有两种不同形态：</p>\n<ul>\n<li>对于每一个上报 key，只进行数量上的统计</li>\n<li>对于每一个上报 key，可以携带一些信息，对携带信息进行统计分析。</li>\n</ul>\n<p>通常情况下，前者的功能是实时或者低延时的，而后者由于需要一部分统计分析，通常可以接受非实时情况（一般每天出前一天的报表）。</p>\n<p>这部分内容，需要较强的后端接口稳定性，通常前端需要和对应岗位的同学共建。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>总结下来，我们一个稳定的前端项目，至少涉及到以下环节：</p>\n<ul>\n<li>完善的项目脚手架与代码约束规范</li>\n<li>内部 gitlab</li>\n<li>可视化管理的测试部署系统</li>\n<li>实时日志查看工具</li>\n<li>脚本错误统计管理系统</li>\n<li>发布管理系统</li>\n<li>访问量实时监控系统</li>\n</ul>\n<p>如果你所在的团队哪个环节还没有或者不完善，那么这也是你的机会。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文基于笔者在腾讯的项目经验，从真实场景出发分析一个中型 Web 应用从立项到上线稳定运行的平稳解决方案，力求既不太空泛以至于看完了仍然找不到落地的点，也尽量不会特别纠结于个别细节导致没有相关使用经历的同学无法感同身受，而是从宏观到方法论，分析整个流程中我们需要用到的工具、方法与规范，给大家提供一个参考。</p>\n<p>本文适合具有一定经验的初中级前端开发者，如果有相关问题，也欢迎与我交流。</p>\n<p>目录</p>\n<ul>\n<li>项目构建的搭建，关键词：<strong>webpack</strong>、<strong>react/vue cli</strong>，<strong>steamer</strong>，<strong>组件库</strong></li>\n<li>代码的规范约束，关键词：<strong>typescript</strong>、<strong>eslint</strong>、<strong>prettier</strong></li>\n<li>测试与测试部署，关键词：<strong>测试部署方案</strong>、<strong>docker</strong></li>\n<li>日志查看与脚本错误的监控，关键词：<strong>sentry</strong>、<strong>vconsole</strong>、<strong>mlogger</strong></li>\n<li>版本发布更新，关键词：<strong>发布系统</strong>、<strong>灰度发布</strong></li>\n<li>访问量实时监控</li>\n</ul>\n<h3 id=\"起步：项目构建的搭建\"><a href=\"#起步：项目构建的搭建\" class=\"headerlink\" title=\"起步：项目构建的搭建\"></a>起步：项目构建的搭建</h3><h4 id=\"使用-webpack-搭建脚手架\"><a href=\"#使用-webpack-搭建脚手架\" class=\"headerlink\" title=\"使用 webpack 搭建脚手架\"></a>使用 webpack 搭建脚手架</h4><p>目前在一般的项目中，我们都会使用 webpack 作为搭建开发环境的基础，而 react 和 vue 也各自提供了 cli 工具用于开发一个中小型项目，react 提供了 eject 功能让我们可以更加自由的配置 webpack，而 vue 脚手架虽然没有提供类似命令，但是借助 webpack 工具链我们几乎也可以自由定制每一个角落。</p>\n<p>不过，这里我的建议是，如果是个人项目或小型项目，我们可以基于 react 或 vue 的脚手架进行更改使用，对于一个具备一定规模的项目团队，建议还是自己维护一套单独的 webpack 构建环境，原因如下：</p>\n<ul>\n<li>由于我们一般需要在项目中接入各类司内工具、支持高级API和语法、同时支持 react/vue、构建目录定制化等各类工作，实际上 80% 以上的工作我们都需要在模版之上自行添加，这个时候我们再用脚手架带来的收益已经非常小了，反而还会受制于项目的初始目录结构。</li>\n</ul>\n<p>我们在自定义脚手架的 webpack 构建的时候，也需要梳理出一定的目录规范与约束，这样也有利于提高后期脚手架的可维护性和扩展性，一般来说，我们也要对脚手架中的公共部分和项目私有部分进行分离，对于一个具体项目而言，可以不用改动 webpack 的项目公共部分，这样也有利于减少不同项目之间的切换成本，对于我们目前的项目，一般会有如下两个目录：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> project</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> project.js</span><br><span class=\"line\"><span class=\"bullet\">-</span> config</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> feature</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> plugins</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> rules</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> script.js</span><br><span class=\"line\"><span class=\"bullet\">\t-</span> webpack.base.js \t</span><br></pre></td></tr></table></figure>\n\n<p>对于一个项目，只需更改 project 下的配置。</p>\n<p>这里我也推荐一个前同事做的<a href=\"https://github.com/steamerjs\">steamer研发体系</a>，在从中也可以找到很多相关参考，最简单的方式，就是直接在<a href=\"https://github.com/steamerjs/steamer-simple\">steamer-simple</a> 的基础上进行扩展。</p>\n<h4 id=\"定制生成目录\"><a href=\"#定制生成目录\" class=\"headerlink\" title=\"定制生成目录\"></a>定制生成目录</h4><p>生成目录的格式，这里需要单独讲一下。</p>\n<p>一般来说，我们生成目录的格式都是要跟发布系统进行结合的，不过也有的时候，我们做项目的时候还没有明确要接入发布系统，或者尚不知道发布系统的格式要求，但是一般情况下我们应当遵循下面的约定：</p>\n<ul>\n<li>js/css/img 等资源文件和 html 文件分离，前者发布到 CDN，后者发布到 http 服务器。</li>\n<li>html 中引入的文件地址，应当是在构建过程中更新的 CDN 地址，而不是相对路径地址。</li>\n<li>如果有离线包（offline 能力需要对应的客户端 webview 支持）等，需要单独一个目录。</li>\n</ul>\n<p>对于我们目前的项目而言，一般情况下会有三个生成目录：</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\"> cdn</span></span><br><span class=\"line\"><span class=\"ruby\"></span>-<span class=\"ruby\"> offline <span class=\"comment\"># 需要客户端支持该能力</span></span></span><br><span class=\"line\"><span class=\"ruby\"></span>-<span class=\"ruby\"> webserver</span></span><br></pre></td></tr></table></figure>\n\n<p>如果一开始我们把所有内容生成到一个目录中了，这给我们后期的改动和维护，都带来很大的隐患。</p>\n<h4 id=\"组件库\"><a href=\"#组件库\" class=\"headerlink\" title=\"组件库\"></a>组件库</h4><p>组件库这一部分，适合项目开始变得复杂的情况下进行启动，而不建议一开始进行过渡设计，建设组件库能够通过组件复用降低我们的开发成本，同时，组件库也需要专人维护，保持更新。</p>\n<h3 id=\"开发：代码的规范约束\"><a href=\"#开发：代码的规范约束\" class=\"headerlink\" title=\"开发：代码的规范约束\"></a>开发：代码的规范约束</h3><p>对于 js 文件的代码格式，诸如要不要分号、两个还是四个字符缩进等，一只争议不断，本文也不对此进行讨论，但是对于一个团队的项目集合（而不是单个项目）而言，代码风格的统一，是一个非常有必要而且必须要做的事情。</p>\n<h4 id=\"typescript\"><a href=\"#typescript\" class=\"headerlink\" title=\"typescript\"></a>typescript</h4><p>关于 typescript 的相关文章实在太多了，这里也不对此进行详细的说明，其对代码的可读性、规范约束、降低报错风险等都有很好的改进，对于越复杂的项目其效果越明显。</p>\n<p>另外， <a href=\"https://ts.xcatliu.com/\">typescript 入门教程</a>的作者也在我们团队中，这里我想说，如果现在还没有开始使用 typescript，请开始学习并使用 typescript 吧。</p>\n<h4 id=\"eslint-与-prettier\"><a href=\"#eslint-与-prettier\" class=\"headerlink\" title=\"eslint 与 prettier\"></a>eslint 与 prettier</h4><p>除了 typescript 以外，在代码格式方面还建议使用 eslint 和 prettier 来进行代码格式的约束，这里虽然 eslint 和 prettier 两者在某些情景下会有些重叠，但是两者的侧重点不同，eslint 侧重于代码质量的检查并且给出提示，在某种层面上，可以看作是 typescript 的补充，而 prettier 在格式化代码方面更具有优势，并且 prettier 在设计之初就考虑了和 eslint 的集成，所以你可以完全放心的在项目中使用两者，而不用担心出现无法解决的冲突。</p>\n<p>另外，eslint 社区中已经形成了很多种最佳实践，而我们团队也设计出了自己的一套 eslint 规则，可以按需<a href=\"https://github.com/AlloyTeam/eslint-config-alloy\">取用</a></p>\n<p>p.s. 目前 tslint 后续计划不在维护，转向 eslint 增强，因此我们在项目中可以不再使用 tslint。</p>\n<p>以上这几种代码风格方面的约束，适合项目之初即开始约束，这样在中后期会有巨大的时间成本的节省和效率的提升。</p>\n<h3 id=\"协作：使用-git\"><a href=\"#协作：使用-git\" class=\"headerlink\" title=\"协作：使用 git\"></a>协作：使用 git</h3><p>使用 git 进行协作这里其实包括两个点，使用 git 管理项目与自建 gitlab，后者是一个比较基础性的工作，并且实际上难度并不大，我认为每一个公司都可以使用自建的 gitlab 进行版本管理，这个实际上难度并不大，并且可以有效的保护公司的代码财产，如果你所在的公司还没有，那么这也是你的机会。</p>\n<p>在具体的使用 git 中，对于git的分支/TAG管理、PR规范、提交文件约束等都应当有一套合理的流程，这里我对几点比较重要的进行说明：</p>\n<ul>\n<li>锁定主干与分支开发，我们在日常开发中禁止直接提交主干，而是只能在分支中进行开发，并且通过 MR 的方式提交到主干。</li>\n<li>git hooks 检查：我们应该通过 git hooks 进行必要的检查，比如自动化测试、eslint 检查、以及一些项目中必要的检查。</li>\n<li>MR 检查与 Code Review，这里建议在 Merge Request 的时候做两件事情，一件是 Code Review，不过这个在某些特殊情况下不具备条件，尤其是团队人力紧张的时候，另外一个则是 MR 的 HOOK 触发检查，这个一般需要借助一些持续集成工具来完成，可以说是我们代码在合并主干之前的最后一个关卡。</li>\n</ul>\n<h3 id=\"测试：测试与测试部署\"><a href=\"#测试：测试与测试部署\" class=\"headerlink\" title=\"测试：测试与测试部署\"></a>测试：测试与测试部署</h3><p>测试是代码开发中重要的一个环节，但实际上对于前端开发来说，前端开发工程师一般较少书写测试用例，也并没有专业的测试开发工程师来辅助工作，不过，一般会有配备系统测试工程师在黑盒的情况下进行冒烟测试和功能测试以及整体链路的验收，俗称“点点点”。而这个时候，前端开发要做的就是把程序代码部署到测试服务器上，同时提供一个尽可能真实的场景供测试进行测试。</p>\n<p>在笔者经历的项目中，虽然也使用了单元测试、端对端测试，不过这一部分体系并不十分完备，并且可能也不是大多数前端开发者感兴趣的内容，所以这里主要总结如何进行高效的测试部署与发布对接。</p>\n<p>一般来说，我们一般会有一台到多台 Linux 测试机，供测试环境部署使用，对于前端项目而言，一般不需要特殊环境，可以进行 webpack 构建以及有 nginx 进行转发即可。</p>\n<p>而测试环境的部署，如果是让我们手动登录去部署，显然是不合理的，如果我们纯粹使用 CI 来完成这件事，则对 CI 工具的能力和项目人员素质有一定要求，并且不具备可视化管理能力，容易出错，这里我建议可以维护一个可视化系统来进行测试环境的部署和管理，其整个环节应该是这样的：</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地代码 -&gt; gitlab -&gt; 测试系统部署 -&gt; 对接发布系统 </span><br></pre></td></tr></table></figure>\n\n<p>这里的测试系统，实际上是从 gitlab 拉取代码，并且本地执行 build 命令（一般是 <code>npm run build</code>）并把构建结果存储在 nginx 可代理的目录即可，出于系统完备性考虑，一般我们会有多台测试机，这里我建议一般拿其中的一台作为构建机，其他的测试机仅提供 nginx 代理能力即可，我们在一台构建机中进行构建，并且将构建结果通过系统命令发送到其他的测试机。</p>\n<p>一台构建机可以服务于所有的项目，这里还可能涉及到 webpack、nodejs 版本的维护，我们需要约束各个测试项目构建处在一个相对独立的环境中，我们也可以使用过 Docker 来进行构建，保证隔离。</p>\n<p>构建完成后，一般我们借助 Fiddler、Charles、Whistle 等任意一款代理工具，即可以进行测试。</p>\n<h3 id=\"监控：日志查看与脚本错误的监控\"><a href=\"#监控：日志查看与脚本错误的监控\" class=\"headerlink\" title=\"监控：日志查看与脚本错误的监控\"></a>监控：日志查看与脚本错误的监控</h3><p>对于前端项目而言，即使我们已经使用了 typescript、eslint 并且也有了一些测试脚本和系统测试工程师进行的功能测试，我们还是免不了会出现 js 脚本错误，特别是 js 代码的运行环境和设备的多样化，很多错误我们并没有发现，但是产品、运营同学却出现了，或者到了线上在用户设备上出现了。</p>\n<p>所以，有两个事情我们必须要做：</p>\n<ol>\n<li>日志查看功能（手机端）：现在我们写的大多数 TO C 页面都是在手机端进行，查看 console 非常不方便，我们需要一个线上实时查看 console 的工具。</li>\n<li>我们需要脚本错误日志统计系统来进行错误统计管理与具体错误查看。</li>\n</ol>\n<p>对于第一个功能，进行细分，我们需要做这样几件事情：</p>\n<ul>\n<li>嵌入一个 console 和 网络请求查看器，并且只在特殊情况下才能触发（比如连续点击标题十次、或者使用特定交互手势）</li>\n<li>在触发查看器的时候，可以将日志完整地进行上传并分析。</li>\n<li>同时可以对该用户进行染色，会自动上传并记录该用户一定时间内后续刷新后操作的全部日志。</li>\n</ul>\n<p>不过这里并没有完全实现以上三点的开源库推荐，可以在 <a href=\"https://github.com/Tencent/vConsole\">vconsole</a> 或者 <a href=\"https://github.com/AlloyTeam/MLogger\">mlogger</a> 的基础上进行适当扩展，完成相关功能。</p>\n<p>对于第二个功能，我们需要一个完整的统计分析与管理的错误系统，这个如果自行开发的话，难度会比较大，这里强烈推荐 <a href=\"https://sentry.io/welcome/\">sentry</a>，可以非常方便的使用 Docker 部署到服务器端，并且拥有非常强大的日志错误分析与处理能力，通过结合 JavaScript 的 sourcemap ，可以给我们的错误定位带来极大的方便。</p>\n<p>总之，日志查看与脚本错误监控，是比较重要但是同时容易被忽视的地方，很多时候，我们的系统在线上使用了几个月了，真正有问题反馈了，我们才会考虑加上这些功能，但这个时候通常已经造成了损失。</p>\n<h3 id=\"发布：版本发布更新\"><a href=\"#发布：版本发布更新\" class=\"headerlink\" title=\"发布：版本发布更新\"></a>发布：版本发布更新</h3><p>发布系统，一般作为前端最后环节的系统，通常会和测试部署系统打通（或合二为一），一般的发布系统的必要功能如下：</p>\n<ul>\n<li>对于前端的发布，每次只发布有改变的文件，无变动的文件则无需发布。</li>\n<li>每次发布先发布 js/css/img 等资源文件，生效之后再发布 html 文件。</li>\n<li>发布系统保留线上旧版代码，出问题后可以快速一键回滚。</li>\n</ul>\n<p>至于一些其他的日志、报表等辅助性功能，则根据需要满足，这里不再赘述。</p>\n<h4 id=\"灰度发布\"><a href=\"#灰度发布\" class=\"headerlink\" title=\"灰度发布\"></a>灰度发布</h4><p>灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1-5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量较大的页面。</p>\n<p>对于前端的灰度，实际上有以下几种方案：</p>\n<ul>\n<li>在代码层面进行灰度，即通过 if/else 进行判断，这样无需发布系统关注，也可以自由配置规则、比例与白名单/黑名单。</li>\n<li>在入口层面进行灰度，比如 App 内嵌的 H5 则在客户端的对应入口进行回复，这样通常也无需发布系统关注。</li>\n<li>通过发布系统，按照比例灰度，比如我们有 10 台 webserver，如果我们先发布 1 台，这样我们的灰度比例为 10%。</li>\n</ul>\n<h3 id=\"访问量实时监控\"><a href=\"#访问量实时监控\" class=\"headerlink\" title=\"访问量实时监控\"></a>访问量实时监控</h3><p>最后一点，我们还需要一个访问量实时监控系统，我们上述有了错误查看与脚本监控系统，但是对于我们的各个页面的访问量、点击率等指标，通常是产品/运营同学比较关心的，同时访问量的波动情况也是项目健康度的一个表征（访问量突然大幅上涨或下跌，一般都有其特定原因），所以我们需要访问量实时监控系统。</p>\n<p>而实际上访问量监控系统也有两种不同形态：</p>\n<ul>\n<li>对于每一个上报 key，只进行数量上的统计</li>\n<li>对于每一个上报 key，可以携带一些信息，对携带信息进行统计分析。</li>\n</ul>\n<p>通常情况下，前者的功能是实时或者低延时的，而后者由于需要一部分统计分析，通常可以接受非实时情况（一般每天出前一天的报表）。</p>\n<p>这部分内容，需要较强的后端接口稳定性，通常前端需要和对应岗位的同学共建。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>总结下来，我们一个稳定的前端项目，至少涉及到以下环节：</p>\n<ul>\n<li>完善的项目脚手架与代码约束规范</li>\n<li>内部 gitlab</li>\n<li>可视化管理的测试部署系统</li>\n<li>实时日志查看工具</li>\n<li>脚本错误统计管理系统</li>\n<li>发布管理系统</li>\n<li>访问量实时监控系统</li>\n</ul>\n<p>如果你所在的团队哪个环节还没有或者不完善，那么这也是你的机会。</p>\n"},{"title":"web跨端融合方案浅析","abbrlink":2443313688,"date":"2018-12-04T12:51:52.000Z","_content":"\n本文会对目前流行的基于 JavaScript 的 web 跨端融合方案进行总结和分析，目标人群为 web 方向的从业者但是对跨端融合方案了解不多的人。\n\n### web 跨端融合简介\n\n在 2015 年 React Native 发布之前，web 在移动端 APP 上主要通过 WebView 进行承载，其有许多优点，可以快速迭代发布，不特别受 APP 版本的影响，因此，一些快速发展的业务（包括前期的手机QQ、手机淘宝）大量采用了 WebView 内嵌 H5 页面的形式来推动业务。\n\n但是这种方式缺点也比较明显，主要体现在以下两点：\n\n* 加载时间较长，包括 WebView 初始化的时间、网络请求的时间。\n* HTML 页面在性能上天然不如 Native 页面，无论怎么进行性能优化。\n\n在 2015 年，Facebook 推出了 React Native，从而打开了 web 跨端融合的大门，后续在此架构基础上又出现了阿里巴巴的 Weex（2016）、腾讯的小程序（小程序实际上更偏 web 一点，和其他几类稍有不同，本文不作介绍）、 Hippy（2018）、Taro（Taro 其实更偏向解释翻译，和其他几类定位不同）等跨端融合解决方案，并且渐渐被用到越来越多的项目中，目前，跨端融合开发已经是一种比较主流的 web 开发模式，在阿里系应用、腾讯的微信、QQ浏览器、手机QQ均已经进行了大规模应用。\n\n### 基本架构\n\n虽然 web 跨端融合方案众多，除了上述提到的三种，还有各个公司的更多方案，但是一般来说跨端融合的技术架构都比较相近，我们可以通过下面这一个图来简单概括：\n\n![](/img/1.jpg)\n\n接下来，我们逐个进行简析：\n\n* 业务代码：即我们写的 React Native 代码、Weex 代码，一般来说，我们的业务代码需要经过框架工具或者打包工具（例如 webpack 配合 loader）进行打包，从而兼容一些 ES Next 的写法以及一些框架本身不支持的 Web 写法。\n* Javascript FrameWork：这部分主要是针对 Weex、Hippy 来讲的，Weex 声称支持 Vue、Rax 语法，而 Hippy 声称支持 React、Vue 写法，实际上，对于这些库而言，并不是直接将 React、Vue 引入到项目中，而是会对其源代码进行修改（Vue 有针对 Weex 平台的[版本](https://github.com/vuejs/vue/tree/dev/src/platforms)），而 Hippy 也是对 React 源代码进行了修改，例如，你写的一个` createElement `的操作，在 Web 平台中实际调用的是 `document.createElement(tagName) `这个接口；而在 Weex 平台中实际执行的是` new renderer.Element(tagName)`（renderer 由 Javascript Runtime 提供，并且最终和 Native 通信渲染上屏）。\n* Javascript Runtime：Runtime 的部分，主要是对外暴露了一些统一的接口，比如说节点的增删改查、网络请求的接口等，而这些借口，实际上是其“代理”的客户端的能力，通过客户端 JSAPI 的方式进行调用。另外，把 Runtime 和 FrameWork 进行抽离，也可以便于一个跨端方案适配多个框架，只需要将不同的 FrameWork 和浏览器交互的部分代码转换成 Runtime 提供的标准接口，就可以实现对不同框架的支持。\n* Core：这部分主要是对 Javascript 的解释执行，在 iOS 上一般是 JSCore（系统自带，给客户端提供了执行 JavaScript 程序的能力），而安卓上则可以采用 V8、X5 等。\n* 最下层则是分 Android 和 iOS 端去进行渲染。\n\n### 发展现状\n\n实际上，React Native 最初提出这种解决方案的时候，市面上并没有同类的产品，但是由于 React Native 的一些问题和其他原因，各个大公司基本都在实现自己的跨端融合方案，这里 React Native 的问题主要体现在：\n\n* 最主要的是协议风险。\n* React Native 打包出来的 JSBundle 较大，并且默认没有灵活的分包机制，需要自行解决相关问题。\n* 在部分组件比如 List 组件中，性能较差（据非官方说法，性能并不是 React Native 团队首要考察因素，但是国内团队一般都比较重视性能）。\n* 部分事件发送频繁导致性能损失、例如列表滚动事件、手势事件等。\n* 双端 API 大量没有对齐（这也和其 slogan 是‘learn once, write everywhere’ 而不是 ‘write once, run everywhere’ 相对应）。\n\n而对于国内的 Weex 和 Hippy 框架，其都做了大量的性能优化解决了上述问题，并且规避了协议风险（Weex 采用了 Apache 2.0 协议，而 Hippy 即将开源）。\n\n另外值得一提的是，Weex 和 Hippy 都可以在 web 端进行运行，一般可以作为降级方案使用，从而真正做到了“一份代码”，三端运行。\n\n### 性能优化\n\n实际上，采用目前的跨端融合方案的体验已经比采用 WebView 的方案强太多了，但是性能优化是没有止境的，随着页面复杂度的提高以及用户体验的要求，实际上目前这类跨端融合方案采用了以下几个方向的性能和用户体验优化：\n\n#### 减少网络请求\n\n在我们上述提供的架构图中，一般而言对于一个这类页面，业务代码是通过网络请求加载的，这个时候在加载上主要省去的是 WebView 的初始化时间，这其实是不够的，所以我们也可以采用将业务代码提前下发并存在用户本地，打开的时候只需要从本地拉取并执行代码，这样可以减少相关的网络请求阻塞，优化加载时间。\n\n另外，减少网络请求还体现在对资源的缓存上，对一个页面中所采用的图片等资源文件进行 LRU 策略的缓存，从而防止重复的请求（在传统的 WebView 的方案上，也可以采用对 WebView 增加 Hook 的方式实现）。\n\n当然，以上两点在 WebView 的方案上也可以采用。\n\n#### 降低通信成本\n\n我们从上文的架构图中可以看出，这里的层级实际上比较多，如果不同层级的通信数据较多，并且有比较频繁甚至重复的编解码操作，肯定会有很大的开销，从而影响性能，所以，在不同层级之间做好数据的传递，并且防止重复的编解码操作是比较重要的。\n\n这里可以优化的细节其实比较多，我们举一个 Hippy 的例子：\n\n在 Hippy 架构中，jsRuntime 会生成一个 jsObject 对象树（即需要渲染的 DOM 信息），其在经过 JSBridge 时需要通过`JSON.stringify` 进行序列化，而在 Java（andriod) 接收端，则需要先将其变成一个 JsonObject，最终转化成 HippyMap，这里实际上是有重复的编解码操作的，我们看看 Hippy 的优化策略：\n\n![](/img/3.jpg)\n\n>图片来自 IMWeb 2018\n\n通过 hippybuffer 的方式减少通信的数据量，并且防止重复的编解码操作，可以有效提高性能。\n\n#### 减少通信次数\n\n为了减少在通信方面的消耗，我们除了降低通信的成本，还可以做的就是减少通信次数，当然，前提是不影响用户体验。\n\n这方面可以减少的通信消耗，其中一个方面是频繁的事件通信，我们知道，事件的触发是在 native 端的，但是事件处理的逻辑代码实际上是在 js 层来完成的，在这方面的通信，React Native 就因为频繁的通信从而影响了性能。\n\n我们可以优化的地方在于，首先减少没有绑定回调函数的事件通信，一般而言这部分通信是不必要的，其次是多次通信可以进行合并，比如说 list 滚动回调函数、以及动画通信，我们可以通过配置驱动代替数据驱动的方式（即一次向客户端传递整个配置，后续相同事件可以直接在客户端进行处理），来减少通信次数。\n\n这方面 Hippy 和 Weex 都有大量细碎的实践，在此便不具体介绍了。\n\n#### 降低首屏时间\n\n在原来的 WebView 页面中，我们为了增强用户体验，防止用户进来之后看到白屏，可以采用服务端渲染的方式，将渲染好的页面返回给客户端，同时优化了首屏请求，也防止了客户端设备较差造成JS执行时间较长的情况。\n\n在跨端融合方案中我们仍然有类似的解决方案，在不考虑离线包的情况下（即只考虑业务代码从远程加载的情况），我们也可以由服务端渲染好再返回，Weex 便采用了类似的方案，不过其做的更加彻底，在服务端将代码结果编译成 AST 树并转化成字节码（OPcode），在客户端解析后直接生成虚拟 DOM：\n\n![](/img/2.jpg)\n\n>图片来自 IMWeb 2018\n\n#### 客户端级别的其他优化\n\n客户端的优化有一部分是本来客户端开发就会面临的内容，也有一部分是和混合方案有关的优化，比如 Flex Render 的优化，不过这方面的内容一般而言和前端关系不是非常密切，笔者作为初级前端工程师，对这方面的内容还并不熟悉。\n\n### 框架选型\n\n本文的最后一部分，介绍框架选型。\n\n对于各类跨端融合的方案，其相对于 WebView 都有非常大的性能提升，因此在前期，无论选择什么框架都能够看到成效，这里也并不进行特定的框架选型推荐，但是一般认为，如果是从 Vue 的项目切换，Weex 会更合适一点，而如果从 React 项目切换，在确保没有证书风险的情况下可以采用 React Native，否则可以尝试原生支持 React 的 Hippy。\n\n以上。\n\n\n","source":"_posts/web跨端融合方案浅析.md","raw":"---\ntitle: web跨端融合方案浅析\ntags:\n  - 跨端融合\nabbrlink: 2443313688\ndate: 2018-12-04 20:51:52\n---\n\n本文会对目前流行的基于 JavaScript 的 web 跨端融合方案进行总结和分析，目标人群为 web 方向的从业者但是对跨端融合方案了解不多的人。\n\n### web 跨端融合简介\n\n在 2015 年 React Native 发布之前，web 在移动端 APP 上主要通过 WebView 进行承载，其有许多优点，可以快速迭代发布，不特别受 APP 版本的影响，因此，一些快速发展的业务（包括前期的手机QQ、手机淘宝）大量采用了 WebView 内嵌 H5 页面的形式来推动业务。\n\n但是这种方式缺点也比较明显，主要体现在以下两点：\n\n* 加载时间较长，包括 WebView 初始化的时间、网络请求的时间。\n* HTML 页面在性能上天然不如 Native 页面，无论怎么进行性能优化。\n\n在 2015 年，Facebook 推出了 React Native，从而打开了 web 跨端融合的大门，后续在此架构基础上又出现了阿里巴巴的 Weex（2016）、腾讯的小程序（小程序实际上更偏 web 一点，和其他几类稍有不同，本文不作介绍）、 Hippy（2018）、Taro（Taro 其实更偏向解释翻译，和其他几类定位不同）等跨端融合解决方案，并且渐渐被用到越来越多的项目中，目前，跨端融合开发已经是一种比较主流的 web 开发模式，在阿里系应用、腾讯的微信、QQ浏览器、手机QQ均已经进行了大规模应用。\n\n### 基本架构\n\n虽然 web 跨端融合方案众多，除了上述提到的三种，还有各个公司的更多方案，但是一般来说跨端融合的技术架构都比较相近，我们可以通过下面这一个图来简单概括：\n\n![](/img/1.jpg)\n\n接下来，我们逐个进行简析：\n\n* 业务代码：即我们写的 React Native 代码、Weex 代码，一般来说，我们的业务代码需要经过框架工具或者打包工具（例如 webpack 配合 loader）进行打包，从而兼容一些 ES Next 的写法以及一些框架本身不支持的 Web 写法。\n* Javascript FrameWork：这部分主要是针对 Weex、Hippy 来讲的，Weex 声称支持 Vue、Rax 语法，而 Hippy 声称支持 React、Vue 写法，实际上，对于这些库而言，并不是直接将 React、Vue 引入到项目中，而是会对其源代码进行修改（Vue 有针对 Weex 平台的[版本](https://github.com/vuejs/vue/tree/dev/src/platforms)），而 Hippy 也是对 React 源代码进行了修改，例如，你写的一个` createElement `的操作，在 Web 平台中实际调用的是 `document.createElement(tagName) `这个接口；而在 Weex 平台中实际执行的是` new renderer.Element(tagName)`（renderer 由 Javascript Runtime 提供，并且最终和 Native 通信渲染上屏）。\n* Javascript Runtime：Runtime 的部分，主要是对外暴露了一些统一的接口，比如说节点的增删改查、网络请求的接口等，而这些借口，实际上是其“代理”的客户端的能力，通过客户端 JSAPI 的方式进行调用。另外，把 Runtime 和 FrameWork 进行抽离，也可以便于一个跨端方案适配多个框架，只需要将不同的 FrameWork 和浏览器交互的部分代码转换成 Runtime 提供的标准接口，就可以实现对不同框架的支持。\n* Core：这部分主要是对 Javascript 的解释执行，在 iOS 上一般是 JSCore（系统自带，给客户端提供了执行 JavaScript 程序的能力），而安卓上则可以采用 V8、X5 等。\n* 最下层则是分 Android 和 iOS 端去进行渲染。\n\n### 发展现状\n\n实际上，React Native 最初提出这种解决方案的时候，市面上并没有同类的产品，但是由于 React Native 的一些问题和其他原因，各个大公司基本都在实现自己的跨端融合方案，这里 React Native 的问题主要体现在：\n\n* 最主要的是协议风险。\n* React Native 打包出来的 JSBundle 较大，并且默认没有灵活的分包机制，需要自行解决相关问题。\n* 在部分组件比如 List 组件中，性能较差（据非官方说法，性能并不是 React Native 团队首要考察因素，但是国内团队一般都比较重视性能）。\n* 部分事件发送频繁导致性能损失、例如列表滚动事件、手势事件等。\n* 双端 API 大量没有对齐（这也和其 slogan 是‘learn once, write everywhere’ 而不是 ‘write once, run everywhere’ 相对应）。\n\n而对于国内的 Weex 和 Hippy 框架，其都做了大量的性能优化解决了上述问题，并且规避了协议风险（Weex 采用了 Apache 2.0 协议，而 Hippy 即将开源）。\n\n另外值得一提的是，Weex 和 Hippy 都可以在 web 端进行运行，一般可以作为降级方案使用，从而真正做到了“一份代码”，三端运行。\n\n### 性能优化\n\n实际上，采用目前的跨端融合方案的体验已经比采用 WebView 的方案强太多了，但是性能优化是没有止境的，随着页面复杂度的提高以及用户体验的要求，实际上目前这类跨端融合方案采用了以下几个方向的性能和用户体验优化：\n\n#### 减少网络请求\n\n在我们上述提供的架构图中，一般而言对于一个这类页面，业务代码是通过网络请求加载的，这个时候在加载上主要省去的是 WebView 的初始化时间，这其实是不够的，所以我们也可以采用将业务代码提前下发并存在用户本地，打开的时候只需要从本地拉取并执行代码，这样可以减少相关的网络请求阻塞，优化加载时间。\n\n另外，减少网络请求还体现在对资源的缓存上，对一个页面中所采用的图片等资源文件进行 LRU 策略的缓存，从而防止重复的请求（在传统的 WebView 的方案上，也可以采用对 WebView 增加 Hook 的方式实现）。\n\n当然，以上两点在 WebView 的方案上也可以采用。\n\n#### 降低通信成本\n\n我们从上文的架构图中可以看出，这里的层级实际上比较多，如果不同层级的通信数据较多，并且有比较频繁甚至重复的编解码操作，肯定会有很大的开销，从而影响性能，所以，在不同层级之间做好数据的传递，并且防止重复的编解码操作是比较重要的。\n\n这里可以优化的细节其实比较多，我们举一个 Hippy 的例子：\n\n在 Hippy 架构中，jsRuntime 会生成一个 jsObject 对象树（即需要渲染的 DOM 信息），其在经过 JSBridge 时需要通过`JSON.stringify` 进行序列化，而在 Java（andriod) 接收端，则需要先将其变成一个 JsonObject，最终转化成 HippyMap，这里实际上是有重复的编解码操作的，我们看看 Hippy 的优化策略：\n\n![](/img/3.jpg)\n\n>图片来自 IMWeb 2018\n\n通过 hippybuffer 的方式减少通信的数据量，并且防止重复的编解码操作，可以有效提高性能。\n\n#### 减少通信次数\n\n为了减少在通信方面的消耗，我们除了降低通信的成本，还可以做的就是减少通信次数，当然，前提是不影响用户体验。\n\n这方面可以减少的通信消耗，其中一个方面是频繁的事件通信，我们知道，事件的触发是在 native 端的，但是事件处理的逻辑代码实际上是在 js 层来完成的，在这方面的通信，React Native 就因为频繁的通信从而影响了性能。\n\n我们可以优化的地方在于，首先减少没有绑定回调函数的事件通信，一般而言这部分通信是不必要的，其次是多次通信可以进行合并，比如说 list 滚动回调函数、以及动画通信，我们可以通过配置驱动代替数据驱动的方式（即一次向客户端传递整个配置，后续相同事件可以直接在客户端进行处理），来减少通信次数。\n\n这方面 Hippy 和 Weex 都有大量细碎的实践，在此便不具体介绍了。\n\n#### 降低首屏时间\n\n在原来的 WebView 页面中，我们为了增强用户体验，防止用户进来之后看到白屏，可以采用服务端渲染的方式，将渲染好的页面返回给客户端，同时优化了首屏请求，也防止了客户端设备较差造成JS执行时间较长的情况。\n\n在跨端融合方案中我们仍然有类似的解决方案，在不考虑离线包的情况下（即只考虑业务代码从远程加载的情况），我们也可以由服务端渲染好再返回，Weex 便采用了类似的方案，不过其做的更加彻底，在服务端将代码结果编译成 AST 树并转化成字节码（OPcode），在客户端解析后直接生成虚拟 DOM：\n\n![](/img/2.jpg)\n\n>图片来自 IMWeb 2018\n\n#### 客户端级别的其他优化\n\n客户端的优化有一部分是本来客户端开发就会面临的内容，也有一部分是和混合方案有关的优化，比如 Flex Render 的优化，不过这方面的内容一般而言和前端关系不是非常密切，笔者作为初级前端工程师，对这方面的内容还并不熟悉。\n\n### 框架选型\n\n本文的最后一部分，介绍框架选型。\n\n对于各类跨端融合的方案，其相对于 WebView 都有非常大的性能提升，因此在前期，无论选择什么框架都能够看到成效，这里也并不进行特定的框架选型推荐，但是一般认为，如果是从 Vue 的项目切换，Weex 会更合适一点，而如果从 React 项目切换，在确保没有证书风险的情况下可以采用 React Native，否则可以尝试原生支持 React 的 Hippy。\n\n以上。\n\n\n","slug":"web跨端融合方案浅析","published":1,"updated":"2021-12-23T05:50:07.542Z","_id":"ckxijpqst000nd3mraqkzfdrg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文会对目前流行的基于 JavaScript 的 web 跨端融合方案进行总结和分析，目标人群为 web 方向的从业者但是对跨端融合方案了解不多的人。</p>\n<h3 id=\"web-跨端融合简介\"><a href=\"#web-跨端融合简介\" class=\"headerlink\" title=\"web 跨端融合简介\"></a>web 跨端融合简介</h3><p>在 2015 年 React Native 发布之前，web 在移动端 APP 上主要通过 WebView 进行承载，其有许多优点，可以快速迭代发布，不特别受 APP 版本的影响，因此，一些快速发展的业务（包括前期的手机QQ、手机淘宝）大量采用了 WebView 内嵌 H5 页面的形式来推动业务。</p>\n<p>但是这种方式缺点也比较明显，主要体现在以下两点：</p>\n<ul>\n<li>加载时间较长，包括 WebView 初始化的时间、网络请求的时间。</li>\n<li>HTML 页面在性能上天然不如 Native 页面，无论怎么进行性能优化。</li>\n</ul>\n<p>在 2015 年，Facebook 推出了 React Native，从而打开了 web 跨端融合的大门，后续在此架构基础上又出现了阿里巴巴的 Weex（2016）、腾讯的小程序（小程序实际上更偏 web 一点，和其他几类稍有不同，本文不作介绍）、 Hippy（2018）、Taro（Taro 其实更偏向解释翻译，和其他几类定位不同）等跨端融合解决方案，并且渐渐被用到越来越多的项目中，目前，跨端融合开发已经是一种比较主流的 web 开发模式，在阿里系应用、腾讯的微信、QQ浏览器、手机QQ均已经进行了大规模应用。</p>\n<h3 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h3><p>虽然 web 跨端融合方案众多，除了上述提到的三种，还有各个公司的更多方案，但是一般来说跨端融合的技术架构都比较相近，我们可以通过下面这一个图来简单概括：</p>\n<p><img src=\"/img/1.jpg\"></p>\n<p>接下来，我们逐个进行简析：</p>\n<ul>\n<li>业务代码：即我们写的 React Native 代码、Weex 代码，一般来说，我们的业务代码需要经过框架工具或者打包工具（例如 webpack 配合 loader）进行打包，从而兼容一些 ES Next 的写法以及一些框架本身不支持的 Web 写法。</li>\n<li>Javascript FrameWork：这部分主要是针对 Weex、Hippy 来讲的，Weex 声称支持 Vue、Rax 语法，而 Hippy 声称支持 React、Vue 写法，实际上，对于这些库而言，并不是直接将 React、Vue 引入到项目中，而是会对其源代码进行修改（Vue 有针对 Weex 平台的<a href=\"https://github.com/vuejs/vue/tree/dev/src/platforms\">版本</a>），而 Hippy 也是对 React 源代码进行了修改，例如，你写的一个<code>createElement</code>的操作，在 Web 平台中实际调用的是 <code>document.createElement(tagName) </code>这个接口；而在 Weex 平台中实际执行的是<code> new renderer.Element(tagName)</code>（renderer 由 Javascript Runtime 提供，并且最终和 Native 通信渲染上屏）。</li>\n<li>Javascript Runtime：Runtime 的部分，主要是对外暴露了一些统一的接口，比如说节点的增删改查、网络请求的接口等，而这些借口，实际上是其“代理”的客户端的能力，通过客户端 JSAPI 的方式进行调用。另外，把 Runtime 和 FrameWork 进行抽离，也可以便于一个跨端方案适配多个框架，只需要将不同的 FrameWork 和浏览器交互的部分代码转换成 Runtime 提供的标准接口，就可以实现对不同框架的支持。</li>\n<li>Core：这部分主要是对 Javascript 的解释执行，在 iOS 上一般是 JSCore（系统自带，给客户端提供了执行 JavaScript 程序的能力），而安卓上则可以采用 V8、X5 等。</li>\n<li>最下层则是分 Android 和 iOS 端去进行渲染。</li>\n</ul>\n<h3 id=\"发展现状\"><a href=\"#发展现状\" class=\"headerlink\" title=\"发展现状\"></a>发展现状</h3><p>实际上，React Native 最初提出这种解决方案的时候，市面上并没有同类的产品，但是由于 React Native 的一些问题和其他原因，各个大公司基本都在实现自己的跨端融合方案，这里 React Native 的问题主要体现在：</p>\n<ul>\n<li>最主要的是协议风险。</li>\n<li>React Native 打包出来的 JSBundle 较大，并且默认没有灵活的分包机制，需要自行解决相关问题。</li>\n<li>在部分组件比如 List 组件中，性能较差（据非官方说法，性能并不是 React Native 团队首要考察因素，但是国内团队一般都比较重视性能）。</li>\n<li>部分事件发送频繁导致性能损失、例如列表滚动事件、手势事件等。</li>\n<li>双端 API 大量没有对齐（这也和其 slogan 是‘learn once, write everywhere’ 而不是 ‘write once, run everywhere’ 相对应）。</li>\n</ul>\n<p>而对于国内的 Weex 和 Hippy 框架，其都做了大量的性能优化解决了上述问题，并且规避了协议风险（Weex 采用了 Apache 2.0 协议，而 Hippy 即将开源）。</p>\n<p>另外值得一提的是，Weex 和 Hippy 都可以在 web 端进行运行，一般可以作为降级方案使用，从而真正做到了“一份代码”，三端运行。</p>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p>实际上，采用目前的跨端融合方案的体验已经比采用 WebView 的方案强太多了，但是性能优化是没有止境的，随着页面复杂度的提高以及用户体验的要求，实际上目前这类跨端融合方案采用了以下几个方向的性能和用户体验优化：</p>\n<h4 id=\"减少网络请求\"><a href=\"#减少网络请求\" class=\"headerlink\" title=\"减少网络请求\"></a>减少网络请求</h4><p>在我们上述提供的架构图中，一般而言对于一个这类页面，业务代码是通过网络请求加载的，这个时候在加载上主要省去的是 WebView 的初始化时间，这其实是不够的，所以我们也可以采用将业务代码提前下发并存在用户本地，打开的时候只需要从本地拉取并执行代码，这样可以减少相关的网络请求阻塞，优化加载时间。</p>\n<p>另外，减少网络请求还体现在对资源的缓存上，对一个页面中所采用的图片等资源文件进行 LRU 策略的缓存，从而防止重复的请求（在传统的 WebView 的方案上，也可以采用对 WebView 增加 Hook 的方式实现）。</p>\n<p>当然，以上两点在 WebView 的方案上也可以采用。</p>\n<h4 id=\"降低通信成本\"><a href=\"#降低通信成本\" class=\"headerlink\" title=\"降低通信成本\"></a>降低通信成本</h4><p>我们从上文的架构图中可以看出，这里的层级实际上比较多，如果不同层级的通信数据较多，并且有比较频繁甚至重复的编解码操作，肯定会有很大的开销，从而影响性能，所以，在不同层级之间做好数据的传递，并且防止重复的编解码操作是比较重要的。</p>\n<p>这里可以优化的细节其实比较多，我们举一个 Hippy 的例子：</p>\n<p>在 Hippy 架构中，jsRuntime 会生成一个 jsObject 对象树（即需要渲染的 DOM 信息），其在经过 JSBridge 时需要通过<code>JSON.stringify</code> 进行序列化，而在 Java（andriod) 接收端，则需要先将其变成一个 JsonObject，最终转化成 HippyMap，这里实际上是有重复的编解码操作的，我们看看 Hippy 的优化策略：</p>\n<p><img src=\"/img/3.jpg\"></p>\n<blockquote>\n<p>图片来自 IMWeb 2018</p>\n</blockquote>\n<p>通过 hippybuffer 的方式减少通信的数据量，并且防止重复的编解码操作，可以有效提高性能。</p>\n<h4 id=\"减少通信次数\"><a href=\"#减少通信次数\" class=\"headerlink\" title=\"减少通信次数\"></a>减少通信次数</h4><p>为了减少在通信方面的消耗，我们除了降低通信的成本，还可以做的就是减少通信次数，当然，前提是不影响用户体验。</p>\n<p>这方面可以减少的通信消耗，其中一个方面是频繁的事件通信，我们知道，事件的触发是在 native 端的，但是事件处理的逻辑代码实际上是在 js 层来完成的，在这方面的通信，React Native 就因为频繁的通信从而影响了性能。</p>\n<p>我们可以优化的地方在于，首先减少没有绑定回调函数的事件通信，一般而言这部分通信是不必要的，其次是多次通信可以进行合并，比如说 list 滚动回调函数、以及动画通信，我们可以通过配置驱动代替数据驱动的方式（即一次向客户端传递整个配置，后续相同事件可以直接在客户端进行处理），来减少通信次数。</p>\n<p>这方面 Hippy 和 Weex 都有大量细碎的实践，在此便不具体介绍了。</p>\n<h4 id=\"降低首屏时间\"><a href=\"#降低首屏时间\" class=\"headerlink\" title=\"降低首屏时间\"></a>降低首屏时间</h4><p>在原来的 WebView 页面中，我们为了增强用户体验，防止用户进来之后看到白屏，可以采用服务端渲染的方式，将渲染好的页面返回给客户端，同时优化了首屏请求，也防止了客户端设备较差造成JS执行时间较长的情况。</p>\n<p>在跨端融合方案中我们仍然有类似的解决方案，在不考虑离线包的情况下（即只考虑业务代码从远程加载的情况），我们也可以由服务端渲染好再返回，Weex 便采用了类似的方案，不过其做的更加彻底，在服务端将代码结果编译成 AST 树并转化成字节码（OPcode），在客户端解析后直接生成虚拟 DOM：</p>\n<p><img src=\"/img/2.jpg\"></p>\n<blockquote>\n<p>图片来自 IMWeb 2018</p>\n</blockquote>\n<h4 id=\"客户端级别的其他优化\"><a href=\"#客户端级别的其他优化\" class=\"headerlink\" title=\"客户端级别的其他优化\"></a>客户端级别的其他优化</h4><p>客户端的优化有一部分是本来客户端开发就会面临的内容，也有一部分是和混合方案有关的优化，比如 Flex Render 的优化，不过这方面的内容一般而言和前端关系不是非常密切，笔者作为初级前端工程师，对这方面的内容还并不熟悉。</p>\n<h3 id=\"框架选型\"><a href=\"#框架选型\" class=\"headerlink\" title=\"框架选型\"></a>框架选型</h3><p>本文的最后一部分，介绍框架选型。</p>\n<p>对于各类跨端融合的方案，其相对于 WebView 都有非常大的性能提升，因此在前期，无论选择什么框架都能够看到成效，这里也并不进行特定的框架选型推荐，但是一般认为，如果是从 Vue 的项目切换，Weex 会更合适一点，而如果从 React 项目切换，在确保没有证书风险的情况下可以采用 React Native，否则可以尝试原生支持 React 的 Hippy。</p>\n<p>以上。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文会对目前流行的基于 JavaScript 的 web 跨端融合方案进行总结和分析，目标人群为 web 方向的从业者但是对跨端融合方案了解不多的人。</p>\n<h3 id=\"web-跨端融合简介\"><a href=\"#web-跨端融合简介\" class=\"headerlink\" title=\"web 跨端融合简介\"></a>web 跨端融合简介</h3><p>在 2015 年 React Native 发布之前，web 在移动端 APP 上主要通过 WebView 进行承载，其有许多优点，可以快速迭代发布，不特别受 APP 版本的影响，因此，一些快速发展的业务（包括前期的手机QQ、手机淘宝）大量采用了 WebView 内嵌 H5 页面的形式来推动业务。</p>\n<p>但是这种方式缺点也比较明显，主要体现在以下两点：</p>\n<ul>\n<li>加载时间较长，包括 WebView 初始化的时间、网络请求的时间。</li>\n<li>HTML 页面在性能上天然不如 Native 页面，无论怎么进行性能优化。</li>\n</ul>\n<p>在 2015 年，Facebook 推出了 React Native，从而打开了 web 跨端融合的大门，后续在此架构基础上又出现了阿里巴巴的 Weex（2016）、腾讯的小程序（小程序实际上更偏 web 一点，和其他几类稍有不同，本文不作介绍）、 Hippy（2018）、Taro（Taro 其实更偏向解释翻译，和其他几类定位不同）等跨端融合解决方案，并且渐渐被用到越来越多的项目中，目前，跨端融合开发已经是一种比较主流的 web 开发模式，在阿里系应用、腾讯的微信、QQ浏览器、手机QQ均已经进行了大规模应用。</p>\n<h3 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h3><p>虽然 web 跨端融合方案众多，除了上述提到的三种，还有各个公司的更多方案，但是一般来说跨端融合的技术架构都比较相近，我们可以通过下面这一个图来简单概括：</p>\n<p><img src=\"/img/1.jpg\"></p>\n<p>接下来，我们逐个进行简析：</p>\n<ul>\n<li>业务代码：即我们写的 React Native 代码、Weex 代码，一般来说，我们的业务代码需要经过框架工具或者打包工具（例如 webpack 配合 loader）进行打包，从而兼容一些 ES Next 的写法以及一些框架本身不支持的 Web 写法。</li>\n<li>Javascript FrameWork：这部分主要是针对 Weex、Hippy 来讲的，Weex 声称支持 Vue、Rax 语法，而 Hippy 声称支持 React、Vue 写法，实际上，对于这些库而言，并不是直接将 React、Vue 引入到项目中，而是会对其源代码进行修改（Vue 有针对 Weex 平台的<a href=\"https://github.com/vuejs/vue/tree/dev/src/platforms\">版本</a>），而 Hippy 也是对 React 源代码进行了修改，例如，你写的一个<code>createElement</code>的操作，在 Web 平台中实际调用的是 <code>document.createElement(tagName) </code>这个接口；而在 Weex 平台中实际执行的是<code> new renderer.Element(tagName)</code>（renderer 由 Javascript Runtime 提供，并且最终和 Native 通信渲染上屏）。</li>\n<li>Javascript Runtime：Runtime 的部分，主要是对外暴露了一些统一的接口，比如说节点的增删改查、网络请求的接口等，而这些借口，实际上是其“代理”的客户端的能力，通过客户端 JSAPI 的方式进行调用。另外，把 Runtime 和 FrameWork 进行抽离，也可以便于一个跨端方案适配多个框架，只需要将不同的 FrameWork 和浏览器交互的部分代码转换成 Runtime 提供的标准接口，就可以实现对不同框架的支持。</li>\n<li>Core：这部分主要是对 Javascript 的解释执行，在 iOS 上一般是 JSCore（系统自带，给客户端提供了执行 JavaScript 程序的能力），而安卓上则可以采用 V8、X5 等。</li>\n<li>最下层则是分 Android 和 iOS 端去进行渲染。</li>\n</ul>\n<h3 id=\"发展现状\"><a href=\"#发展现状\" class=\"headerlink\" title=\"发展现状\"></a>发展现状</h3><p>实际上，React Native 最初提出这种解决方案的时候，市面上并没有同类的产品，但是由于 React Native 的一些问题和其他原因，各个大公司基本都在实现自己的跨端融合方案，这里 React Native 的问题主要体现在：</p>\n<ul>\n<li>最主要的是协议风险。</li>\n<li>React Native 打包出来的 JSBundle 较大，并且默认没有灵活的分包机制，需要自行解决相关问题。</li>\n<li>在部分组件比如 List 组件中，性能较差（据非官方说法，性能并不是 React Native 团队首要考察因素，但是国内团队一般都比较重视性能）。</li>\n<li>部分事件发送频繁导致性能损失、例如列表滚动事件、手势事件等。</li>\n<li>双端 API 大量没有对齐（这也和其 slogan 是‘learn once, write everywhere’ 而不是 ‘write once, run everywhere’ 相对应）。</li>\n</ul>\n<p>而对于国内的 Weex 和 Hippy 框架，其都做了大量的性能优化解决了上述问题，并且规避了协议风险（Weex 采用了 Apache 2.0 协议，而 Hippy 即将开源）。</p>\n<p>另外值得一提的是，Weex 和 Hippy 都可以在 web 端进行运行，一般可以作为降级方案使用，从而真正做到了“一份代码”，三端运行。</p>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p>实际上，采用目前的跨端融合方案的体验已经比采用 WebView 的方案强太多了，但是性能优化是没有止境的，随着页面复杂度的提高以及用户体验的要求，实际上目前这类跨端融合方案采用了以下几个方向的性能和用户体验优化：</p>\n<h4 id=\"减少网络请求\"><a href=\"#减少网络请求\" class=\"headerlink\" title=\"减少网络请求\"></a>减少网络请求</h4><p>在我们上述提供的架构图中，一般而言对于一个这类页面，业务代码是通过网络请求加载的，这个时候在加载上主要省去的是 WebView 的初始化时间，这其实是不够的，所以我们也可以采用将业务代码提前下发并存在用户本地，打开的时候只需要从本地拉取并执行代码，这样可以减少相关的网络请求阻塞，优化加载时间。</p>\n<p>另外，减少网络请求还体现在对资源的缓存上，对一个页面中所采用的图片等资源文件进行 LRU 策略的缓存，从而防止重复的请求（在传统的 WebView 的方案上，也可以采用对 WebView 增加 Hook 的方式实现）。</p>\n<p>当然，以上两点在 WebView 的方案上也可以采用。</p>\n<h4 id=\"降低通信成本\"><a href=\"#降低通信成本\" class=\"headerlink\" title=\"降低通信成本\"></a>降低通信成本</h4><p>我们从上文的架构图中可以看出，这里的层级实际上比较多，如果不同层级的通信数据较多，并且有比较频繁甚至重复的编解码操作，肯定会有很大的开销，从而影响性能，所以，在不同层级之间做好数据的传递，并且防止重复的编解码操作是比较重要的。</p>\n<p>这里可以优化的细节其实比较多，我们举一个 Hippy 的例子：</p>\n<p>在 Hippy 架构中，jsRuntime 会生成一个 jsObject 对象树（即需要渲染的 DOM 信息），其在经过 JSBridge 时需要通过<code>JSON.stringify</code> 进行序列化，而在 Java（andriod) 接收端，则需要先将其变成一个 JsonObject，最终转化成 HippyMap，这里实际上是有重复的编解码操作的，我们看看 Hippy 的优化策略：</p>\n<p><img src=\"/img/3.jpg\"></p>\n<blockquote>\n<p>图片来自 IMWeb 2018</p>\n</blockquote>\n<p>通过 hippybuffer 的方式减少通信的数据量，并且防止重复的编解码操作，可以有效提高性能。</p>\n<h4 id=\"减少通信次数\"><a href=\"#减少通信次数\" class=\"headerlink\" title=\"减少通信次数\"></a>减少通信次数</h4><p>为了减少在通信方面的消耗，我们除了降低通信的成本，还可以做的就是减少通信次数，当然，前提是不影响用户体验。</p>\n<p>这方面可以减少的通信消耗，其中一个方面是频繁的事件通信，我们知道，事件的触发是在 native 端的，但是事件处理的逻辑代码实际上是在 js 层来完成的，在这方面的通信，React Native 就因为频繁的通信从而影响了性能。</p>\n<p>我们可以优化的地方在于，首先减少没有绑定回调函数的事件通信，一般而言这部分通信是不必要的，其次是多次通信可以进行合并，比如说 list 滚动回调函数、以及动画通信，我们可以通过配置驱动代替数据驱动的方式（即一次向客户端传递整个配置，后续相同事件可以直接在客户端进行处理），来减少通信次数。</p>\n<p>这方面 Hippy 和 Weex 都有大量细碎的实践，在此便不具体介绍了。</p>\n<h4 id=\"降低首屏时间\"><a href=\"#降低首屏时间\" class=\"headerlink\" title=\"降低首屏时间\"></a>降低首屏时间</h4><p>在原来的 WebView 页面中，我们为了增强用户体验，防止用户进来之后看到白屏，可以采用服务端渲染的方式，将渲染好的页面返回给客户端，同时优化了首屏请求，也防止了客户端设备较差造成JS执行时间较长的情况。</p>\n<p>在跨端融合方案中我们仍然有类似的解决方案，在不考虑离线包的情况下（即只考虑业务代码从远程加载的情况），我们也可以由服务端渲染好再返回，Weex 便采用了类似的方案，不过其做的更加彻底，在服务端将代码结果编译成 AST 树并转化成字节码（OPcode），在客户端解析后直接生成虚拟 DOM：</p>\n<p><img src=\"/img/2.jpg\"></p>\n<blockquote>\n<p>图片来自 IMWeb 2018</p>\n</blockquote>\n<h4 id=\"客户端级别的其他优化\"><a href=\"#客户端级别的其他优化\" class=\"headerlink\" title=\"客户端级别的其他优化\"></a>客户端级别的其他优化</h4><p>客户端的优化有一部分是本来客户端开发就会面临的内容，也有一部分是和混合方案有关的优化，比如 Flex Render 的优化，不过这方面的内容一般而言和前端关系不是非常密切，笔者作为初级前端工程师，对这方面的内容还并不熟悉。</p>\n<h3 id=\"框架选型\"><a href=\"#框架选型\" class=\"headerlink\" title=\"框架选型\"></a>框架选型</h3><p>本文的最后一部分，介绍框架选型。</p>\n<p>对于各类跨端融合的方案，其相对于 WebView 都有非常大的性能提升，因此在前期，无论选择什么框架都能够看到成效，这里也并不进行特定的框架选型推荐，但是一般认为，如果是从 Vue 的项目切换，Weex 会更合适一点，而如果从 React 项目切换，在确保没有证书风险的情况下可以采用 React Native，否则可以尝试原生支持 React 的 Hippy。</p>\n<p>以上。</p>\n"},{"title":"一些性能相关的 JavaScript 代码编写建议规范","abbrlink":1657189574,"date":"2021-08-29T05:59:00.000Z","_content":"\n本文对一些日常编写 JavaScript 的过程中，一些有助于提高代码性能的规范进行罗列。\n\n> 本文比较零碎，不作为规范提议，仅作为交流参考。\n\n### 1. 使用解构赋值，减少中间变量。\n\n对于一些比如变量替换的场景，我们使用解构赋值，可以省略中间变量，整体代码也会更加清晰。\n\n```\nlet a = 3;\nlet b = 4;\n[b, a] = [a, b];\n```\n\n### 2. 通过条件判断提前返回\n\n这里主要是提醒大家如何写好 if 语句。\n\n实际上， 在编写复杂的 if 语句之前，我们应该考虑是否可以**逻辑外化**：\n\n即尽可能的将代码的复杂逻辑向外推，例如抽离成多个函数，而不是在程序里面进行过多判断。有一种比较典型的不合理的重用是把大量的逻辑都堆叠到一个函数里面，然后提供一个很复杂的功能。我认为更好的做法应当是分离成更多的模块。\n\n经过以上思考之后，我们可能还有一些 if 语句，一般的原则是：\n\n* if 语句先简单，后复杂。\n* if 语句，可以提前返回即提前返回，减少复杂的嵌套。\n\n```\n// nice:\nif (condition1) {\n  // do something\n  return;\n}\n\nif (condition2) {\n  // do something\n  return;\n}\n\nother_function();\n\n// bad:\nif (condition1) {\n  // do something\n} else {\n  if (condition2) {\n    // do something\n  } else {\n    other_function();\n  }\n}\n```\n\n### 3. 尽量避免在循环体内包裹函数表达式\n\n函数表达式会生成对应的函数对象，如果我们在循环体内去做这个事情，很可能会造成额外的浪费。\n\n```\n// nice:\nfunction callback() {\n}\n\nconst len = nodelist.length;\nfor(let i = 0; i < len; i += 1) {\n  addListener(nodelist[i], callback);\n}\n\n// bad:\nfor(let i = 0; i < nodelist.length; i += 1) {\n  addListener(nodelist[i], function() {});\n}\n```\n\n### 4. 对循环体内的不变值，在循环体外使用缓存\n\n这一条其实是对上一条的补充，实际上是同样的原理，即希望我们在循环体内尽量保持逻辑的简单，减少重复的 cpu 时间和内存的消耗。\n\n### 5. 清空数组使用 .length = 0\n\n这样写可以方便我们清空一个 const 数组。\n\n```\nconst a = [1,2,3,4];\n// 如果使用 a = [] 会报错\na.length = 0;\n```\n\n### 6. 不得为了编写方便，将并行的 io 串行化\n\n虽然现在 JavaScript 有了 async/await，但是我发现很多同学会对此滥用，一个很常见的清空就是将可以并行的操作串行化了:\n\n```\nlet res1 = await process1();\nlet res2 = await process2();\nnext(res1, res2);\n```\n\n这个时候，虽然写代码方便，但是这样写是不可取的，Promise 提供了若干的方便我们处理并行任务的[方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise#)，我认为这些都是必须要了解的。\n\n\n### 7. 禁止直接使用 eval\n\neval 的安全性非常差，事实上有很多已知的 xss 等漏洞都和 eval 有关，所以我们在实际场景中避免使用 eval。\n\n如下为一个例子，使用了 eval 函数，由于其执行代码的作用域为本地作用域，所以对我们的本地变量进行了修改并且可以生效：\n\n```\nlet tip = \"请重新登录\"\nlet otherCode = `tip = \"请前往 xxx.com 重新登录\"`\neval(otherCode);\n```\n\n一些取代方式：\n\n我们可以使用 `new Function` 的方式来代替 eval，这样至少可以进行作用域的隔离，相对会安全一些（但是请注意其仍然会可能影响到全局变量）。\n\n### 8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll\n\n类似的 all 相关操作都要避免使用，由于我们很难控制随着项目发展内容会有多少，所以我们最好一开始就不要留下随着项目内容增加性能越来越差的隐患。\n\n### 9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle\n\n通过 style 只能获得内联定义或通过 JavaScript 直接定义的样式，通过 CSS class 设置的样式无法直接获取。\n\n### 10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。\n\n直接操作 style，会比较混乱，而且有的时候还会忘记写单位，导致实际上不管用。\n\n","source":"_posts/一些性能相关的 JavaScript 代码编写建议规范.md","raw":"---\ntitle: 一些性能相关的 JavaScript 代码编写建议规范\ntags:\n  - javascript\nabbrlink: 1657189574\ndate: 2021-08-29 13:59:00\n---\n\n本文对一些日常编写 JavaScript 的过程中，一些有助于提高代码性能的规范进行罗列。\n\n> 本文比较零碎，不作为规范提议，仅作为交流参考。\n\n### 1. 使用解构赋值，减少中间变量。\n\n对于一些比如变量替换的场景，我们使用解构赋值，可以省略中间变量，整体代码也会更加清晰。\n\n```\nlet a = 3;\nlet b = 4;\n[b, a] = [a, b];\n```\n\n### 2. 通过条件判断提前返回\n\n这里主要是提醒大家如何写好 if 语句。\n\n实际上， 在编写复杂的 if 语句之前，我们应该考虑是否可以**逻辑外化**：\n\n即尽可能的将代码的复杂逻辑向外推，例如抽离成多个函数，而不是在程序里面进行过多判断。有一种比较典型的不合理的重用是把大量的逻辑都堆叠到一个函数里面，然后提供一个很复杂的功能。我认为更好的做法应当是分离成更多的模块。\n\n经过以上思考之后，我们可能还有一些 if 语句，一般的原则是：\n\n* if 语句先简单，后复杂。\n* if 语句，可以提前返回即提前返回，减少复杂的嵌套。\n\n```\n// nice:\nif (condition1) {\n  // do something\n  return;\n}\n\nif (condition2) {\n  // do something\n  return;\n}\n\nother_function();\n\n// bad:\nif (condition1) {\n  // do something\n} else {\n  if (condition2) {\n    // do something\n  } else {\n    other_function();\n  }\n}\n```\n\n### 3. 尽量避免在循环体内包裹函数表达式\n\n函数表达式会生成对应的函数对象，如果我们在循环体内去做这个事情，很可能会造成额外的浪费。\n\n```\n// nice:\nfunction callback() {\n}\n\nconst len = nodelist.length;\nfor(let i = 0; i < len; i += 1) {\n  addListener(nodelist[i], callback);\n}\n\n// bad:\nfor(let i = 0; i < nodelist.length; i += 1) {\n  addListener(nodelist[i], function() {});\n}\n```\n\n### 4. 对循环体内的不变值，在循环体外使用缓存\n\n这一条其实是对上一条的补充，实际上是同样的原理，即希望我们在循环体内尽量保持逻辑的简单，减少重复的 cpu 时间和内存的消耗。\n\n### 5. 清空数组使用 .length = 0\n\n这样写可以方便我们清空一个 const 数组。\n\n```\nconst a = [1,2,3,4];\n// 如果使用 a = [] 会报错\na.length = 0;\n```\n\n### 6. 不得为了编写方便，将并行的 io 串行化\n\n虽然现在 JavaScript 有了 async/await，但是我发现很多同学会对此滥用，一个很常见的清空就是将可以并行的操作串行化了:\n\n```\nlet res1 = await process1();\nlet res2 = await process2();\nnext(res1, res2);\n```\n\n这个时候，虽然写代码方便，但是这样写是不可取的，Promise 提供了若干的方便我们处理并行任务的[方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise#)，我认为这些都是必须要了解的。\n\n\n### 7. 禁止直接使用 eval\n\neval 的安全性非常差，事实上有很多已知的 xss 等漏洞都和 eval 有关，所以我们在实际场景中避免使用 eval。\n\n如下为一个例子，使用了 eval 函数，由于其执行代码的作用域为本地作用域，所以对我们的本地变量进行了修改并且可以生效：\n\n```\nlet tip = \"请重新登录\"\nlet otherCode = `tip = \"请前往 xxx.com 重新登录\"`\neval(otherCode);\n```\n\n一些取代方式：\n\n我们可以使用 `new Function` 的方式来代替 eval，这样至少可以进行作用域的隔离，相对会安全一些（但是请注意其仍然会可能影响到全局变量）。\n\n### 8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll\n\n类似的 all 相关操作都要避免使用，由于我们很难控制随着项目发展内容会有多少，所以我们最好一开始就不要留下随着项目内容增加性能越来越差的隐患。\n\n### 9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle\n\n通过 style 只能获得内联定义或通过 JavaScript 直接定义的样式，通过 CSS class 设置的样式无法直接获取。\n\n### 10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。\n\n直接操作 style，会比较混乱，而且有的时候还会忘记写单位，导致实际上不管用。\n\n","slug":"一些性能相关的 JavaScript 代码编写建议规范","published":1,"updated":"2021-12-23T05:50:07.543Z","_id":"ckxijpqsv000pd3mrbtcv3ryi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文对一些日常编写 JavaScript 的过程中，一些有助于提高代码性能的规范进行罗列。</p>\n<blockquote>\n<p>本文比较零碎，不作为规范提议，仅作为交流参考。</p>\n</blockquote>\n<h3 id=\"1-使用解构赋值，减少中间变量。\"><a href=\"#1-使用解构赋值，减少中间变量。\" class=\"headerlink\" title=\"1. 使用解构赋值，减少中间变量。\"></a>1. 使用解构赋值，减少中间变量。</h3><p>对于一些比如变量替换的场景，我们使用解构赋值，可以省略中间变量，整体代码也会更加清晰。</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span> = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">b</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">[b, a] = [a, b];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-通过条件判断提前返回\"><a href=\"#2-通过条件判断提前返回\" class=\"headerlink\" title=\"2. 通过条件判断提前返回\"></a>2. 通过条件判断提前返回</h3><p>这里主要是提醒大家如何写好 if 语句。</p>\n<p>实际上， 在编写复杂的 if 语句之前，我们应该考虑是否可以<strong>逻辑外化</strong>：</p>\n<p>即尽可能的将代码的复杂逻辑向外推，例如抽离成多个函数，而不是在程序里面进行过多判断。有一种比较典型的不合理的重用是把大量的逻辑都堆叠到一个函数里面，然后提供一个很复杂的功能。我认为更好的做法应当是分离成更多的模块。</p>\n<p>经过以上思考之后，我们可能还有一些 if 语句，一般的原则是：</p>\n<ul>\n<li>if 语句先简单，后复杂。</li>\n<li>if 语句，可以提前返回即提前返回，减少复杂的嵌套。</li>\n</ul>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> nice:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (condition1) &#123;</span><br><span class=\"line\">  <span class=\"regexp\">//</span> <span class=\"keyword\">do</span> something</span><br><span class=\"line\">  return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (condition2) &#123;</span><br><span class=\"line\">  <span class=\"regexp\">//</span> <span class=\"keyword\">do</span> something</span><br><span class=\"line\">  return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">other_function();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span> bad:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (condition1) &#123;</span><br><span class=\"line\">  <span class=\"regexp\">//</span> <span class=\"keyword\">do</span> something</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (condition2) &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span> <span class=\"keyword\">do</span> something</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    other_function();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-尽量避免在循环体内包裹函数表达式\"><a href=\"#3-尽量避免在循环体内包裹函数表达式\" class=\"headerlink\" title=\"3. 尽量避免在循环体内包裹函数表达式\"></a>3. 尽量避免在循环体内包裹函数表达式</h3><p>函数表达式会生成对应的函数对象，如果我们在循环体内去做这个事情，很可能会造成额外的浪费。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// nice:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callback</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> len = nodelist.length;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  addListener(nodelist[i], callback);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bad:</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nodelist.length; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  addListener(nodelist[i], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-对循环体内的不变值，在循环体外使用缓存\"><a href=\"#4-对循环体内的不变值，在循环体外使用缓存\" class=\"headerlink\" title=\"4. 对循环体内的不变值，在循环体外使用缓存\"></a>4. 对循环体内的不变值，在循环体外使用缓存</h3><p>这一条其实是对上一条的补充，实际上是同样的原理，即希望我们在循环体内尽量保持逻辑的简单，减少重复的 cpu 时间和内存的消耗。</p>\n<h3 id=\"5-清空数组使用-length-0\"><a href=\"#5-清空数组使用-length-0\" class=\"headerlink\" title=\"5. 清空数组使用 .length = 0\"></a>5. 清空数组使用 .length = 0</h3><p>这样写可以方便我们清空一个 const 数组。</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">// 如果使用 a = [] 会报错</span></span><br><span class=\"line\">a.<span class=\"built_in\">length</span> = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-不得为了编写方便，将并行的-io-串行化\"><a href=\"#6-不得为了编写方便，将并行的-io-串行化\" class=\"headerlink\" title=\"6. 不得为了编写方便，将并行的 io 串行化\"></a>6. 不得为了编写方便，将并行的 io 串行化</h3><p>虽然现在 JavaScript 有了 async/await，但是我发现很多同学会对此滥用，一个很常见的清空就是将可以并行的操作串行化了:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">let</span> res<span class=\"number\">1</span> = await process<span class=\"number\">1</span>();</span><br><span class=\"line\"><span class=\"attribute\">let</span> res<span class=\"number\">2</span> = await process<span class=\"number\">2</span>();</span><br><span class=\"line\"><span class=\"attribute\">next</span>(res<span class=\"number\">1</span>, res<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，虽然写代码方便，但是这样写是不可取的，Promise 提供了若干的方便我们处理并行任务的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise#\">方法</a>，我认为这些都是必须要了解的。</p>\n<h3 id=\"7-禁止直接使用-eval\"><a href=\"#7-禁止直接使用-eval\" class=\"headerlink\" title=\"7. 禁止直接使用 eval\"></a>7. 禁止直接使用 eval</h3><p>eval 的安全性非常差，事实上有很多已知的 xss 等漏洞都和 eval 有关，所以我们在实际场景中避免使用 eval。</p>\n<p>如下为一个例子，使用了 eval 函数，由于其执行代码的作用域为本地作用域，所以对我们的本地变量进行了修改并且可以生效：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">tip</span> = <span class=\"string\">&quot;请重新登录&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">otherCode</span> = `<span class=\"attr\">tip</span> = <span class=\"string\">&quot;请前往 xxx.com 重新登录&quot;</span>`</span><br><span class=\"line\">eval(otherCode);</span><br></pre></td></tr></table></figure>\n\n<p>一些取代方式：</p>\n<p>我们可以使用 <code>new Function</code> 的方式来代替 eval，这样至少可以进行作用域的隔离，相对会安全一些（但是请注意其仍然会可能影响到全局变量）。</p>\n<h3 id=\"8-浏览器环境中，尽量避免使用-document-all、document-querySelectorAll\"><a href=\"#8-浏览器环境中，尽量避免使用-document-all、document-querySelectorAll\" class=\"headerlink\" title=\"8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll\"></a>8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll</h3><p>类似的 all 相关操作都要避免使用，由于我们很难控制随着项目发展内容会有多少，所以我们最好一开始就不要留下随着项目内容增加性能越来越差的隐患。</p>\n<h3 id=\"9-获取元素的样式，尽量使用-getComputedStyle-或-currentStyle\"><a href=\"#9-获取元素的样式，尽量使用-getComputedStyle-或-currentStyle\" class=\"headerlink\" title=\"9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle\"></a>9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle</h3><p>通过 style 只能获得内联定义或通过 JavaScript 直接定义的样式，通过 CSS class 设置的样式无法直接获取。</p>\n<h3 id=\"10-尽可能通过为元素添加预定义的-ClassName-来改变元素样式，避免直接操作-style-进行设置。\"><a href=\"#10-尽可能通过为元素添加预定义的-ClassName-来改变元素样式，避免直接操作-style-进行设置。\" class=\"headerlink\" title=\"10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。\"></a>10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。</h3><p>直接操作 style，会比较混乱，而且有的时候还会忘记写单位，导致实际上不管用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文对一些日常编写 JavaScript 的过程中，一些有助于提高代码性能的规范进行罗列。</p>\n<blockquote>\n<p>本文比较零碎，不作为规范提议，仅作为交流参考。</p>\n</blockquote>\n<h3 id=\"1-使用解构赋值，减少中间变量。\"><a href=\"#1-使用解构赋值，减少中间变量。\" class=\"headerlink\" title=\"1. 使用解构赋值，减少中间变量。\"></a>1. 使用解构赋值，减少中间变量。</h3><p>对于一些比如变量替换的场景，我们使用解构赋值，可以省略中间变量，整体代码也会更加清晰。</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span> = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">b</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">[b, a] = [a, b];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-通过条件判断提前返回\"><a href=\"#2-通过条件判断提前返回\" class=\"headerlink\" title=\"2. 通过条件判断提前返回\"></a>2. 通过条件判断提前返回</h3><p>这里主要是提醒大家如何写好 if 语句。</p>\n<p>实际上， 在编写复杂的 if 语句之前，我们应该考虑是否可以<strong>逻辑外化</strong>：</p>\n<p>即尽可能的将代码的复杂逻辑向外推，例如抽离成多个函数，而不是在程序里面进行过多判断。有一种比较典型的不合理的重用是把大量的逻辑都堆叠到一个函数里面，然后提供一个很复杂的功能。我认为更好的做法应当是分离成更多的模块。</p>\n<p>经过以上思考之后，我们可能还有一些 if 语句，一般的原则是：</p>\n<ul>\n<li>if 语句先简单，后复杂。</li>\n<li>if 语句，可以提前返回即提前返回，减少复杂的嵌套。</li>\n</ul>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> nice:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (condition1) &#123;</span><br><span class=\"line\">  <span class=\"regexp\">//</span> <span class=\"keyword\">do</span> something</span><br><span class=\"line\">  return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (condition2) &#123;</span><br><span class=\"line\">  <span class=\"regexp\">//</span> <span class=\"keyword\">do</span> something</span><br><span class=\"line\">  return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">other_function();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span> bad:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (condition1) &#123;</span><br><span class=\"line\">  <span class=\"regexp\">//</span> <span class=\"keyword\">do</span> something</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (condition2) &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span> <span class=\"keyword\">do</span> something</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    other_function();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-尽量避免在循环体内包裹函数表达式\"><a href=\"#3-尽量避免在循环体内包裹函数表达式\" class=\"headerlink\" title=\"3. 尽量避免在循环体内包裹函数表达式\"></a>3. 尽量避免在循环体内包裹函数表达式</h3><p>函数表达式会生成对应的函数对象，如果我们在循环体内去做这个事情，很可能会造成额外的浪费。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// nice:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callback</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> len = nodelist.length;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  addListener(nodelist[i], callback);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bad:</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nodelist.length; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  addListener(nodelist[i], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-对循环体内的不变值，在循环体外使用缓存\"><a href=\"#4-对循环体内的不变值，在循环体外使用缓存\" class=\"headerlink\" title=\"4. 对循环体内的不变值，在循环体外使用缓存\"></a>4. 对循环体内的不变值，在循环体外使用缓存</h3><p>这一条其实是对上一条的补充，实际上是同样的原理，即希望我们在循环体内尽量保持逻辑的简单，减少重复的 cpu 时间和内存的消耗。</p>\n<h3 id=\"5-清空数组使用-length-0\"><a href=\"#5-清空数组使用-length-0\" class=\"headerlink\" title=\"5. 清空数组使用 .length = 0\"></a>5. 清空数组使用 .length = 0</h3><p>这样写可以方便我们清空一个 const 数组。</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">// 如果使用 a = [] 会报错</span></span><br><span class=\"line\">a.<span class=\"built_in\">length</span> = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-不得为了编写方便，将并行的-io-串行化\"><a href=\"#6-不得为了编写方便，将并行的-io-串行化\" class=\"headerlink\" title=\"6. 不得为了编写方便，将并行的 io 串行化\"></a>6. 不得为了编写方便，将并行的 io 串行化</h3><p>虽然现在 JavaScript 有了 async/await，但是我发现很多同学会对此滥用，一个很常见的清空就是将可以并行的操作串行化了:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">let</span> res<span class=\"number\">1</span> = await process<span class=\"number\">1</span>();</span><br><span class=\"line\"><span class=\"attribute\">let</span> res<span class=\"number\">2</span> = await process<span class=\"number\">2</span>();</span><br><span class=\"line\"><span class=\"attribute\">next</span>(res<span class=\"number\">1</span>, res<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，虽然写代码方便，但是这样写是不可取的，Promise 提供了若干的方便我们处理并行任务的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise#\">方法</a>，我认为这些都是必须要了解的。</p>\n<h3 id=\"7-禁止直接使用-eval\"><a href=\"#7-禁止直接使用-eval\" class=\"headerlink\" title=\"7. 禁止直接使用 eval\"></a>7. 禁止直接使用 eval</h3><p>eval 的安全性非常差，事实上有很多已知的 xss 等漏洞都和 eval 有关，所以我们在实际场景中避免使用 eval。</p>\n<p>如下为一个例子，使用了 eval 函数，由于其执行代码的作用域为本地作用域，所以对我们的本地变量进行了修改并且可以生效：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">tip</span> = <span class=\"string\">&quot;请重新登录&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">otherCode</span> = `<span class=\"attr\">tip</span> = <span class=\"string\">&quot;请前往 xxx.com 重新登录&quot;</span>`</span><br><span class=\"line\">eval(otherCode);</span><br></pre></td></tr></table></figure>\n\n<p>一些取代方式：</p>\n<p>我们可以使用 <code>new Function</code> 的方式来代替 eval，这样至少可以进行作用域的隔离，相对会安全一些（但是请注意其仍然会可能影响到全局变量）。</p>\n<h3 id=\"8-浏览器环境中，尽量避免使用-document-all、document-querySelectorAll\"><a href=\"#8-浏览器环境中，尽量避免使用-document-all、document-querySelectorAll\" class=\"headerlink\" title=\"8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll\"></a>8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll</h3><p>类似的 all 相关操作都要避免使用，由于我们很难控制随着项目发展内容会有多少，所以我们最好一开始就不要留下随着项目内容增加性能越来越差的隐患。</p>\n<h3 id=\"9-获取元素的样式，尽量使用-getComputedStyle-或-currentStyle\"><a href=\"#9-获取元素的样式，尽量使用-getComputedStyle-或-currentStyle\" class=\"headerlink\" title=\"9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle\"></a>9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle</h3><p>通过 style 只能获得内联定义或通过 JavaScript 直接定义的样式，通过 CSS class 设置的样式无法直接获取。</p>\n<h3 id=\"10-尽可能通过为元素添加预定义的-ClassName-来改变元素样式，避免直接操作-style-进行设置。\"><a href=\"#10-尽可能通过为元素添加预定义的-ClassName-来改变元素样式，避免直接操作-style-进行设置。\" class=\"headerlink\" title=\"10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。\"></a>10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。</h3><p>直接操作 style，会比较混乱，而且有的时候还会忘记写单位，导致实际上不管用。</p>\n"},{"title":"一篇关于react历史的流水账","abbrlink":2530407405,"date":"2018-06-10T07:54:14.000Z","_content":"\nreact 目前已经更新到 V16.3，其一路走来，日臻完善，笔者接触 react 两年有余，在这里做一个阶段性的整理，也对 react 的发展和我对 react 的学习做一个整体记录。\n\n笔者是在 16 年初开始关注 react，而实际上那个时候 react 已经发布快三年了， 16 年初的我写页面还是主要使用 backbone.js、Jquery，并且认为，相比于纯粹使用 Jquery 的“刀耕火种”的时代，使用 backbone.js 已经足够方便并且不需要替代品了。\n\n这篇文章会从 react 开源之初进行讲起，直到 2018 年六月。\n\n### 为什么是 react\n\n我们知道，react 并不是一个 MVC 框架，也并没有使用传统的前端模版，而是采用了纯 JS 编写（实际上用到了 JSX ），使用了虚拟 DOM，使用 diff 来保证 DOM 的更新效率，并且可以结合 facebook 的 Flux 架构，解决传统 MVC 模式的一些痛点。\n\n在 react 开源之初，相关生态体系并不完善，甚至官方还在用`Backbone.Router`加 react 来开发单页面应用。\n\n但是那个时候的 react，和现在的 react，解决的核心问题都没有变化，那就是**复杂的UI渲染问题（ complex UI rendering ）**，所有的它的组件化，虚拟 DOM 和 diff 算法，甚至目前提出的 Fiber、async rendering等等，都是围绕这个中心。\n\n### FLUX\n\n在 2014 年五月左右，也就是距离 react 开源接近一年时间，react 公开了 FLUX 架构。当然，我们现在在学习的过程中，甚至都很难听到 FLUX 这个词汇了，更多的则是 redux 甚至 dva 等更上层的框架，但是目前绝大多数 react 相关的数据管理框架都受到了 FLUX 很大启发。\n\nFLUX 和双向数据绑定的关系，我认为这里有必要援引当初官方写的一点解释（更详细的一些信息，可以看[这篇文章](https://www.10000h.top/react_flux.pdf)）：\n\n```\nTo summarize, Flux works well for us because the single directional data flow makes it easy to understand and modify an application as it becomes more complicated. We found that two-way data bindings lead to cascading updates, where changing one data model led to another data model updating, making it very difficult to predict what would change as the result of a single user interaction.\n\n总而言之，Flux对我们来说效果很好，因为单向数据流可以让应用程序变得更加复杂，从而轻松理解和修改应用程序。我们发现双向数据绑定导致级联更新，其中更改一个数据模型导致另一个数据模型更新，使得很难预测单个用户交互的结果会发生什么变化。\n```\n\n从此之后，下面这张图便多次出现在官方博客和各个网站中，相信我们也肯定见过下图：\n\n![](https://www.10000h.top/images/flux.png)\n\n### react-router\n\n2014年8月，react-router 的雏形发布，在其发布之前，不少示例应用还在使用 backbone\n.js 的 router，而 react-router 的发布，标志着 react 生态的进一步成熟。\n\n### react ES6 Class\n\n实际上，在 2015.01.27 之前，我们都是在使用 `React.createClass`来书写组件。\n\n而在 2015.01.27 这一天，也就是第一届 `reactjs conf` 的前一天，react 官方发布了 React V0.13.0 beta 版本。这一个版本的最大更新就是支持 ES6 的 Class 写法来书写组件，同时也公布了比如 propTypes 类型检查、defaultProps、AutoBind、ref 等一系列相关工作在 ES6 Class 模式下的写法。\n\n这次发布是 react 开源至此最为重大的一次更新，也因此直接将 react 的写法进行了革新，在我看来，这标志着 react 从刀耕火种的原始时代进入了石器时代。\n\n*实际上，直到一个半月后的 03.10 ，V0.13 的正式版本才发布。*\n\n而在之后的 V15.5 版本（2017年4月发布），react 才将`React.createClass`的使用设置为 Deprecation，并且宣布会在将来移除该 API，与此同时，react 团队仍然提供了一个单独的库`create-react-class` 来支持原来的 `React.createClass` 功能。\n\n### Relay & GraphQL\n\n在 2015 年的 2月，Facebook 公布了 GraphQL，GraphQL 是一种新的数据查询解决方案，事实证明，它是非常优秀的一个解决方案，到现在已经基本在行业内人尽皆知。\n\n而 Relay 则是链接 react 和 GraphQL 的一个解决方案，有点类似 redux（但是 stat 数只有 redux 的四分之一左右），但是对 GraphQL 更为友好，并且在缓存机制的设计（按照 Graph 来 cache）、声明式的数据获取等方面，有一些自己的独到之处。\n\n当然，我们使用 redux 配合相关插件，也可以不使用 Relay。\n\n\n### React Native\n\n在第一届 React.js Conf 中，react 团队首次公开了 React Native，并且在3月份真正开源了 React Native（实际上这个时候安卓版本还并不可用），之后在2015年上半年，相关团队陆陆续续披露了关于 React Native 发展情况的更多信息。\n\n并且也是在这个时候（2015年3月），react 团队开始使用 **learn once, write anywhere** 这个如今我们耳熟能详的口号。\n\n### react & react-dom & babel\n\n在2015年七月，官方发布了React v0.14 Beta 1，这也是一个变动比较大的版本，在这个版本中，主要有如下比较大的变化:\n\n* 官方宣布废弃 react-tools 和 JSTransform，这是和 JSX 解析相关的库，而从此 react 开始使用 babel，我认为这对 react 以及其使用者来说无疑是一个利好。\n* 分离 react 和 react-dom，由于 React Native 已经迭代了一段时间，这个分离同时也意味着 react 之后的发展方向，react 本身将会关注抽象层和组件本身，而 react-dom 可以将其在浏览器中落地，React Native 可以将其在客户端中落地，之后也许还会有 react-xxx ...\n\n将 react 和 react-dom 分离之后，react 团队又对 react-dom 在 dom 方面做了较为大量的更新。\n\n### Discontinuing IE 8 Support\n\n在 react V15 的版本中，放弃了对 IE 8 的支持。\n\n\n### Fiber\n\nreact 团队使用 Fiber 架构完成了 react V16 的开发，得益于 Fiber 架构，react 的性能又得到了显著提升（尤其是在某些要求交互连续的场景下），并且包大小缩小了 32%。\n\n到目前来说，关于 Fiber 架构的中英文资料都已经相当丰富，笔者在这里就不进行过多的赘述了。\n\n### 接下来的展望\n\nreact 团队目前的主要工作集中在 async rendering 方面，这方面的改进可以极大提升用户交互体验（特别是在弱网络环境下），会在 2018 年发布。\n\n如果你对这方面的内容很感兴趣，不妨看看 react 之前的[演讲视频](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html)\n\n### 附录1 一些你可能不知道的变化\n\n* react并非直接将 JSX 渲染成 DOM，而是对某些事件和属性做了封装（优化）。 react 对表单类型的 DOM 进行了优化，比如封装了较为通用的 onChange 回调函数，这其中需要处理不少问题，react 在 V0.4 即拥有了这一特性，可以参考[这里](https://reactjs.org/blog/2013/07/23/community-roundup-5.html#cross-browser-onchange)\n* 事实上，react 在V0.8之前，一直在以“react-tools”这个名字发布，而 npm 上面叫做 react 的实际上是另外一个包，而到 V0.8 的时候，react 团队和原来的 “react” 包开发者协商，之后 react 便接管了原来的这个包，也因此，react并没有 V0.6 和 V0.7，而是从 V0.5 直接到了 V0.8\n* react 从 V0.14 之后，就直接跳跃到了 V15，官方团队给出的理由是，react 很早就已经足够稳定并且可以使用在生产版本中，更改版本的表达方式更有助于表示 react 项目本身的稳定性。\n\n### 附录2 一些比较优秀的博客\n\n* 关于React Components, Elements, 和 Instances，如果你还有一些疑问，可以看一看React官方团队的文章：[React Components, Elements, and Instances](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html)\n* 如果你倾向于使用 mixins，不妨看看 react 关于取消 mixin的说法：[Mixins Considered Harmful](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)\n* react props 相关的开发模式的建议，我认为目前在使用 react 的程序员都应该了解一下[You Probably Don't Need Derived State](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html)","source":"_posts/一篇关于react历史的流水账.md","raw":"---\ntitle: 一篇关于react历史的流水账\ntags:\n  - react\nabbrlink: 2530407405\ndate: 2018-06-10 15:54:14\n---\n\nreact 目前已经更新到 V16.3，其一路走来，日臻完善，笔者接触 react 两年有余，在这里做一个阶段性的整理，也对 react 的发展和我对 react 的学习做一个整体记录。\n\n笔者是在 16 年初开始关注 react，而实际上那个时候 react 已经发布快三年了， 16 年初的我写页面还是主要使用 backbone.js、Jquery，并且认为，相比于纯粹使用 Jquery 的“刀耕火种”的时代，使用 backbone.js 已经足够方便并且不需要替代品了。\n\n这篇文章会从 react 开源之初进行讲起，直到 2018 年六月。\n\n### 为什么是 react\n\n我们知道，react 并不是一个 MVC 框架，也并没有使用传统的前端模版，而是采用了纯 JS 编写（实际上用到了 JSX ），使用了虚拟 DOM，使用 diff 来保证 DOM 的更新效率，并且可以结合 facebook 的 Flux 架构，解决传统 MVC 模式的一些痛点。\n\n在 react 开源之初，相关生态体系并不完善，甚至官方还在用`Backbone.Router`加 react 来开发单页面应用。\n\n但是那个时候的 react，和现在的 react，解决的核心问题都没有变化，那就是**复杂的UI渲染问题（ complex UI rendering ）**，所有的它的组件化，虚拟 DOM 和 diff 算法，甚至目前提出的 Fiber、async rendering等等，都是围绕这个中心。\n\n### FLUX\n\n在 2014 年五月左右，也就是距离 react 开源接近一年时间，react 公开了 FLUX 架构。当然，我们现在在学习的过程中，甚至都很难听到 FLUX 这个词汇了，更多的则是 redux 甚至 dva 等更上层的框架，但是目前绝大多数 react 相关的数据管理框架都受到了 FLUX 很大启发。\n\nFLUX 和双向数据绑定的关系，我认为这里有必要援引当初官方写的一点解释（更详细的一些信息，可以看[这篇文章](https://www.10000h.top/react_flux.pdf)）：\n\n```\nTo summarize, Flux works well for us because the single directional data flow makes it easy to understand and modify an application as it becomes more complicated. We found that two-way data bindings lead to cascading updates, where changing one data model led to another data model updating, making it very difficult to predict what would change as the result of a single user interaction.\n\n总而言之，Flux对我们来说效果很好，因为单向数据流可以让应用程序变得更加复杂，从而轻松理解和修改应用程序。我们发现双向数据绑定导致级联更新，其中更改一个数据模型导致另一个数据模型更新，使得很难预测单个用户交互的结果会发生什么变化。\n```\n\n从此之后，下面这张图便多次出现在官方博客和各个网站中，相信我们也肯定见过下图：\n\n![](https://www.10000h.top/images/flux.png)\n\n### react-router\n\n2014年8月，react-router 的雏形发布，在其发布之前，不少示例应用还在使用 backbone\n.js 的 router，而 react-router 的发布，标志着 react 生态的进一步成熟。\n\n### react ES6 Class\n\n实际上，在 2015.01.27 之前，我们都是在使用 `React.createClass`来书写组件。\n\n而在 2015.01.27 这一天，也就是第一届 `reactjs conf` 的前一天，react 官方发布了 React V0.13.0 beta 版本。这一个版本的最大更新就是支持 ES6 的 Class 写法来书写组件，同时也公布了比如 propTypes 类型检查、defaultProps、AutoBind、ref 等一系列相关工作在 ES6 Class 模式下的写法。\n\n这次发布是 react 开源至此最为重大的一次更新，也因此直接将 react 的写法进行了革新，在我看来，这标志着 react 从刀耕火种的原始时代进入了石器时代。\n\n*实际上，直到一个半月后的 03.10 ，V0.13 的正式版本才发布。*\n\n而在之后的 V15.5 版本（2017年4月发布），react 才将`React.createClass`的使用设置为 Deprecation，并且宣布会在将来移除该 API，与此同时，react 团队仍然提供了一个单独的库`create-react-class` 来支持原来的 `React.createClass` 功能。\n\n### Relay & GraphQL\n\n在 2015 年的 2月，Facebook 公布了 GraphQL，GraphQL 是一种新的数据查询解决方案，事实证明，它是非常优秀的一个解决方案，到现在已经基本在行业内人尽皆知。\n\n而 Relay 则是链接 react 和 GraphQL 的一个解决方案，有点类似 redux（但是 stat 数只有 redux 的四分之一左右），但是对 GraphQL 更为友好，并且在缓存机制的设计（按照 Graph 来 cache）、声明式的数据获取等方面，有一些自己的独到之处。\n\n当然，我们使用 redux 配合相关插件，也可以不使用 Relay。\n\n\n### React Native\n\n在第一届 React.js Conf 中，react 团队首次公开了 React Native，并且在3月份真正开源了 React Native（实际上这个时候安卓版本还并不可用），之后在2015年上半年，相关团队陆陆续续披露了关于 React Native 发展情况的更多信息。\n\n并且也是在这个时候（2015年3月），react 团队开始使用 **learn once, write anywhere** 这个如今我们耳熟能详的口号。\n\n### react & react-dom & babel\n\n在2015年七月，官方发布了React v0.14 Beta 1，这也是一个变动比较大的版本，在这个版本中，主要有如下比较大的变化:\n\n* 官方宣布废弃 react-tools 和 JSTransform，这是和 JSX 解析相关的库，而从此 react 开始使用 babel，我认为这对 react 以及其使用者来说无疑是一个利好。\n* 分离 react 和 react-dom，由于 React Native 已经迭代了一段时间，这个分离同时也意味着 react 之后的发展方向，react 本身将会关注抽象层和组件本身，而 react-dom 可以将其在浏览器中落地，React Native 可以将其在客户端中落地，之后也许还会有 react-xxx ...\n\n将 react 和 react-dom 分离之后，react 团队又对 react-dom 在 dom 方面做了较为大量的更新。\n\n### Discontinuing IE 8 Support\n\n在 react V15 的版本中，放弃了对 IE 8 的支持。\n\n\n### Fiber\n\nreact 团队使用 Fiber 架构完成了 react V16 的开发，得益于 Fiber 架构，react 的性能又得到了显著提升（尤其是在某些要求交互连续的场景下），并且包大小缩小了 32%。\n\n到目前来说，关于 Fiber 架构的中英文资料都已经相当丰富，笔者在这里就不进行过多的赘述了。\n\n### 接下来的展望\n\nreact 团队目前的主要工作集中在 async rendering 方面，这方面的改进可以极大提升用户交互体验（特别是在弱网络环境下），会在 2018 年发布。\n\n如果你对这方面的内容很感兴趣，不妨看看 react 之前的[演讲视频](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html)\n\n### 附录1 一些你可能不知道的变化\n\n* react并非直接将 JSX 渲染成 DOM，而是对某些事件和属性做了封装（优化）。 react 对表单类型的 DOM 进行了优化，比如封装了较为通用的 onChange 回调函数，这其中需要处理不少问题，react 在 V0.4 即拥有了这一特性，可以参考[这里](https://reactjs.org/blog/2013/07/23/community-roundup-5.html#cross-browser-onchange)\n* 事实上，react 在V0.8之前，一直在以“react-tools”这个名字发布，而 npm 上面叫做 react 的实际上是另外一个包，而到 V0.8 的时候，react 团队和原来的 “react” 包开发者协商，之后 react 便接管了原来的这个包，也因此，react并没有 V0.6 和 V0.7，而是从 V0.5 直接到了 V0.8\n* react 从 V0.14 之后，就直接跳跃到了 V15，官方团队给出的理由是，react 很早就已经足够稳定并且可以使用在生产版本中，更改版本的表达方式更有助于表示 react 项目本身的稳定性。\n\n### 附录2 一些比较优秀的博客\n\n* 关于React Components, Elements, 和 Instances，如果你还有一些疑问，可以看一看React官方团队的文章：[React Components, Elements, and Instances](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html)\n* 如果你倾向于使用 mixins，不妨看看 react 关于取消 mixin的说法：[Mixins Considered Harmful](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)\n* react props 相关的开发模式的建议，我认为目前在使用 react 的程序员都应该了解一下[You Probably Don't Need Derived State](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html)","slug":"一篇关于react历史的流水账","published":1,"updated":"2021-12-23T05:50:07.544Z","_id":"ckxijpqsv000rd3mrb8qnd4id","comments":1,"layout":"post","photos":[],"link":"","content":"<p>react 目前已经更新到 V16.3，其一路走来，日臻完善，笔者接触 react 两年有余，在这里做一个阶段性的整理，也对 react 的发展和我对 react 的学习做一个整体记录。</p>\n<p>笔者是在 16 年初开始关注 react，而实际上那个时候 react 已经发布快三年了， 16 年初的我写页面还是主要使用 backbone.js、Jquery，并且认为，相比于纯粹使用 Jquery 的“刀耕火种”的时代，使用 backbone.js 已经足够方便并且不需要替代品了。</p>\n<p>这篇文章会从 react 开源之初进行讲起，直到 2018 年六月。</p>\n<h3 id=\"为什么是-react\"><a href=\"#为什么是-react\" class=\"headerlink\" title=\"为什么是 react\"></a>为什么是 react</h3><p>我们知道，react 并不是一个 MVC 框架，也并没有使用传统的前端模版，而是采用了纯 JS 编写（实际上用到了 JSX ），使用了虚拟 DOM，使用 diff 来保证 DOM 的更新效率，并且可以结合 facebook 的 Flux 架构，解决传统 MVC 模式的一些痛点。</p>\n<p>在 react 开源之初，相关生态体系并不完善，甚至官方还在用<code>Backbone.Router</code>加 react 来开发单页面应用。</p>\n<p>但是那个时候的 react，和现在的 react，解决的核心问题都没有变化，那就是<strong>复杂的UI渲染问题（ complex UI rendering ）</strong>，所有的它的组件化，虚拟 DOM 和 diff 算法，甚至目前提出的 Fiber、async rendering等等，都是围绕这个中心。</p>\n<h3 id=\"FLUX\"><a href=\"#FLUX\" class=\"headerlink\" title=\"FLUX\"></a>FLUX</h3><p>在 2014 年五月左右，也就是距离 react 开源接近一年时间，react 公开了 FLUX 架构。当然，我们现在在学习的过程中，甚至都很难听到 FLUX 这个词汇了，更多的则是 redux 甚至 dva 等更上层的框架，但是目前绝大多数 react 相关的数据管理框架都受到了 FLUX 很大启发。</p>\n<p>FLUX 和双向数据绑定的关系，我认为这里有必要援引当初官方写的一点解释（更详细的一些信息，可以看<a href=\"https://www.10000h.top/react_flux.pdf\">这篇文章</a>）：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To summarize, Flux works well <span class=\"keyword\">for</span> us because <span class=\"keyword\">the</span> single directional data flow makes <span class=\"keyword\">it</span> easy <span class=\"built_in\">to</span> understand <span class=\"keyword\">and</span> modify <span class=\"keyword\">an</span> application <span class=\"keyword\">as</span> <span class=\"keyword\">it</span> becomes more complicated. We found that <span class=\"literal\">two</span>-way data bindings lead <span class=\"built_in\">to</span> cascading updates, where changing <span class=\"literal\">one</span> data model led <span class=\"built_in\">to</span> another data model updating, making <span class=\"keyword\">it</span> very difficult <span class=\"built_in\">to</span> predict what would change <span class=\"keyword\">as</span> <span class=\"keyword\">the</span> <span class=\"built_in\">result</span> <span class=\"keyword\">of</span> <span class=\"keyword\">a</span> single user interaction.</span><br><span class=\"line\"></span><br><span class=\"line\">总而言之，Flux对我们来说效果很好，因为单向数据流可以让应用程序变得更加复杂，从而轻松理解和修改应用程序。我们发现双向数据绑定导致级联更新，其中更改一个数据模型导致另一个数据模型更新，使得很难预测单个用户交互的结果会发生什么变化。</span><br></pre></td></tr></table></figure>\n\n<p>从此之后，下面这张图便多次出现在官方博客和各个网站中，相信我们也肯定见过下图：</p>\n<p><img src=\"https://www.10000h.top/images/flux.png\"></p>\n<h3 id=\"react-router\"><a href=\"#react-router\" class=\"headerlink\" title=\"react-router\"></a>react-router</h3><p>2014年8月，react-router 的雏形发布，在其发布之前，不少示例应用还在使用 backbone<br>.js 的 router，而 react-router 的发布，标志着 react 生态的进一步成熟。</p>\n<h3 id=\"react-ES6-Class\"><a href=\"#react-ES6-Class\" class=\"headerlink\" title=\"react ES6 Class\"></a>react ES6 Class</h3><p>实际上，在 2015.01.27 之前，我们都是在使用 <code>React.createClass</code>来书写组件。</p>\n<p>而在 2015.01.27 这一天，也就是第一届 <code>reactjs conf</code> 的前一天，react 官方发布了 React V0.13.0 beta 版本。这一个版本的最大更新就是支持 ES6 的 Class 写法来书写组件，同时也公布了比如 propTypes 类型检查、defaultProps、AutoBind、ref 等一系列相关工作在 ES6 Class 模式下的写法。</p>\n<p>这次发布是 react 开源至此最为重大的一次更新，也因此直接将 react 的写法进行了革新，在我看来，这标志着 react 从刀耕火种的原始时代进入了石器时代。</p>\n<p><em>实际上，直到一个半月后的 03.10 ，V0.13 的正式版本才发布。</em></p>\n<p>而在之后的 V15.5 版本（2017年4月发布），react 才将<code>React.createClass</code>的使用设置为 Deprecation，并且宣布会在将来移除该 API，与此同时，react 团队仍然提供了一个单独的库<code>create-react-class</code> 来支持原来的 <code>React.createClass</code> 功能。</p>\n<h3 id=\"Relay-amp-GraphQL\"><a href=\"#Relay-amp-GraphQL\" class=\"headerlink\" title=\"Relay &amp; GraphQL\"></a>Relay &amp; GraphQL</h3><p>在 2015 年的 2月，Facebook 公布了 GraphQL，GraphQL 是一种新的数据查询解决方案，事实证明，它是非常优秀的一个解决方案，到现在已经基本在行业内人尽皆知。</p>\n<p>而 Relay 则是链接 react 和 GraphQL 的一个解决方案，有点类似 redux（但是 stat 数只有 redux 的四分之一左右），但是对 GraphQL 更为友好，并且在缓存机制的设计（按照 Graph 来 cache）、声明式的数据获取等方面，有一些自己的独到之处。</p>\n<p>当然，我们使用 redux 配合相关插件，也可以不使用 Relay。</p>\n<h3 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h3><p>在第一届 React.js Conf 中，react 团队首次公开了 React Native，并且在3月份真正开源了 React Native（实际上这个时候安卓版本还并不可用），之后在2015年上半年，相关团队陆陆续续披露了关于 React Native 发展情况的更多信息。</p>\n<p>并且也是在这个时候（2015年3月），react 团队开始使用 <strong>learn once, write anywhere</strong> 这个如今我们耳熟能详的口号。</p>\n<h3 id=\"react-amp-react-dom-amp-babel\"><a href=\"#react-amp-react-dom-amp-babel\" class=\"headerlink\" title=\"react &amp; react-dom &amp; babel\"></a>react &amp; react-dom &amp; babel</h3><p>在2015年七月，官方发布了React v0.14 Beta 1，这也是一个变动比较大的版本，在这个版本中，主要有如下比较大的变化:</p>\n<ul>\n<li>官方宣布废弃 react-tools 和 JSTransform，这是和 JSX 解析相关的库，而从此 react 开始使用 babel，我认为这对 react 以及其使用者来说无疑是一个利好。</li>\n<li>分离 react 和 react-dom，由于 React Native 已经迭代了一段时间，这个分离同时也意味着 react 之后的发展方向，react 本身将会关注抽象层和组件本身，而 react-dom 可以将其在浏览器中落地，React Native 可以将其在客户端中落地，之后也许还会有 react-xxx …</li>\n</ul>\n<p>将 react 和 react-dom 分离之后，react 团队又对 react-dom 在 dom 方面做了较为大量的更新。</p>\n<h3 id=\"Discontinuing-IE-8-Support\"><a href=\"#Discontinuing-IE-8-Support\" class=\"headerlink\" title=\"Discontinuing IE 8 Support\"></a>Discontinuing IE 8 Support</h3><p>在 react V15 的版本中，放弃了对 IE 8 的支持。</p>\n<h3 id=\"Fiber\"><a href=\"#Fiber\" class=\"headerlink\" title=\"Fiber\"></a>Fiber</h3><p>react 团队使用 Fiber 架构完成了 react V16 的开发，得益于 Fiber 架构，react 的性能又得到了显著提升（尤其是在某些要求交互连续的场景下），并且包大小缩小了 32%。</p>\n<p>到目前来说，关于 Fiber 架构的中英文资料都已经相当丰富，笔者在这里就不进行过多的赘述了。</p>\n<h3 id=\"接下来的展望\"><a href=\"#接下来的展望\" class=\"headerlink\" title=\"接下来的展望\"></a>接下来的展望</h3><p>react 团队目前的主要工作集中在 async rendering 方面，这方面的改进可以极大提升用户交互体验（特别是在弱网络环境下），会在 2018 年发布。</p>\n<p>如果你对这方面的内容很感兴趣，不妨看看 react 之前的<a href=\"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\">演讲视频</a></p>\n<h3 id=\"附录1-一些你可能不知道的变化\"><a href=\"#附录1-一些你可能不知道的变化\" class=\"headerlink\" title=\"附录1 一些你可能不知道的变化\"></a>附录1 一些你可能不知道的变化</h3><ul>\n<li>react并非直接将 JSX 渲染成 DOM，而是对某些事件和属性做了封装（优化）。 react 对表单类型的 DOM 进行了优化，比如封装了较为通用的 onChange 回调函数，这其中需要处理不少问题，react 在 V0.4 即拥有了这一特性，可以参考<a href=\"https://reactjs.org/blog/2013/07/23/community-roundup-5.html#cross-browser-onchange\">这里</a></li>\n<li>事实上，react 在V0.8之前，一直在以“react-tools”这个名字发布，而 npm 上面叫做 react 的实际上是另外一个包，而到 V0.8 的时候，react 团队和原来的 “react” 包开发者协商，之后 react 便接管了原来的这个包，也因此，react并没有 V0.6 和 V0.7，而是从 V0.5 直接到了 V0.8</li>\n<li>react 从 V0.14 之后，就直接跳跃到了 V15，官方团队给出的理由是，react 很早就已经足够稳定并且可以使用在生产版本中，更改版本的表达方式更有助于表示 react 项目本身的稳定性。</li>\n</ul>\n<h3 id=\"附录2-一些比较优秀的博客\"><a href=\"#附录2-一些比较优秀的博客\" class=\"headerlink\" title=\"附录2 一些比较优秀的博客\"></a>附录2 一些比较优秀的博客</h3><ul>\n<li>关于React Components, Elements, 和 Instances，如果你还有一些疑问，可以看一看React官方团队的文章：<a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a></li>\n<li>如果你倾向于使用 mixins，不妨看看 react 关于取消 mixin的说法：<a href=\"https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html\">Mixins Considered Harmful</a></li>\n<li>react props 相关的开发模式的建议，我认为目前在使用 react 的程序员都应该了解一下<a href=\"https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html\">You Probably Don’t Need Derived State</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>react 目前已经更新到 V16.3，其一路走来，日臻完善，笔者接触 react 两年有余，在这里做一个阶段性的整理，也对 react 的发展和我对 react 的学习做一个整体记录。</p>\n<p>笔者是在 16 年初开始关注 react，而实际上那个时候 react 已经发布快三年了， 16 年初的我写页面还是主要使用 backbone.js、Jquery，并且认为，相比于纯粹使用 Jquery 的“刀耕火种”的时代，使用 backbone.js 已经足够方便并且不需要替代品了。</p>\n<p>这篇文章会从 react 开源之初进行讲起，直到 2018 年六月。</p>\n<h3 id=\"为什么是-react\"><a href=\"#为什么是-react\" class=\"headerlink\" title=\"为什么是 react\"></a>为什么是 react</h3><p>我们知道，react 并不是一个 MVC 框架，也并没有使用传统的前端模版，而是采用了纯 JS 编写（实际上用到了 JSX ），使用了虚拟 DOM，使用 diff 来保证 DOM 的更新效率，并且可以结合 facebook 的 Flux 架构，解决传统 MVC 模式的一些痛点。</p>\n<p>在 react 开源之初，相关生态体系并不完善，甚至官方还在用<code>Backbone.Router</code>加 react 来开发单页面应用。</p>\n<p>但是那个时候的 react，和现在的 react，解决的核心问题都没有变化，那就是<strong>复杂的UI渲染问题（ complex UI rendering ）</strong>，所有的它的组件化，虚拟 DOM 和 diff 算法，甚至目前提出的 Fiber、async rendering等等，都是围绕这个中心。</p>\n<h3 id=\"FLUX\"><a href=\"#FLUX\" class=\"headerlink\" title=\"FLUX\"></a>FLUX</h3><p>在 2014 年五月左右，也就是距离 react 开源接近一年时间，react 公开了 FLUX 架构。当然，我们现在在学习的过程中，甚至都很难听到 FLUX 这个词汇了，更多的则是 redux 甚至 dva 等更上层的框架，但是目前绝大多数 react 相关的数据管理框架都受到了 FLUX 很大启发。</p>\n<p>FLUX 和双向数据绑定的关系，我认为这里有必要援引当初官方写的一点解释（更详细的一些信息，可以看<a href=\"https://www.10000h.top/react_flux.pdf\">这篇文章</a>）：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To summarize, Flux works well <span class=\"keyword\">for</span> us because <span class=\"keyword\">the</span> single directional data flow makes <span class=\"keyword\">it</span> easy <span class=\"built_in\">to</span> understand <span class=\"keyword\">and</span> modify <span class=\"keyword\">an</span> application <span class=\"keyword\">as</span> <span class=\"keyword\">it</span> becomes more complicated. We found that <span class=\"literal\">two</span>-way data bindings lead <span class=\"built_in\">to</span> cascading updates, where changing <span class=\"literal\">one</span> data model led <span class=\"built_in\">to</span> another data model updating, making <span class=\"keyword\">it</span> very difficult <span class=\"built_in\">to</span> predict what would change <span class=\"keyword\">as</span> <span class=\"keyword\">the</span> <span class=\"built_in\">result</span> <span class=\"keyword\">of</span> <span class=\"keyword\">a</span> single user interaction.</span><br><span class=\"line\"></span><br><span class=\"line\">总而言之，Flux对我们来说效果很好，因为单向数据流可以让应用程序变得更加复杂，从而轻松理解和修改应用程序。我们发现双向数据绑定导致级联更新，其中更改一个数据模型导致另一个数据模型更新，使得很难预测单个用户交互的结果会发生什么变化。</span><br></pre></td></tr></table></figure>\n\n<p>从此之后，下面这张图便多次出现在官方博客和各个网站中，相信我们也肯定见过下图：</p>\n<p><img src=\"https://www.10000h.top/images/flux.png\"></p>\n<h3 id=\"react-router\"><a href=\"#react-router\" class=\"headerlink\" title=\"react-router\"></a>react-router</h3><p>2014年8月，react-router 的雏形发布，在其发布之前，不少示例应用还在使用 backbone<br>.js 的 router，而 react-router 的发布，标志着 react 生态的进一步成熟。</p>\n<h3 id=\"react-ES6-Class\"><a href=\"#react-ES6-Class\" class=\"headerlink\" title=\"react ES6 Class\"></a>react ES6 Class</h3><p>实际上，在 2015.01.27 之前，我们都是在使用 <code>React.createClass</code>来书写组件。</p>\n<p>而在 2015.01.27 这一天，也就是第一届 <code>reactjs conf</code> 的前一天，react 官方发布了 React V0.13.0 beta 版本。这一个版本的最大更新就是支持 ES6 的 Class 写法来书写组件，同时也公布了比如 propTypes 类型检查、defaultProps、AutoBind、ref 等一系列相关工作在 ES6 Class 模式下的写法。</p>\n<p>这次发布是 react 开源至此最为重大的一次更新，也因此直接将 react 的写法进行了革新，在我看来，这标志着 react 从刀耕火种的原始时代进入了石器时代。</p>\n<p><em>实际上，直到一个半月后的 03.10 ，V0.13 的正式版本才发布。</em></p>\n<p>而在之后的 V15.5 版本（2017年4月发布），react 才将<code>React.createClass</code>的使用设置为 Deprecation，并且宣布会在将来移除该 API，与此同时，react 团队仍然提供了一个单独的库<code>create-react-class</code> 来支持原来的 <code>React.createClass</code> 功能。</p>\n<h3 id=\"Relay-amp-GraphQL\"><a href=\"#Relay-amp-GraphQL\" class=\"headerlink\" title=\"Relay &amp; GraphQL\"></a>Relay &amp; GraphQL</h3><p>在 2015 年的 2月，Facebook 公布了 GraphQL，GraphQL 是一种新的数据查询解决方案，事实证明，它是非常优秀的一个解决方案，到现在已经基本在行业内人尽皆知。</p>\n<p>而 Relay 则是链接 react 和 GraphQL 的一个解决方案，有点类似 redux（但是 stat 数只有 redux 的四分之一左右），但是对 GraphQL 更为友好，并且在缓存机制的设计（按照 Graph 来 cache）、声明式的数据获取等方面，有一些自己的独到之处。</p>\n<p>当然，我们使用 redux 配合相关插件，也可以不使用 Relay。</p>\n<h3 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h3><p>在第一届 React.js Conf 中，react 团队首次公开了 React Native，并且在3月份真正开源了 React Native（实际上这个时候安卓版本还并不可用），之后在2015年上半年，相关团队陆陆续续披露了关于 React Native 发展情况的更多信息。</p>\n<p>并且也是在这个时候（2015年3月），react 团队开始使用 <strong>learn once, write anywhere</strong> 这个如今我们耳熟能详的口号。</p>\n<h3 id=\"react-amp-react-dom-amp-babel\"><a href=\"#react-amp-react-dom-amp-babel\" class=\"headerlink\" title=\"react &amp; react-dom &amp; babel\"></a>react &amp; react-dom &amp; babel</h3><p>在2015年七月，官方发布了React v0.14 Beta 1，这也是一个变动比较大的版本，在这个版本中，主要有如下比较大的变化:</p>\n<ul>\n<li>官方宣布废弃 react-tools 和 JSTransform，这是和 JSX 解析相关的库，而从此 react 开始使用 babel，我认为这对 react 以及其使用者来说无疑是一个利好。</li>\n<li>分离 react 和 react-dom，由于 React Native 已经迭代了一段时间，这个分离同时也意味着 react 之后的发展方向，react 本身将会关注抽象层和组件本身，而 react-dom 可以将其在浏览器中落地，React Native 可以将其在客户端中落地，之后也许还会有 react-xxx …</li>\n</ul>\n<p>将 react 和 react-dom 分离之后，react 团队又对 react-dom 在 dom 方面做了较为大量的更新。</p>\n<h3 id=\"Discontinuing-IE-8-Support\"><a href=\"#Discontinuing-IE-8-Support\" class=\"headerlink\" title=\"Discontinuing IE 8 Support\"></a>Discontinuing IE 8 Support</h3><p>在 react V15 的版本中，放弃了对 IE 8 的支持。</p>\n<h3 id=\"Fiber\"><a href=\"#Fiber\" class=\"headerlink\" title=\"Fiber\"></a>Fiber</h3><p>react 团队使用 Fiber 架构完成了 react V16 的开发，得益于 Fiber 架构，react 的性能又得到了显著提升（尤其是在某些要求交互连续的场景下），并且包大小缩小了 32%。</p>\n<p>到目前来说，关于 Fiber 架构的中英文资料都已经相当丰富，笔者在这里就不进行过多的赘述了。</p>\n<h3 id=\"接下来的展望\"><a href=\"#接下来的展望\" class=\"headerlink\" title=\"接下来的展望\"></a>接下来的展望</h3><p>react 团队目前的主要工作集中在 async rendering 方面，这方面的改进可以极大提升用户交互体验（特别是在弱网络环境下），会在 2018 年发布。</p>\n<p>如果你对这方面的内容很感兴趣，不妨看看 react 之前的<a href=\"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\">演讲视频</a></p>\n<h3 id=\"附录1-一些你可能不知道的变化\"><a href=\"#附录1-一些你可能不知道的变化\" class=\"headerlink\" title=\"附录1 一些你可能不知道的变化\"></a>附录1 一些你可能不知道的变化</h3><ul>\n<li>react并非直接将 JSX 渲染成 DOM，而是对某些事件和属性做了封装（优化）。 react 对表单类型的 DOM 进行了优化，比如封装了较为通用的 onChange 回调函数，这其中需要处理不少问题，react 在 V0.4 即拥有了这一特性，可以参考<a href=\"https://reactjs.org/blog/2013/07/23/community-roundup-5.html#cross-browser-onchange\">这里</a></li>\n<li>事实上，react 在V0.8之前，一直在以“react-tools”这个名字发布，而 npm 上面叫做 react 的实际上是另外一个包，而到 V0.8 的时候，react 团队和原来的 “react” 包开发者协商，之后 react 便接管了原来的这个包，也因此，react并没有 V0.6 和 V0.7，而是从 V0.5 直接到了 V0.8</li>\n<li>react 从 V0.14 之后，就直接跳跃到了 V15，官方团队给出的理由是，react 很早就已经足够稳定并且可以使用在生产版本中，更改版本的表达方式更有助于表示 react 项目本身的稳定性。</li>\n</ul>\n<h3 id=\"附录2-一些比较优秀的博客\"><a href=\"#附录2-一些比较优秀的博客\" class=\"headerlink\" title=\"附录2 一些比较优秀的博客\"></a>附录2 一些比较优秀的博客</h3><ul>\n<li>关于React Components, Elements, 和 Instances，如果你还有一些疑问，可以看一看React官方团队的文章：<a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a></li>\n<li>如果你倾向于使用 mixins，不妨看看 react 关于取消 mixin的说法：<a href=\"https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html\">Mixins Considered Harmful</a></li>\n<li>react props 相关的开发模式的建议，我认为目前在使用 react 的程序员都应该了解一下<a href=\"https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html\">You Probably Don’t Need Derived State</a></li>\n</ul>\n"},{"title":"使用 Node.js 打造多用户实时监控系统","abbrlink":177297340,"date":"2018-10-21T09:15:38.000Z","_content":"\n### 背景概述\n\n首先描述一下笔者遇到的问题，我们可以设定这样一个场景：现在有一个实时监控系统的开发需求，要求同时支持多个用户（这里我们为了简化，暂时不涉及登陆态，假定一个设备即为一个用户），对于不同的用户来讲，他们需要监控的一部分内容是完全相同的，比如设备的 CPU 信息、内存信息等，而另外一部分内容是部分用户重叠的，比如对某一区域的用户来说某些监控信息是相同的，而还有一些信息，则是用户之间完全不同的。\n\n对于每个用户来讲，当其进入页面之后即表明其开始监控，需要持续地进行数据更新，而当其退出界面或者手动点击停止监控，则停止监控。\n\n### 问题描述\n\n实际上，对于以上情况，我们很容易想到通过 WebSocket，对不同的用户进行隔离处理，当一个用户开始监控的时候，通过函数来逐个启动其所有的监控项目，当其停止监控的时候，取消相关监控，并且清除无关变量等。我们可以将所有内容写到 WebSocket 的连接回调中，由于作用域隔离，不同用户之间的监控（读操作）不会产生互相影响。\n\n这种方式可以说是最为快捷方便的方式了，并且几乎无需进行设计，但是这样有一个非常明显的效率问题：\n\n由于不同用户的部分监控项目是有重叠的，对于这些重叠的项目，我们如果对于每一个用户都单独监控，那么就会产生非常多的浪费，如果这些监控中还涉及到数据库交互或者较为复杂的计算，那么成倍之后的性能损失是非常难以承受的。\n\n所以，我们需要将不同用户重叠的那些监控项目，进行合并，合并成一个之后，如果有新的消息，我们就推到所有相关用户的回调函数中去处理。\n\n也就是说，我们需要管理一个一对多的订阅发布模式。\n\n到这里，我们发现我们想要实现这样一个监控系统，并不是非常简单，主要有下列问题：\n\n* [1]对于可能有用户重叠的监控项目，我们需要抽离到用户作用域之外，并且通过统计计数等方式来\"记住\"当前所有的监控用户，当有新内容时推到各个用户的处理函数中，并且当最后一个用户取消监控的时候要及时清理相关对象。\n* [2]不同用户的重叠监控项目的监控方式也各不相同，有的是通过 `setInterval` 等方式的定时任务，有的是事件监听器等等。\n* [3]判断不同用户的项目是否重叠也有一定的争议，比如假设不同用户端监控的是同一个项目，调用的也是相同的函数，但是由于用户 ID 不同，这个时候我们如何判断是否算\"同一个监控\"？\n\n以上的这些问题，如果我们不借助现有的库和工具，自己顺着思路一点点去写，则很容易陷入修修补补的循环，无法专注监控本身，并且最后甚至在效率上适得其反。\n\n### 解决方案\n\n以下解决方案基于 Rx.js，需要对 [Observable](https://cn.rx.js.org/class/es6/Observable.js~Observable.html) 有一定了解。\n\n#### 多个用户的监控以及取消\n\n[Monitor-RX](https://github.com/aircloud/monitor-rx) 是对以上场景问题的一个解决方案封装，其利用了 Rx.js 对订阅发布的管理能力，可以让整个流程变的清晰。\n\n在 Rx.js 中，我们可以通过以下方式建立一个多播对象 `multicasted`：\n\n```\nvar source = Rx.from([1, 2, 3]);\nvar subject = new Rx.Subject();\nvar multicasted = source.pipe(multicast(subject)).refCount();\n// 其属于 monitor-rx 的实现细节，无需理解亦可使用 monitor-rx\n\nsubscription1 = refCounted.subscribe({\n    next: (v) => console.log('observerA: ' + JSON.stringify(v))\n});\n\nsetTimeout(() => {\n    subscription2 = refCounted.subscribe({\n        next: (v) => console.log('observerB: ' + JSON.stringify(v))\n    });\n}, 1200);\n\nsubscription1.unsubscribe();\nsetTimeout(() => {\n    subscription2.unsubscribe();\n    // 这里 refCounted 的 unsubscribe 相关清理逻辑会自动被调用\n}, 3200);\n```\n\n在这里采用多播，有如下几个好处：\n\n* 可以随时增加新的订阅者，并且新的订阅者只会收到其加入订阅之后的数据。\n* 可以随时对任意一个订阅者取消订阅。\n* 当所有订阅者取消订阅之后，Observable 会自动触发 Observable 函数，从而可以对其事件循环等进行清理。\n\n以上能力其实可以帮助我们解决上文提到的问题 [1]。\n\n#### 监控格式的统一\n\n实际上，在我们的监控系统中，从数据依赖的角度，我们的监控函数会有这样几类：\n\n* [a]纯粹的定时任务，无数据依赖，这方面比如当前内存快照数据等。\n* [b]带有记忆依赖的定时任务：定时任务依赖前一次的数据（甚至更多次），需要两次数据做差等，这方面的数据比如一段时间的消耗数据，cpu 使用率的计算。\n* [c]带有用户依赖的定时任务：依赖用户 id 等信息，不同用户无法共用。\n\n而从任务触发的角度，我们仍待可以对其分类：\n\n* [i]简单的 `setInterval` 定时任务。\n* [ii]基于事件机制的不定时任务。\n* [iii]基于其他触发机制的任务。\n\n实际上，我们如果采用 Rx.js 的模式进行编写，无需考虑任务的数据依赖和触发的方式，只需写成一个一个 Observable 实例即可。另外，对于比较简单的 [a]&[i] 或 [c]&[i]  类型，我们还可以通过 monitor-rx 提供的 `convertToRx` 或 `convertToSimpleRx` 转换成 Observable 实例生成函数，例如：\n\n```\nvar os = require('os');\nvar process = require('process');\nconst monitorRx = require('monitor-rx');\n\nfunction getMemoryInfo() {\n    return process.memoryUsage();\n}\n\nconst memory = monitorRx.Utils.convertToSimpleRx(getMemoryInfo)\n\n// 或者\n//const memory = monitorRx.Utils.convertToRx({\n//    getMemoryInfo\n//});\n\nmodule.exports = memory;\n```\n\nconvertToRx 相比于 convertToSimpleRx，可以支持函数配置注入（即下文中 opts 的 func 属性和 args 属性）,可以在具体生成 Observable 实例的时候具体指定使用哪些函数以及其参数。\n\n如果是比较复杂的 Observable 类型，那么我们就无法直接通过普通函数进行转化了，这个时候我们遵循 Observable 的标准返回 Observable 生成函数即可（不是直接返回 Observable 实例） \n\n这实际上也对问题 [2] 进行了解决。\n\n#### 监控唯一性：\n\n我们知道，如果两个用户都监控同一个信息，我们可以共用一个 Observable，这里的问题，就是如何定义两个用户的监控是\"相同\"的。\n\n这里我们采用一个可选项 opts 的概念，其一共有如下属性：\n\n```\n{\n    module: 'ModuleName',\n    func: ['FuncName'],\n    args: [['arg1','arg2']],\n    opts: {interval:1000}, \n}\n```\n\nmodule 即用户是对哪一个模块进行监控（实际上是 Observable），func 和 args 则是监控过程中需要调用的函数，我们也可以通过 agrs 传入用户个人信息。于没有内部子函数调用的监控，二者为空即可，opts 是一些其他可选项，比如定义请求间隔等。\n\n之后，我们通过 `JSON.stringify(opts)` 来序列化这个可选项配置，如果两个用户序列化后的可选项配置相同，那么我们就认为这两个用户可以共用一个监控，即共用一个 Observable。\n\n### 更多内容\n\n实际上，借助 Monitor-RX，我们可以很方便的解决上述提出的问题，Monitor-RX 也在积极的更新中，大家可以在[这里](https://github.com/aircloud/monitor-rx)了解到更多的信息。","source":"_posts/使用 Node.js 打造多用户实时监控系统.md","raw":"---\ntitle: 使用 Node.js 打造多用户实时监控系统\ntags:\n  - Node.js\n  - javascript\n  - Rx.js\nabbrlink: 177297340\ndate: 2018-10-21 17:15:38\n---\n\n### 背景概述\n\n首先描述一下笔者遇到的问题，我们可以设定这样一个场景：现在有一个实时监控系统的开发需求，要求同时支持多个用户（这里我们为了简化，暂时不涉及登陆态，假定一个设备即为一个用户），对于不同的用户来讲，他们需要监控的一部分内容是完全相同的，比如设备的 CPU 信息、内存信息等，而另外一部分内容是部分用户重叠的，比如对某一区域的用户来说某些监控信息是相同的，而还有一些信息，则是用户之间完全不同的。\n\n对于每个用户来讲，当其进入页面之后即表明其开始监控，需要持续地进行数据更新，而当其退出界面或者手动点击停止监控，则停止监控。\n\n### 问题描述\n\n实际上，对于以上情况，我们很容易想到通过 WebSocket，对不同的用户进行隔离处理，当一个用户开始监控的时候，通过函数来逐个启动其所有的监控项目，当其停止监控的时候，取消相关监控，并且清除无关变量等。我们可以将所有内容写到 WebSocket 的连接回调中，由于作用域隔离，不同用户之间的监控（读操作）不会产生互相影响。\n\n这种方式可以说是最为快捷方便的方式了，并且几乎无需进行设计，但是这样有一个非常明显的效率问题：\n\n由于不同用户的部分监控项目是有重叠的，对于这些重叠的项目，我们如果对于每一个用户都单独监控，那么就会产生非常多的浪费，如果这些监控中还涉及到数据库交互或者较为复杂的计算，那么成倍之后的性能损失是非常难以承受的。\n\n所以，我们需要将不同用户重叠的那些监控项目，进行合并，合并成一个之后，如果有新的消息，我们就推到所有相关用户的回调函数中去处理。\n\n也就是说，我们需要管理一个一对多的订阅发布模式。\n\n到这里，我们发现我们想要实现这样一个监控系统，并不是非常简单，主要有下列问题：\n\n* [1]对于可能有用户重叠的监控项目，我们需要抽离到用户作用域之外，并且通过统计计数等方式来\"记住\"当前所有的监控用户，当有新内容时推到各个用户的处理函数中，并且当最后一个用户取消监控的时候要及时清理相关对象。\n* [2]不同用户的重叠监控项目的监控方式也各不相同，有的是通过 `setInterval` 等方式的定时任务，有的是事件监听器等等。\n* [3]判断不同用户的项目是否重叠也有一定的争议，比如假设不同用户端监控的是同一个项目，调用的也是相同的函数，但是由于用户 ID 不同，这个时候我们如何判断是否算\"同一个监控\"？\n\n以上的这些问题，如果我们不借助现有的库和工具，自己顺着思路一点点去写，则很容易陷入修修补补的循环，无法专注监控本身，并且最后甚至在效率上适得其反。\n\n### 解决方案\n\n以下解决方案基于 Rx.js，需要对 [Observable](https://cn.rx.js.org/class/es6/Observable.js~Observable.html) 有一定了解。\n\n#### 多个用户的监控以及取消\n\n[Monitor-RX](https://github.com/aircloud/monitor-rx) 是对以上场景问题的一个解决方案封装，其利用了 Rx.js 对订阅发布的管理能力，可以让整个流程变的清晰。\n\n在 Rx.js 中，我们可以通过以下方式建立一个多播对象 `multicasted`：\n\n```\nvar source = Rx.from([1, 2, 3]);\nvar subject = new Rx.Subject();\nvar multicasted = source.pipe(multicast(subject)).refCount();\n// 其属于 monitor-rx 的实现细节，无需理解亦可使用 monitor-rx\n\nsubscription1 = refCounted.subscribe({\n    next: (v) => console.log('observerA: ' + JSON.stringify(v))\n});\n\nsetTimeout(() => {\n    subscription2 = refCounted.subscribe({\n        next: (v) => console.log('observerB: ' + JSON.stringify(v))\n    });\n}, 1200);\n\nsubscription1.unsubscribe();\nsetTimeout(() => {\n    subscription2.unsubscribe();\n    // 这里 refCounted 的 unsubscribe 相关清理逻辑会自动被调用\n}, 3200);\n```\n\n在这里采用多播，有如下几个好处：\n\n* 可以随时增加新的订阅者，并且新的订阅者只会收到其加入订阅之后的数据。\n* 可以随时对任意一个订阅者取消订阅。\n* 当所有订阅者取消订阅之后，Observable 会自动触发 Observable 函数，从而可以对其事件循环等进行清理。\n\n以上能力其实可以帮助我们解决上文提到的问题 [1]。\n\n#### 监控格式的统一\n\n实际上，在我们的监控系统中，从数据依赖的角度，我们的监控函数会有这样几类：\n\n* [a]纯粹的定时任务，无数据依赖，这方面比如当前内存快照数据等。\n* [b]带有记忆依赖的定时任务：定时任务依赖前一次的数据（甚至更多次），需要两次数据做差等，这方面的数据比如一段时间的消耗数据，cpu 使用率的计算。\n* [c]带有用户依赖的定时任务：依赖用户 id 等信息，不同用户无法共用。\n\n而从任务触发的角度，我们仍待可以对其分类：\n\n* [i]简单的 `setInterval` 定时任务。\n* [ii]基于事件机制的不定时任务。\n* [iii]基于其他触发机制的任务。\n\n实际上，我们如果采用 Rx.js 的模式进行编写，无需考虑任务的数据依赖和触发的方式，只需写成一个一个 Observable 实例即可。另外，对于比较简单的 [a]&[i] 或 [c]&[i]  类型，我们还可以通过 monitor-rx 提供的 `convertToRx` 或 `convertToSimpleRx` 转换成 Observable 实例生成函数，例如：\n\n```\nvar os = require('os');\nvar process = require('process');\nconst monitorRx = require('monitor-rx');\n\nfunction getMemoryInfo() {\n    return process.memoryUsage();\n}\n\nconst memory = monitorRx.Utils.convertToSimpleRx(getMemoryInfo)\n\n// 或者\n//const memory = monitorRx.Utils.convertToRx({\n//    getMemoryInfo\n//});\n\nmodule.exports = memory;\n```\n\nconvertToRx 相比于 convertToSimpleRx，可以支持函数配置注入（即下文中 opts 的 func 属性和 args 属性）,可以在具体生成 Observable 实例的时候具体指定使用哪些函数以及其参数。\n\n如果是比较复杂的 Observable 类型，那么我们就无法直接通过普通函数进行转化了，这个时候我们遵循 Observable 的标准返回 Observable 生成函数即可（不是直接返回 Observable 实例） \n\n这实际上也对问题 [2] 进行了解决。\n\n#### 监控唯一性：\n\n我们知道，如果两个用户都监控同一个信息，我们可以共用一个 Observable，这里的问题，就是如何定义两个用户的监控是\"相同\"的。\n\n这里我们采用一个可选项 opts 的概念，其一共有如下属性：\n\n```\n{\n    module: 'ModuleName',\n    func: ['FuncName'],\n    args: [['arg1','arg2']],\n    opts: {interval:1000}, \n}\n```\n\nmodule 即用户是对哪一个模块进行监控（实际上是 Observable），func 和 args 则是监控过程中需要调用的函数，我们也可以通过 agrs 传入用户个人信息。于没有内部子函数调用的监控，二者为空即可，opts 是一些其他可选项，比如定义请求间隔等。\n\n之后，我们通过 `JSON.stringify(opts)` 来序列化这个可选项配置，如果两个用户序列化后的可选项配置相同，那么我们就认为这两个用户可以共用一个监控，即共用一个 Observable。\n\n### 更多内容\n\n实际上，借助 Monitor-RX，我们可以很方便的解决上述提出的问题，Monitor-RX 也在积极的更新中，大家可以在[这里](https://github.com/aircloud/monitor-rx)了解到更多的信息。","slug":"使用 Node.js 打造多用户实时监控系统","published":1,"updated":"2021-12-23T05:50:07.544Z","_id":"ckxijpqsw000td3mrfo133gi8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"背景概述\"><a href=\"#背景概述\" class=\"headerlink\" title=\"背景概述\"></a>背景概述</h3><p>首先描述一下笔者遇到的问题，我们可以设定这样一个场景：现在有一个实时监控系统的开发需求，要求同时支持多个用户（这里我们为了简化，暂时不涉及登陆态，假定一个设备即为一个用户），对于不同的用户来讲，他们需要监控的一部分内容是完全相同的，比如设备的 CPU 信息、内存信息等，而另外一部分内容是部分用户重叠的，比如对某一区域的用户来说某些监控信息是相同的，而还有一些信息，则是用户之间完全不同的。</p>\n<p>对于每个用户来讲，当其进入页面之后即表明其开始监控，需要持续地进行数据更新，而当其退出界面或者手动点击停止监控，则停止监控。</p>\n<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>实际上，对于以上情况，我们很容易想到通过 WebSocket，对不同的用户进行隔离处理，当一个用户开始监控的时候，通过函数来逐个启动其所有的监控项目，当其停止监控的时候，取消相关监控，并且清除无关变量等。我们可以将所有内容写到 WebSocket 的连接回调中，由于作用域隔离，不同用户之间的监控（读操作）不会产生互相影响。</p>\n<p>这种方式可以说是最为快捷方便的方式了，并且几乎无需进行设计，但是这样有一个非常明显的效率问题：</p>\n<p>由于不同用户的部分监控项目是有重叠的，对于这些重叠的项目，我们如果对于每一个用户都单独监控，那么就会产生非常多的浪费，如果这些监控中还涉及到数据库交互或者较为复杂的计算，那么成倍之后的性能损失是非常难以承受的。</p>\n<p>所以，我们需要将不同用户重叠的那些监控项目，进行合并，合并成一个之后，如果有新的消息，我们就推到所有相关用户的回调函数中去处理。</p>\n<p>也就是说，我们需要管理一个一对多的订阅发布模式。</p>\n<p>到这里，我们发现我们想要实现这样一个监控系统，并不是非常简单，主要有下列问题：</p>\n<ul>\n<li>[1]对于可能有用户重叠的监控项目，我们需要抽离到用户作用域之外，并且通过统计计数等方式来”记住”当前所有的监控用户，当有新内容时推到各个用户的处理函数中，并且当最后一个用户取消监控的时候要及时清理相关对象。</li>\n<li>[2]不同用户的重叠监控项目的监控方式也各不相同，有的是通过 <code>setInterval</code> 等方式的定时任务，有的是事件监听器等等。</li>\n<li>[3]判断不同用户的项目是否重叠也有一定的争议，比如假设不同用户端监控的是同一个项目，调用的也是相同的函数，但是由于用户 ID 不同，这个时候我们如何判断是否算”同一个监控”？</li>\n</ul>\n<p>以上的这些问题，如果我们不借助现有的库和工具，自己顺着思路一点点去写，则很容易陷入修修补补的循环，无法专注监控本身，并且最后甚至在效率上适得其反。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>以下解决方案基于 Rx.js，需要对 <a href=\"https://cn.rx.js.org/class/es6/Observable.js~Observable.html\">Observable</a> 有一定了解。</p>\n<h4 id=\"多个用户的监控以及取消\"><a href=\"#多个用户的监控以及取消\" class=\"headerlink\" title=\"多个用户的监控以及取消\"></a>多个用户的监控以及取消</h4><p><a href=\"https://github.com/aircloud/monitor-rx\">Monitor-RX</a> 是对以上场景问题的一个解决方案封装，其利用了 Rx.js 对订阅发布的管理能力，可以让整个流程变的清晰。</p>\n<p>在 Rx.js 中，我们可以通过以下方式建立一个多播对象 <code>multicasted</code>：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var source = Rx.<span class=\"keyword\">from</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">var subject = <span class=\"keyword\">new</span> Rx.Subject();</span><br><span class=\"line\">var multicasted = source.pipe(multicast(subject)).refCount();</span><br><span class=\"line\"><span class=\"regexp\">//</span> 其属于 monitor-rx 的实现细节，无需理解亦可使用 monitor-rx</span><br><span class=\"line\"></span><br><span class=\"line\">subscription1 = refCounted.subscribe(&#123;</span><br><span class=\"line\">    next: <span class=\"function\"><span class=\"params\">(v)</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;observerA: &#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(v))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    subscription2 = refCounted.subscribe(&#123;</span><br><span class=\"line\">        next: <span class=\"function\"><span class=\"params\">(v)</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;observerB: &#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(v))</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;, <span class=\"number\">1200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">subscription1.unsubscribe();</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    subscription2.unsubscribe();</span><br><span class=\"line\">    <span class=\"regexp\">//</span> 这里 refCounted 的 unsubscribe 相关清理逻辑会自动被调用</span><br><span class=\"line\">&#125;, <span class=\"number\">3200</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这里采用多播，有如下几个好处：</p>\n<ul>\n<li>可以随时增加新的订阅者，并且新的订阅者只会收到其加入订阅之后的数据。</li>\n<li>可以随时对任意一个订阅者取消订阅。</li>\n<li>当所有订阅者取消订阅之后，Observable 会自动触发 Observable 函数，从而可以对其事件循环等进行清理。</li>\n</ul>\n<p>以上能力其实可以帮助我们解决上文提到的问题 [1]。</p>\n<h4 id=\"监控格式的统一\"><a href=\"#监控格式的统一\" class=\"headerlink\" title=\"监控格式的统一\"></a>监控格式的统一</h4><p>实际上，在我们的监控系统中，从数据依赖的角度，我们的监控函数会有这样几类：</p>\n<ul>\n<li>[a]纯粹的定时任务，无数据依赖，这方面比如当前内存快照数据等。</li>\n<li>[b]带有记忆依赖的定时任务：定时任务依赖前一次的数据（甚至更多次），需要两次数据做差等，这方面的数据比如一段时间的消耗数据，cpu 使用率的计算。</li>\n<li>[c]带有用户依赖的定时任务：依赖用户 id 等信息，不同用户无法共用。</li>\n</ul>\n<p>而从任务触发的角度，我们仍待可以对其分类：</p>\n<ul>\n<li>[i]简单的 <code>setInterval</code> 定时任务。</li>\n<li>[ii]基于事件机制的不定时任务。</li>\n<li>[iii]基于其他触发机制的任务。</li>\n</ul>\n<p>实际上，我们如果采用 Rx.js 的模式进行编写，无需考虑任务的数据依赖和触发的方式，只需写成一个一个 Observable 实例即可。另外，对于比较简单的 [a]&amp;[i] 或 [c]&amp;[i]  类型，我们还可以通过 monitor-rx 提供的 <code>convertToRx</code> 或 <code>convertToSimpleRx</code> 转换成 Observable 实例生成函数，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> os = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;os&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> process = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;process&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> monitorRx = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;monitor-rx&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMemoryInfo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> process.memoryUsage();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> memory = monitorRx.Utils.convertToSimpleRx(getMemoryInfo)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"comment\">//const memory = monitorRx.Utils.convertToRx(&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    getMemoryInfo</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = memory;</span><br></pre></td></tr></table></figure>\n\n<p>convertToRx 相比于 convertToSimpleRx，可以支持函数配置注入（即下文中 opts 的 func 属性和 args 属性）,可以在具体生成 Observable 实例的时候具体指定使用哪些函数以及其参数。</p>\n<p>如果是比较复杂的 Observable 类型，那么我们就无法直接通过普通函数进行转化了，这个时候我们遵循 Observable 的标准返回 Observable 生成函数即可（不是直接返回 Observable 实例） </p>\n<p>这实际上也对问题 [2] 进行了解决。</p>\n<h4 id=\"监控唯一性：\"><a href=\"#监控唯一性：\" class=\"headerlink\" title=\"监控唯一性：\"></a>监控唯一性：</h4><p>我们知道，如果两个用户都监控同一个信息，我们可以共用一个 Observable，这里的问题，就是如何定义两个用户的监控是”相同”的。</p>\n<p>这里我们采用一个可选项 opts 的概念，其一共有如下属性：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: <span class=\"string\">&#x27;ModuleName&#x27;</span>,</span><br><span class=\"line\">    func: [<span class=\"string\">&#x27;FuncName&#x27;</span>],</span><br><span class=\"line\">    args: <span class=\"string\">[[&#x27;arg1&#x27;,&#x27;arg2&#x27;]]</span>,</span><br><span class=\"line\">    opts: &#123;interval:<span class=\"number\">1000</span>&#125;, </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>module 即用户是对哪一个模块进行监控（实际上是 Observable），func 和 args 则是监控过程中需要调用的函数，我们也可以通过 agrs 传入用户个人信息。于没有内部子函数调用的监控，二者为空即可，opts 是一些其他可选项，比如定义请求间隔等。</p>\n<p>之后，我们通过 <code>JSON.stringify(opts)</code> 来序列化这个可选项配置，如果两个用户序列化后的可选项配置相同，那么我们就认为这两个用户可以共用一个监控，即共用一个 Observable。</p>\n<h3 id=\"更多内容\"><a href=\"#更多内容\" class=\"headerlink\" title=\"更多内容\"></a>更多内容</h3><p>实际上，借助 Monitor-RX，我们可以很方便的解决上述提出的问题，Monitor-RX 也在积极的更新中，大家可以在<a href=\"https://github.com/aircloud/monitor-rx\">这里</a>了解到更多的信息。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"背景概述\"><a href=\"#背景概述\" class=\"headerlink\" title=\"背景概述\"></a>背景概述</h3><p>首先描述一下笔者遇到的问题，我们可以设定这样一个场景：现在有一个实时监控系统的开发需求，要求同时支持多个用户（这里我们为了简化，暂时不涉及登陆态，假定一个设备即为一个用户），对于不同的用户来讲，他们需要监控的一部分内容是完全相同的，比如设备的 CPU 信息、内存信息等，而另外一部分内容是部分用户重叠的，比如对某一区域的用户来说某些监控信息是相同的，而还有一些信息，则是用户之间完全不同的。</p>\n<p>对于每个用户来讲，当其进入页面之后即表明其开始监控，需要持续地进行数据更新，而当其退出界面或者手动点击停止监控，则停止监控。</p>\n<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>实际上，对于以上情况，我们很容易想到通过 WebSocket，对不同的用户进行隔离处理，当一个用户开始监控的时候，通过函数来逐个启动其所有的监控项目，当其停止监控的时候，取消相关监控，并且清除无关变量等。我们可以将所有内容写到 WebSocket 的连接回调中，由于作用域隔离，不同用户之间的监控（读操作）不会产生互相影响。</p>\n<p>这种方式可以说是最为快捷方便的方式了，并且几乎无需进行设计，但是这样有一个非常明显的效率问题：</p>\n<p>由于不同用户的部分监控项目是有重叠的，对于这些重叠的项目，我们如果对于每一个用户都单独监控，那么就会产生非常多的浪费，如果这些监控中还涉及到数据库交互或者较为复杂的计算，那么成倍之后的性能损失是非常难以承受的。</p>\n<p>所以，我们需要将不同用户重叠的那些监控项目，进行合并，合并成一个之后，如果有新的消息，我们就推到所有相关用户的回调函数中去处理。</p>\n<p>也就是说，我们需要管理一个一对多的订阅发布模式。</p>\n<p>到这里，我们发现我们想要实现这样一个监控系统，并不是非常简单，主要有下列问题：</p>\n<ul>\n<li>[1]对于可能有用户重叠的监控项目，我们需要抽离到用户作用域之外，并且通过统计计数等方式来”记住”当前所有的监控用户，当有新内容时推到各个用户的处理函数中，并且当最后一个用户取消监控的时候要及时清理相关对象。</li>\n<li>[2]不同用户的重叠监控项目的监控方式也各不相同，有的是通过 <code>setInterval</code> 等方式的定时任务，有的是事件监听器等等。</li>\n<li>[3]判断不同用户的项目是否重叠也有一定的争议，比如假设不同用户端监控的是同一个项目，调用的也是相同的函数，但是由于用户 ID 不同，这个时候我们如何判断是否算”同一个监控”？</li>\n</ul>\n<p>以上的这些问题，如果我们不借助现有的库和工具，自己顺着思路一点点去写，则很容易陷入修修补补的循环，无法专注监控本身，并且最后甚至在效率上适得其反。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>以下解决方案基于 Rx.js，需要对 <a href=\"https://cn.rx.js.org/class/es6/Observable.js~Observable.html\">Observable</a> 有一定了解。</p>\n<h4 id=\"多个用户的监控以及取消\"><a href=\"#多个用户的监控以及取消\" class=\"headerlink\" title=\"多个用户的监控以及取消\"></a>多个用户的监控以及取消</h4><p><a href=\"https://github.com/aircloud/monitor-rx\">Monitor-RX</a> 是对以上场景问题的一个解决方案封装，其利用了 Rx.js 对订阅发布的管理能力，可以让整个流程变的清晰。</p>\n<p>在 Rx.js 中，我们可以通过以下方式建立一个多播对象 <code>multicasted</code>：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var source = Rx.<span class=\"keyword\">from</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">var subject = <span class=\"keyword\">new</span> Rx.Subject();</span><br><span class=\"line\">var multicasted = source.pipe(multicast(subject)).refCount();</span><br><span class=\"line\"><span class=\"regexp\">//</span> 其属于 monitor-rx 的实现细节，无需理解亦可使用 monitor-rx</span><br><span class=\"line\"></span><br><span class=\"line\">subscription1 = refCounted.subscribe(&#123;</span><br><span class=\"line\">    next: <span class=\"function\"><span class=\"params\">(v)</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;observerA: &#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(v))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    subscription2 = refCounted.subscribe(&#123;</span><br><span class=\"line\">        next: <span class=\"function\"><span class=\"params\">(v)</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;observerB: &#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(v))</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;, <span class=\"number\">1200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">subscription1.unsubscribe();</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    subscription2.unsubscribe();</span><br><span class=\"line\">    <span class=\"regexp\">//</span> 这里 refCounted 的 unsubscribe 相关清理逻辑会自动被调用</span><br><span class=\"line\">&#125;, <span class=\"number\">3200</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这里采用多播，有如下几个好处：</p>\n<ul>\n<li>可以随时增加新的订阅者，并且新的订阅者只会收到其加入订阅之后的数据。</li>\n<li>可以随时对任意一个订阅者取消订阅。</li>\n<li>当所有订阅者取消订阅之后，Observable 会自动触发 Observable 函数，从而可以对其事件循环等进行清理。</li>\n</ul>\n<p>以上能力其实可以帮助我们解决上文提到的问题 [1]。</p>\n<h4 id=\"监控格式的统一\"><a href=\"#监控格式的统一\" class=\"headerlink\" title=\"监控格式的统一\"></a>监控格式的统一</h4><p>实际上，在我们的监控系统中，从数据依赖的角度，我们的监控函数会有这样几类：</p>\n<ul>\n<li>[a]纯粹的定时任务，无数据依赖，这方面比如当前内存快照数据等。</li>\n<li>[b]带有记忆依赖的定时任务：定时任务依赖前一次的数据（甚至更多次），需要两次数据做差等，这方面的数据比如一段时间的消耗数据，cpu 使用率的计算。</li>\n<li>[c]带有用户依赖的定时任务：依赖用户 id 等信息，不同用户无法共用。</li>\n</ul>\n<p>而从任务触发的角度，我们仍待可以对其分类：</p>\n<ul>\n<li>[i]简单的 <code>setInterval</code> 定时任务。</li>\n<li>[ii]基于事件机制的不定时任务。</li>\n<li>[iii]基于其他触发机制的任务。</li>\n</ul>\n<p>实际上，我们如果采用 Rx.js 的模式进行编写，无需考虑任务的数据依赖和触发的方式，只需写成一个一个 Observable 实例即可。另外，对于比较简单的 [a]&amp;[i] 或 [c]&amp;[i]  类型，我们还可以通过 monitor-rx 提供的 <code>convertToRx</code> 或 <code>convertToSimpleRx</code> 转换成 Observable 实例生成函数，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> os = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;os&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> process = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;process&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> monitorRx = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;monitor-rx&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMemoryInfo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> process.memoryUsage();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> memory = monitorRx.Utils.convertToSimpleRx(getMemoryInfo)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"comment\">//const memory = monitorRx.Utils.convertToRx(&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    getMemoryInfo</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = memory;</span><br></pre></td></tr></table></figure>\n\n<p>convertToRx 相比于 convertToSimpleRx，可以支持函数配置注入（即下文中 opts 的 func 属性和 args 属性）,可以在具体生成 Observable 实例的时候具体指定使用哪些函数以及其参数。</p>\n<p>如果是比较复杂的 Observable 类型，那么我们就无法直接通过普通函数进行转化了，这个时候我们遵循 Observable 的标准返回 Observable 生成函数即可（不是直接返回 Observable 实例） </p>\n<p>这实际上也对问题 [2] 进行了解决。</p>\n<h4 id=\"监控唯一性：\"><a href=\"#监控唯一性：\" class=\"headerlink\" title=\"监控唯一性：\"></a>监控唯一性：</h4><p>我们知道，如果两个用户都监控同一个信息，我们可以共用一个 Observable，这里的问题，就是如何定义两个用户的监控是”相同”的。</p>\n<p>这里我们采用一个可选项 opts 的概念，其一共有如下属性：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: <span class=\"string\">&#x27;ModuleName&#x27;</span>,</span><br><span class=\"line\">    func: [<span class=\"string\">&#x27;FuncName&#x27;</span>],</span><br><span class=\"line\">    args: <span class=\"string\">[[&#x27;arg1&#x27;,&#x27;arg2&#x27;]]</span>,</span><br><span class=\"line\">    opts: &#123;interval:<span class=\"number\">1000</span>&#125;, </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>module 即用户是对哪一个模块进行监控（实际上是 Observable），func 和 args 则是监控过程中需要调用的函数，我们也可以通过 agrs 传入用户个人信息。于没有内部子函数调用的监控，二者为空即可，opts 是一些其他可选项，比如定义请求间隔等。</p>\n<p>之后，我们通过 <code>JSON.stringify(opts)</code> 来序列化这个可选项配置，如果两个用户序列化后的可选项配置相同，那么我们就认为这两个用户可以共用一个监控，即共用一个 Observable。</p>\n<h3 id=\"更多内容\"><a href=\"#更多内容\" class=\"headerlink\" title=\"更多内容\"></a>更多内容</h3><p>实际上，借助 Monitor-RX，我们可以很方便的解决上述提出的问题，Monitor-RX 也在积极的更新中，大家可以在<a href=\"https://github.com/aircloud/monitor-rx\">这里</a>了解到更多的信息。</p>\n"},{"title":"使用 OpenCV 实现简单的人脸识别程序","abbrlink":78466600,"date":"2019-09-10T07:34:13.000Z","_content":"\n本问就 Mac 系统安装 OpenCV 以及实现一个简单的人脸识别程序进行记录。\n\n### 安装 OpenCV\n\n实际上，OpenCV 的安装方式比较多，这里为了避免一些第三方安装的问题，我们采用源代码方式安装。\n\n安全前请确保本机已经安装了 CMake 和 Xcode。\n\n我们去[ OpenCV 的网站](https://opencv.org/releases/) 下载源代码，选择 Release -> SourceCode，可以选择最新的 4.11 版本。\n\n这里以 4.1.1 版本为例，下载后我们解压到 `opencv-4.1.1`，然后进入到该目录，新建一个 release 目录用于存放我们构建好的内容，并进入到该目录：\n\n```\nmkdir release\ncd release/\n```\n\n然后我们依次执行以下命令安装：\n\n```\ncmake -G “Unix Makefiles” .. \nmake\nmake install\n```\n\n全部命令执行成功后，实际上就安装完成了，我们可以从最后的输出中看到，相关内容已经被安装到了 `/usr/local/include`、`/usr/local/lib` 等文件夹下。\n\n### 使用 Xcode 编写人脸识别程序\n\n我们可以使用 Xcode 建立一个命令行程序，这里我们还需要处理两个问题：\n\n* OpenCV 的引入\n* 摄像头权限的获取\n\n#### OpenCV 的引入\n\n对于第一点，我们在 **Build Setting** 的 **Search Paths** 中增加 Header 和 Library 的路径：\n\n![路径](/img/cv1.jpg)\n\n然后我们需要在 **Build Phases** 的 **Link Binary With Libraries** 中增加动态链接库。\n\n我们可以点击左下角加号，选择 `Add Others` 然后进入 `/usr/local/lib` 把 OpenCV 相关的库均包含进来即可。\n\n>实际上我们可以部分引入，但是由于我们是初步上手，全部引入也可以。\n\n#### 摄像头权限的获取\n\n这里如果我们直接运行我们的程序，在 macOS 最新的系统中是无法运行通过的，这里涉及到摄像头权限问题。\n\n一般来说，对于 macOS，我们需要在运行程序的目录下声明 `info.plist`, 这样程序在运行的时候系统会自动有申请权限的弹窗，对于我们测试场景下而言，我们可以这样做：\n\n* 进入我们 Product 存放的目录（注意不是项目代码目录，可以在 Products 条目右单击 `Show in Finder`）\n* 复制一个 info.plist（这里我们可以随便找一个本地安装的应用程序的 info.plist，一般右单击显示包内容即可看到）\n* 在 info.plist 中增加 `NSCameraUsageDescription`，value 即提示语，可以写比如 `摄像头权限的获取`。\n\n#### 书写并运行程序\n\n做完上述准备工作后，我们可以写我们的人脸识别程序了，这里给出一个成功运行的代码示例（参考了网上的一些例子）：\n\n```\n#include <iostream>\n#include <opencv2/opencv.hpp>\n\nusing namespace std;\nusing namespace cv;\n\nvoid capture();\n\n// 是否退出摄像头抓取线程\nstatic bool g_quit = false;\n\nint main(int argc, char** argv) {\n    capture();\n    return 0;\n}\n\nvoid capture()\n{\n    // 打开摄像头\n    cv::VideoCapture cap(0);\n    \n    // 如果打开失败，返回错误\n    if (!cap.isOpened())\n    {\n        cout<<\"Open Capture Failed\"<<endl;\n        return;\n    }\n    \n    // 人脸识别分类器\n    cv::CascadeClassifier faceCascadeClassifier(\"/usr/local/share/opencv4/haarcascades/haarcascade_frontalface_alt2.xml\");\n    \n    // 读取 Frame ，直到退出系统\n    while (!g_quit)\n    {\n        cv::Mat frame;\n        if (!cap.read(frame))\n        {\n            // 读取失败，返回错误\n            break;\n        }\n        \n        // 进行人脸识别\n        std::vector<cv::Rect> faces;\n        faceCascadeClassifier.detectMultiScale(frame, faces);\n        // 将人脸识别结果绘制到图片上\n        for (const auto& face : faces)\n        {\n            cout<<\"Find Face\"<<endl;\n            cv::rectangle(frame,\n                          cv::Point(face.x, face.y),\n                          cv::Point(face.x + face.width, face.y + face.height),\n                          CV_RGB(255, 0, 0),\n                          2);\n        }\n        imshow(\"Display Image\", frame);\n        waitKey(100);\n    }\n}\n```\n\n这里值得注意的是，我们这里使用的人脸识别分类器是 OpenCV 安装后自带的，你本机的目录可能并不是这一个（这个路径实际上安装好 OpenCV 之后会打印在控制台）。\n\n正常情况下，以上程序可以直接编译执行。","source":"_posts/使用OpenCV实现简单的人脸识别程序.md","raw":"---\ntitle: 使用 OpenCV 实现简单的人脸识别程序\ntags:\n  - OpenCV\nabbrlink: 78466600\ndate: 2019-09-10 15:34:13\n---\n\n本问就 Mac 系统安装 OpenCV 以及实现一个简单的人脸识别程序进行记录。\n\n### 安装 OpenCV\n\n实际上，OpenCV 的安装方式比较多，这里为了避免一些第三方安装的问题，我们采用源代码方式安装。\n\n安全前请确保本机已经安装了 CMake 和 Xcode。\n\n我们去[ OpenCV 的网站](https://opencv.org/releases/) 下载源代码，选择 Release -> SourceCode，可以选择最新的 4.11 版本。\n\n这里以 4.1.1 版本为例，下载后我们解压到 `opencv-4.1.1`，然后进入到该目录，新建一个 release 目录用于存放我们构建好的内容，并进入到该目录：\n\n```\nmkdir release\ncd release/\n```\n\n然后我们依次执行以下命令安装：\n\n```\ncmake -G “Unix Makefiles” .. \nmake\nmake install\n```\n\n全部命令执行成功后，实际上就安装完成了，我们可以从最后的输出中看到，相关内容已经被安装到了 `/usr/local/include`、`/usr/local/lib` 等文件夹下。\n\n### 使用 Xcode 编写人脸识别程序\n\n我们可以使用 Xcode 建立一个命令行程序，这里我们还需要处理两个问题：\n\n* OpenCV 的引入\n* 摄像头权限的获取\n\n#### OpenCV 的引入\n\n对于第一点，我们在 **Build Setting** 的 **Search Paths** 中增加 Header 和 Library 的路径：\n\n![路径](/img/cv1.jpg)\n\n然后我们需要在 **Build Phases** 的 **Link Binary With Libraries** 中增加动态链接库。\n\n我们可以点击左下角加号，选择 `Add Others` 然后进入 `/usr/local/lib` 把 OpenCV 相关的库均包含进来即可。\n\n>实际上我们可以部分引入，但是由于我们是初步上手，全部引入也可以。\n\n#### 摄像头权限的获取\n\n这里如果我们直接运行我们的程序，在 macOS 最新的系统中是无法运行通过的，这里涉及到摄像头权限问题。\n\n一般来说，对于 macOS，我们需要在运行程序的目录下声明 `info.plist`, 这样程序在运行的时候系统会自动有申请权限的弹窗，对于我们测试场景下而言，我们可以这样做：\n\n* 进入我们 Product 存放的目录（注意不是项目代码目录，可以在 Products 条目右单击 `Show in Finder`）\n* 复制一个 info.plist（这里我们可以随便找一个本地安装的应用程序的 info.plist，一般右单击显示包内容即可看到）\n* 在 info.plist 中增加 `NSCameraUsageDescription`，value 即提示语，可以写比如 `摄像头权限的获取`。\n\n#### 书写并运行程序\n\n做完上述准备工作后，我们可以写我们的人脸识别程序了，这里给出一个成功运行的代码示例（参考了网上的一些例子）：\n\n```\n#include <iostream>\n#include <opencv2/opencv.hpp>\n\nusing namespace std;\nusing namespace cv;\n\nvoid capture();\n\n// 是否退出摄像头抓取线程\nstatic bool g_quit = false;\n\nint main(int argc, char** argv) {\n    capture();\n    return 0;\n}\n\nvoid capture()\n{\n    // 打开摄像头\n    cv::VideoCapture cap(0);\n    \n    // 如果打开失败，返回错误\n    if (!cap.isOpened())\n    {\n        cout<<\"Open Capture Failed\"<<endl;\n        return;\n    }\n    \n    // 人脸识别分类器\n    cv::CascadeClassifier faceCascadeClassifier(\"/usr/local/share/opencv4/haarcascades/haarcascade_frontalface_alt2.xml\");\n    \n    // 读取 Frame ，直到退出系统\n    while (!g_quit)\n    {\n        cv::Mat frame;\n        if (!cap.read(frame))\n        {\n            // 读取失败，返回错误\n            break;\n        }\n        \n        // 进行人脸识别\n        std::vector<cv::Rect> faces;\n        faceCascadeClassifier.detectMultiScale(frame, faces);\n        // 将人脸识别结果绘制到图片上\n        for (const auto& face : faces)\n        {\n            cout<<\"Find Face\"<<endl;\n            cv::rectangle(frame,\n                          cv::Point(face.x, face.y),\n                          cv::Point(face.x + face.width, face.y + face.height),\n                          CV_RGB(255, 0, 0),\n                          2);\n        }\n        imshow(\"Display Image\", frame);\n        waitKey(100);\n    }\n}\n```\n\n这里值得注意的是，我们这里使用的人脸识别分类器是 OpenCV 安装后自带的，你本机的目录可能并不是这一个（这个路径实际上安装好 OpenCV 之后会打印在控制台）。\n\n正常情况下，以上程序可以直接编译执行。","slug":"使用OpenCV实现简单的人脸识别程序","published":1,"updated":"2021-12-23T05:50:07.545Z","_id":"ckxijpqsx000wd3mr703s9xc4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本问就 Mac 系统安装 OpenCV 以及实现一个简单的人脸识别程序进行记录。</p>\n<h3 id=\"安装-OpenCV\"><a href=\"#安装-OpenCV\" class=\"headerlink\" title=\"安装 OpenCV\"></a>安装 OpenCV</h3><p>实际上，OpenCV 的安装方式比较多，这里为了避免一些第三方安装的问题，我们采用源代码方式安装。</p>\n<p>安全前请确保本机已经安装了 CMake 和 Xcode。</p>\n<p>我们去<a href=\"https://opencv.org/releases/\"> OpenCV 的网站</a> 下载源代码，选择 Release -&gt; SourceCode，可以选择最新的 4.11 版本。</p>\n<p>这里以 4.1.1 版本为例，下载后我们解压到 <code>opencv-4.1.1</code>，然后进入到该目录，新建一个 release 目录用于存放我们构建好的内容，并进入到该目录：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir release</span><br><span class=\"line\">cd release/</span><br></pre></td></tr></table></figure>\n\n<p>然后我们依次执行以下命令安装：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake -G “Unix Makefiles” .. </span><br><span class=\"line\"><span class=\"built_in\">make</span></span><br><span class=\"line\"><span class=\"built_in\">make</span> install</span><br></pre></td></tr></table></figure>\n\n<p>全部命令执行成功后，实际上就安装完成了，我们可以从最后的输出中看到，相关内容已经被安装到了 <code>/usr/local/include</code>、<code>/usr/local/lib</code> 等文件夹下。</p>\n<h3 id=\"使用-Xcode-编写人脸识别程序\"><a href=\"#使用-Xcode-编写人脸识别程序\" class=\"headerlink\" title=\"使用 Xcode 编写人脸识别程序\"></a>使用 Xcode 编写人脸识别程序</h3><p>我们可以使用 Xcode 建立一个命令行程序，这里我们还需要处理两个问题：</p>\n<ul>\n<li>OpenCV 的引入</li>\n<li>摄像头权限的获取</li>\n</ul>\n<h4 id=\"OpenCV-的引入\"><a href=\"#OpenCV-的引入\" class=\"headerlink\" title=\"OpenCV 的引入\"></a>OpenCV 的引入</h4><p>对于第一点，我们在 <strong>Build Setting</strong> 的 <strong>Search Paths</strong> 中增加 Header 和 Library 的路径：</p>\n<p><img src=\"/img/cv1.jpg\" alt=\"路径\"></p>\n<p>然后我们需要在 <strong>Build Phases</strong> 的 <strong>Link Binary With Libraries</strong> 中增加动态链接库。</p>\n<p>我们可以点击左下角加号，选择 <code>Add Others</code> 然后进入 <code>/usr/local/lib</code> 把 OpenCV 相关的库均包含进来即可。</p>\n<blockquote>\n<p>实际上我们可以部分引入，但是由于我们是初步上手，全部引入也可以。</p>\n</blockquote>\n<h4 id=\"摄像头权限的获取\"><a href=\"#摄像头权限的获取\" class=\"headerlink\" title=\"摄像头权限的获取\"></a>摄像头权限的获取</h4><p>这里如果我们直接运行我们的程序，在 macOS 最新的系统中是无法运行通过的，这里涉及到摄像头权限问题。</p>\n<p>一般来说，对于 macOS，我们需要在运行程序的目录下声明 <code>info.plist</code>, 这样程序在运行的时候系统会自动有申请权限的弹窗，对于我们测试场景下而言，我们可以这样做：</p>\n<ul>\n<li>进入我们 Product 存放的目录（注意不是项目代码目录，可以在 Products 条目右单击 <code>Show in Finder</code>）</li>\n<li>复制一个 info.plist（这里我们可以随便找一个本地安装的应用程序的 info.plist，一般右单击显示包内容即可看到）</li>\n<li>在 info.plist 中增加 <code>NSCameraUsageDescription</code>，value 即提示语，可以写比如 <code>摄像头权限的获取</code>。</li>\n</ul>\n<h4 id=\"书写并运行程序\"><a href=\"#书写并运行程序\" class=\"headerlink\" title=\"书写并运行程序\"></a>书写并运行程序</h4><p>做完上述准备工作后，我们可以写我们的人脸识别程序了，这里给出一个成功运行的代码示例（参考了网上的一些例子）：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> cv;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">capture</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否退出摄像头抓取线程</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> g_quit = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">capture</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">capture</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打开摄像头</span></span><br><span class=\"line\">    <span class=\"function\">cv::VideoCapture <span class=\"title\">cap</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果打开失败，返回错误</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cap.<span class=\"built_in\">isOpened</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Open Capture Failed&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 人脸识别分类器</span></span><br><span class=\"line\">    <span class=\"function\">cv::CascadeClassifier <span class=\"title\">faceCascadeClassifier</span><span class=\"params\">(<span class=\"string\">&quot;/usr/local/share/opencv4/haarcascades/haarcascade_frontalface_alt2.xml&quot;</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 读取 Frame ，直到退出系统</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!g_quit)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cv::Mat frame;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cap.<span class=\"built_in\">read</span>(frame))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 读取失败，返回错误</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 进行人脸识别</span></span><br><span class=\"line\">        std::vector&lt;cv::Rect&gt; faces;</span><br><span class=\"line\">        faceCascadeClassifier.<span class=\"built_in\">detectMultiScale</span>(frame, faces);</span><br><span class=\"line\">        <span class=\"comment\">// 将人脸识别结果绘制到图片上</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; face : faces)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;Find Face&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            cv::<span class=\"built_in\">rectangle</span>(frame,</span><br><span class=\"line\">                          cv::<span class=\"built_in\">Point</span>(face.x, face.y),</span><br><span class=\"line\">                          cv::<span class=\"built_in\">Point</span>(face.x + face.width, face.y + face.height),</span><br><span class=\"line\">                          <span class=\"built_in\">CV_RGB</span>(<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">                          <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">imshow</span>(<span class=\"string\">&quot;Display Image&quot;</span>, frame);</span><br><span class=\"line\">        <span class=\"built_in\">waitKey</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里值得注意的是，我们这里使用的人脸识别分类器是 OpenCV 安装后自带的，你本机的目录可能并不是这一个（这个路径实际上安装好 OpenCV 之后会打印在控制台）。</p>\n<p>正常情况下，以上程序可以直接编译执行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本问就 Mac 系统安装 OpenCV 以及实现一个简单的人脸识别程序进行记录。</p>\n<h3 id=\"安装-OpenCV\"><a href=\"#安装-OpenCV\" class=\"headerlink\" title=\"安装 OpenCV\"></a>安装 OpenCV</h3><p>实际上，OpenCV 的安装方式比较多，这里为了避免一些第三方安装的问题，我们采用源代码方式安装。</p>\n<p>安全前请确保本机已经安装了 CMake 和 Xcode。</p>\n<p>我们去<a href=\"https://opencv.org/releases/\"> OpenCV 的网站</a> 下载源代码，选择 Release -&gt; SourceCode，可以选择最新的 4.11 版本。</p>\n<p>这里以 4.1.1 版本为例，下载后我们解压到 <code>opencv-4.1.1</code>，然后进入到该目录，新建一个 release 目录用于存放我们构建好的内容，并进入到该目录：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir release</span><br><span class=\"line\">cd release/</span><br></pre></td></tr></table></figure>\n\n<p>然后我们依次执行以下命令安装：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake -G “Unix Makefiles” .. </span><br><span class=\"line\"><span class=\"built_in\">make</span></span><br><span class=\"line\"><span class=\"built_in\">make</span> install</span><br></pre></td></tr></table></figure>\n\n<p>全部命令执行成功后，实际上就安装完成了，我们可以从最后的输出中看到，相关内容已经被安装到了 <code>/usr/local/include</code>、<code>/usr/local/lib</code> 等文件夹下。</p>\n<h3 id=\"使用-Xcode-编写人脸识别程序\"><a href=\"#使用-Xcode-编写人脸识别程序\" class=\"headerlink\" title=\"使用 Xcode 编写人脸识别程序\"></a>使用 Xcode 编写人脸识别程序</h3><p>我们可以使用 Xcode 建立一个命令行程序，这里我们还需要处理两个问题：</p>\n<ul>\n<li>OpenCV 的引入</li>\n<li>摄像头权限的获取</li>\n</ul>\n<h4 id=\"OpenCV-的引入\"><a href=\"#OpenCV-的引入\" class=\"headerlink\" title=\"OpenCV 的引入\"></a>OpenCV 的引入</h4><p>对于第一点，我们在 <strong>Build Setting</strong> 的 <strong>Search Paths</strong> 中增加 Header 和 Library 的路径：</p>\n<p><img src=\"/img/cv1.jpg\" alt=\"路径\"></p>\n<p>然后我们需要在 <strong>Build Phases</strong> 的 <strong>Link Binary With Libraries</strong> 中增加动态链接库。</p>\n<p>我们可以点击左下角加号，选择 <code>Add Others</code> 然后进入 <code>/usr/local/lib</code> 把 OpenCV 相关的库均包含进来即可。</p>\n<blockquote>\n<p>实际上我们可以部分引入，但是由于我们是初步上手，全部引入也可以。</p>\n</blockquote>\n<h4 id=\"摄像头权限的获取\"><a href=\"#摄像头权限的获取\" class=\"headerlink\" title=\"摄像头权限的获取\"></a>摄像头权限的获取</h4><p>这里如果我们直接运行我们的程序，在 macOS 最新的系统中是无法运行通过的，这里涉及到摄像头权限问题。</p>\n<p>一般来说，对于 macOS，我们需要在运行程序的目录下声明 <code>info.plist</code>, 这样程序在运行的时候系统会自动有申请权限的弹窗，对于我们测试场景下而言，我们可以这样做：</p>\n<ul>\n<li>进入我们 Product 存放的目录（注意不是项目代码目录，可以在 Products 条目右单击 <code>Show in Finder</code>）</li>\n<li>复制一个 info.plist（这里我们可以随便找一个本地安装的应用程序的 info.plist，一般右单击显示包内容即可看到）</li>\n<li>在 info.plist 中增加 <code>NSCameraUsageDescription</code>，value 即提示语，可以写比如 <code>摄像头权限的获取</code>。</li>\n</ul>\n<h4 id=\"书写并运行程序\"><a href=\"#书写并运行程序\" class=\"headerlink\" title=\"书写并运行程序\"></a>书写并运行程序</h4><p>做完上述准备工作后，我们可以写我们的人脸识别程序了，这里给出一个成功运行的代码示例（参考了网上的一些例子）：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> cv;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">capture</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否退出摄像头抓取线程</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> g_quit = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">capture</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">capture</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打开摄像头</span></span><br><span class=\"line\">    <span class=\"function\">cv::VideoCapture <span class=\"title\">cap</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果打开失败，返回错误</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cap.<span class=\"built_in\">isOpened</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Open Capture Failed&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 人脸识别分类器</span></span><br><span class=\"line\">    <span class=\"function\">cv::CascadeClassifier <span class=\"title\">faceCascadeClassifier</span><span class=\"params\">(<span class=\"string\">&quot;/usr/local/share/opencv4/haarcascades/haarcascade_frontalface_alt2.xml&quot;</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 读取 Frame ，直到退出系统</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!g_quit)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cv::Mat frame;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cap.<span class=\"built_in\">read</span>(frame))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 读取失败，返回错误</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 进行人脸识别</span></span><br><span class=\"line\">        std::vector&lt;cv::Rect&gt; faces;</span><br><span class=\"line\">        faceCascadeClassifier.<span class=\"built_in\">detectMultiScale</span>(frame, faces);</span><br><span class=\"line\">        <span class=\"comment\">// 将人脸识别结果绘制到图片上</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; face : faces)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;Find Face&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            cv::<span class=\"built_in\">rectangle</span>(frame,</span><br><span class=\"line\">                          cv::<span class=\"built_in\">Point</span>(face.x, face.y),</span><br><span class=\"line\">                          cv::<span class=\"built_in\">Point</span>(face.x + face.width, face.y + face.height),</span><br><span class=\"line\">                          <span class=\"built_in\">CV_RGB</span>(<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">                          <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">imshow</span>(<span class=\"string\">&quot;Display Image&quot;</span>, frame);</span><br><span class=\"line\">        <span class=\"built_in\">waitKey</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里值得注意的是，我们这里使用的人脸识别分类器是 OpenCV 安装后自带的，你本机的目录可能并不是这一个（这个路径实际上安装好 OpenCV 之后会打印在控制台）。</p>\n<p>正常情况下，以上程序可以直接编译执行。</p>\n"},{"title":"使用 Rust WebAssembly 0拷贝进行计算加速","abbrlink":2078658014,"date":"2020-06-26T06:47:03.000Z","_content":"\ndemo: https://github.com/aircloud/rust-wasm-demo  \n\n其他资料：[入门 Rust 开发 WebAssembly](https://zhuanlan.zhihu.com/p/104299612)\n\n一般来说，使用 WebAssembly 能够在一定程度上提高性能，不过有的时候我们也许会发现，使用 WebAssembly 之后，有的时候我们不仅发现性能没有提升，反而下降了许多甚至数倍，实际上这是因为，使用 WebAssembly 需要非常谨慎，有很多细节都会大幅度影响性能，比如：\n\n* 我们编译采用的是 debug 还是 release 方式。\n* 最后编译的结果是否采用了不同级别的优化，如果使用了 `opt-level = 's'` 那么通常速度也会下降很多。\n* 是否在 JS 和 rust 之间存在大量的数据拷贝，因为很多代码是工具链生成的，也许有的时候我们会忽视这一点。\n\n本文针对以上等一些问题特别是第三点，给出一个 wasm 优化的参考方案，并给出示例代码。\n\n### 编译优化\n\n我们在优化数据拷贝之前，对于编译我们可以做一些前置的简单的工作。\n\n* 检查 Cargo.toml 脚本中 `[profile.release]` 中的 `opt-level` 选项，确认我们所使用的值：\n\n```\nThis flag controls the optimization level.\n\n0: no optimizations, also turns on cfg(debug_assertions) (the default).\n1: basic optimizations.\n2: some optimizations.\n3: all optimizations.\ns: optimize for binary size.\nz: optimize for binary size, but also turn off loop vectorization.\nNote: The -O flag is an alias for -C opt-level=2.\n\nThe default is 0.\n```\n\n如果我们使用了 ‘s’ 或者 'z'，那么通常会牺牲一部分性能（对于 demo 而言，使用 'z'， wasm 的性能也只有 js 的 20%），因为其主要是对体积进行一定的优化，所以如果优化前的体积我们可以接受的话，通常不需要这样的优化。\n\n在以上的前提下，我们使用 `--release` 的方式编译，通常就可以了。\n\n### 减少拷贝\n\n在这之前，我们需要有一个认知：\n\n**通过 rust 工具链编译的 wasm 代码，所有参数传入都是需要拷贝一次的，包括我们传入 ArrayBuffer 等 Buffer 类型的参数。**这是由于 wasm 只能访问自己的线性内存，而这个拷贝，通常是我们在处理大规模计算的一个坎，有的时候虽然 wasm 计算快一点，但是拷贝的消耗还是比较大的，加之 js 有若干 v8 优化的加持，可能和 wasm 也相差不多。\n\n所以我们要把计算移植到 wasm 中的话，首先要解决的就是大规模数据拷贝的问题。\n\n这里的一般思路为：\n\n1. wasm 分配内存：调用 wasm 的方法，在 wasm 内存中分配空间，返回指针位置\n2. js 写入数据：js 端在 wasm 的 memory arraybuffer 上，按指针位置和数据量建立 view，把数据写入\n3. wasm 计算：调用 wasm 方法完成计算， 返回计算好的批量结果的指针位置和大小\n4. js 读取数据：js 端在 wasm 的 memory arraybuffer上，按指针位置和数据量建立 view，把数据读出\n\n接下来，我们通过一个 demo 来完成以上几点，demo 的主要功能为：\n\n* 初始化一个 ImageData，内容随机。\n* 分别使用 js 和 WebAssembly 进行高斯模糊计算，并计算二者的时间，进行对比。\n\n这里的 demo 只是辅助进行验证改方案的可行性并且给出一个示例，并不作为一个标准的 benchmark 去对比 js 和 WebAssembly 的性能，同时，也并没有 UI 展示，计算结果输出在控制台中。\n\n最终笔者运行的结果为，js 比 WebAssembly 慢 30% 左右。\n\n#### 1. wasm 分配内存\n\n这部分的通用做法，即我们在 wasm 的 rust 中分配一个数组（Vec），然后把其指针传递给 js：\n\n```\n// rust：\n#[wasm_bindgen]\npub fn new_buffer(key: String, len: usize) -> *const u8 {\n  // GlobalBufferStorage 是一个 lazy_static\n  let mut global_buffer_storage = GlobalBufferStorage.lock().unwrap();\n  let mut buffer = vec![255; len];\n  let ptr = buffer.as_ptr();\n  global_buffer_storage.buffer_map.insert(key, buffer);\n  ptr\n}\n```\n\n为了后续方便寻找到这段数据，我们可以使用一个 key 将这个 Vec 联系起来，并且在 Rust 中放入全局（可以使用 lazy_static!，因为这种类型的数据没有办法直接定义在全局），之后通过 key 来查找数据。\n\n在 js 中，我们就可以建立各种 TypedArray 对其进行操作：\n\n```\nconst ptr = this.wasm!.new_buffer(key, len);\nconst u8Arr = new Uint8ClampedArray(this.wasm!.get_wasm_buffer(), ptr, len);\n```\n\n**这个时候，我们在 js 或 rust 任何一侧改了这个数据之后，都可以在另外一侧访问到。**\n\n实际上，在 js 侧的比如 [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData/ImageData) 等一些对象中，也支持我们传递一个 TypedArray 进行初始化，这让我们在比如 canvas 等应用场景下，使用 wasm 分配的内存更为方便。\n\n```\nconst imageData = new ImageData(u8Arr, width, height);\n```\n\n#### 2. js 写入数据\n\n如果我们需要在 js 侧写入数据，实际上这个时候我们得到的 TypedArray 已经和直接使用 js new 的 TypedArray 在使用上没有差别，可以正常按照数组的方式进行数据写入。\n\n不过，这里需要注意的是，js 写入通过 wasm 分配内存建立的 TypedArray，有些场景下在一定程度上速度要慢于直接使用 js new 的 TypedArray（不过在笔者的测试数据中，wasm 分配的方式反而是更快的），所以如果我们是一个高频的数据写入的场景，比如帧数据等，这个时候最好进行一次对比测试。\n\n\n#### 3. wasm 计算\n\n当我们真正需要进行计算的时候，我们可以调用 wasm 的计算函数，并且传入上文中定义的 key，这样 wasm 的 rust 函数可以直接找到这段数据，这里我们的 demo 为一段计算卷积的函数：\n\n```\n#[wasm_bindgen]\npub fn convolution(key: String, width: usize, height: usize, kernel: Vec<i32>) {\n  let mut global_buffer_storage = GlobalBufferStorage.lock().unwrap();\n  let kernel_length = kernel.iter().sum::<i32>() as i32;\n  if let Some(buffer) = global_buffer_storage.buffer_map.get_mut(&key) {\n    for i in 1..width-1 {\n      for j in 1..height-1 {\n        let mut newR: i32 = 0;\n        let mut newG: i32 = 0;\n        let mut newB: i32 = 0;\n        for x in 0..3 { // 取前后左右共9个格子\n          for y in 0..3 {\n            newR += buffer[width * (j + y - 1) * 4 + (i + x - 1) * 4 + 0] as i32 * kernel[y * 3 + x] / kernel_length;\n            newG += buffer[width * (j + y - 1) * 4 + (i + x - 1) * 4 + 1] as i32 * kernel[y * 3 + x] / kernel_length;\n            newB += buffer[width * (j + y - 1) * 4 + (i + x - 1) * 4 + 2] as i32 * kernel[y * 3 + x] / kernel_length;\n          }\n        }\n        buffer[width * j * 4 + i * 4 + 0] = newR as u8;\n        buffer[width * j * 4 + i * 4 + 1] = newG as u8;\n        buffer[width * j * 4 + i * 4 + 2] = newB as u8;\n      }\n    }\n  } else {\n    return ();\n  }\n}\n```\n\n因为这段函数对应操作的内存数据实际上已经在 wasm 和 js 之间共享了，所以也是不需要返回值的，等计算完成后 js 直接去读之前建立的 TypedArray，甚至直接使用通过 TypedArray 创建的 ImageData，进行绘制上屏等后续操作。\n\n#### 4. js 读取数据\n\n在 demo 中，我们可以直接通过 `CanvasRenderingContext2D.putImageData()` 传入之前获取的 imageData，绘制上屏。\n\n### 其他方案\n\n实际上，我们如果目的是加速 js 计算，不仅仅有 WebAssembly 这一个方案可以选择，如果我们的环境中拥有可以访问 Node 的能力或者可以访问原生模块的能力（比如，我们的应用运行在 electron 环境，或者是一些移动客户端），也可以采用比如 addon 的方式来运行我们的计算部分，相比于 wasm，这部分的优缺点在于：\n\n优点：\n\n* 通常可以更好的控制优化，甚至做到汇编级别的优化定制，性能提升空间更高（同样也可能会面临数据拷贝的问题，也需要一定方式减少拷贝）。\n* 在重 addon 的环境下（例如，其他大量功能也依赖 addon），可以更好的处理函数调用关系、依赖库使用等，一定程度上减少体积和增加开发的便捷性，而 wasm 会被编译成一个独立的二进制文件，处于沙盒环境中，无法直接调用其他的动态库。\n\n缺点：\n\n* 无法做到像 wasm 一样跨平台，并且可以同时运行在网页、桌面环境、移动端等任何 Webview 存在的环境中。\n\n不过总之，如果使用得当，二者的性能都是可以优于原生的 js，都可以作为优化方案考虑。\n","source":"_posts/使用RustWebAssembly0拷贝进行计算加速.md","raw":"---\ntitle: 使用 Rust WebAssembly 0拷贝进行计算加速\ntags:\n  - rust\nabbrlink: 2078658014\ndate: 2020-06-26 14:47:03\n---\n\ndemo: https://github.com/aircloud/rust-wasm-demo  \n\n其他资料：[入门 Rust 开发 WebAssembly](https://zhuanlan.zhihu.com/p/104299612)\n\n一般来说，使用 WebAssembly 能够在一定程度上提高性能，不过有的时候我们也许会发现，使用 WebAssembly 之后，有的时候我们不仅发现性能没有提升，反而下降了许多甚至数倍，实际上这是因为，使用 WebAssembly 需要非常谨慎，有很多细节都会大幅度影响性能，比如：\n\n* 我们编译采用的是 debug 还是 release 方式。\n* 最后编译的结果是否采用了不同级别的优化，如果使用了 `opt-level = 's'` 那么通常速度也会下降很多。\n* 是否在 JS 和 rust 之间存在大量的数据拷贝，因为很多代码是工具链生成的，也许有的时候我们会忽视这一点。\n\n本文针对以上等一些问题特别是第三点，给出一个 wasm 优化的参考方案，并给出示例代码。\n\n### 编译优化\n\n我们在优化数据拷贝之前，对于编译我们可以做一些前置的简单的工作。\n\n* 检查 Cargo.toml 脚本中 `[profile.release]` 中的 `opt-level` 选项，确认我们所使用的值：\n\n```\nThis flag controls the optimization level.\n\n0: no optimizations, also turns on cfg(debug_assertions) (the default).\n1: basic optimizations.\n2: some optimizations.\n3: all optimizations.\ns: optimize for binary size.\nz: optimize for binary size, but also turn off loop vectorization.\nNote: The -O flag is an alias for -C opt-level=2.\n\nThe default is 0.\n```\n\n如果我们使用了 ‘s’ 或者 'z'，那么通常会牺牲一部分性能（对于 demo 而言，使用 'z'， wasm 的性能也只有 js 的 20%），因为其主要是对体积进行一定的优化，所以如果优化前的体积我们可以接受的话，通常不需要这样的优化。\n\n在以上的前提下，我们使用 `--release` 的方式编译，通常就可以了。\n\n### 减少拷贝\n\n在这之前，我们需要有一个认知：\n\n**通过 rust 工具链编译的 wasm 代码，所有参数传入都是需要拷贝一次的，包括我们传入 ArrayBuffer 等 Buffer 类型的参数。**这是由于 wasm 只能访问自己的线性内存，而这个拷贝，通常是我们在处理大规模计算的一个坎，有的时候虽然 wasm 计算快一点，但是拷贝的消耗还是比较大的，加之 js 有若干 v8 优化的加持，可能和 wasm 也相差不多。\n\n所以我们要把计算移植到 wasm 中的话，首先要解决的就是大规模数据拷贝的问题。\n\n这里的一般思路为：\n\n1. wasm 分配内存：调用 wasm 的方法，在 wasm 内存中分配空间，返回指针位置\n2. js 写入数据：js 端在 wasm 的 memory arraybuffer 上，按指针位置和数据量建立 view，把数据写入\n3. wasm 计算：调用 wasm 方法完成计算， 返回计算好的批量结果的指针位置和大小\n4. js 读取数据：js 端在 wasm 的 memory arraybuffer上，按指针位置和数据量建立 view，把数据读出\n\n接下来，我们通过一个 demo 来完成以上几点，demo 的主要功能为：\n\n* 初始化一个 ImageData，内容随机。\n* 分别使用 js 和 WebAssembly 进行高斯模糊计算，并计算二者的时间，进行对比。\n\n这里的 demo 只是辅助进行验证改方案的可行性并且给出一个示例，并不作为一个标准的 benchmark 去对比 js 和 WebAssembly 的性能，同时，也并没有 UI 展示，计算结果输出在控制台中。\n\n最终笔者运行的结果为，js 比 WebAssembly 慢 30% 左右。\n\n#### 1. wasm 分配内存\n\n这部分的通用做法，即我们在 wasm 的 rust 中分配一个数组（Vec），然后把其指针传递给 js：\n\n```\n// rust：\n#[wasm_bindgen]\npub fn new_buffer(key: String, len: usize) -> *const u8 {\n  // GlobalBufferStorage 是一个 lazy_static\n  let mut global_buffer_storage = GlobalBufferStorage.lock().unwrap();\n  let mut buffer = vec![255; len];\n  let ptr = buffer.as_ptr();\n  global_buffer_storage.buffer_map.insert(key, buffer);\n  ptr\n}\n```\n\n为了后续方便寻找到这段数据，我们可以使用一个 key 将这个 Vec 联系起来，并且在 Rust 中放入全局（可以使用 lazy_static!，因为这种类型的数据没有办法直接定义在全局），之后通过 key 来查找数据。\n\n在 js 中，我们就可以建立各种 TypedArray 对其进行操作：\n\n```\nconst ptr = this.wasm!.new_buffer(key, len);\nconst u8Arr = new Uint8ClampedArray(this.wasm!.get_wasm_buffer(), ptr, len);\n```\n\n**这个时候，我们在 js 或 rust 任何一侧改了这个数据之后，都可以在另外一侧访问到。**\n\n实际上，在 js 侧的比如 [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData/ImageData) 等一些对象中，也支持我们传递一个 TypedArray 进行初始化，这让我们在比如 canvas 等应用场景下，使用 wasm 分配的内存更为方便。\n\n```\nconst imageData = new ImageData(u8Arr, width, height);\n```\n\n#### 2. js 写入数据\n\n如果我们需要在 js 侧写入数据，实际上这个时候我们得到的 TypedArray 已经和直接使用 js new 的 TypedArray 在使用上没有差别，可以正常按照数组的方式进行数据写入。\n\n不过，这里需要注意的是，js 写入通过 wasm 分配内存建立的 TypedArray，有些场景下在一定程度上速度要慢于直接使用 js new 的 TypedArray（不过在笔者的测试数据中，wasm 分配的方式反而是更快的），所以如果我们是一个高频的数据写入的场景，比如帧数据等，这个时候最好进行一次对比测试。\n\n\n#### 3. wasm 计算\n\n当我们真正需要进行计算的时候，我们可以调用 wasm 的计算函数，并且传入上文中定义的 key，这样 wasm 的 rust 函数可以直接找到这段数据，这里我们的 demo 为一段计算卷积的函数：\n\n```\n#[wasm_bindgen]\npub fn convolution(key: String, width: usize, height: usize, kernel: Vec<i32>) {\n  let mut global_buffer_storage = GlobalBufferStorage.lock().unwrap();\n  let kernel_length = kernel.iter().sum::<i32>() as i32;\n  if let Some(buffer) = global_buffer_storage.buffer_map.get_mut(&key) {\n    for i in 1..width-1 {\n      for j in 1..height-1 {\n        let mut newR: i32 = 0;\n        let mut newG: i32 = 0;\n        let mut newB: i32 = 0;\n        for x in 0..3 { // 取前后左右共9个格子\n          for y in 0..3 {\n            newR += buffer[width * (j + y - 1) * 4 + (i + x - 1) * 4 + 0] as i32 * kernel[y * 3 + x] / kernel_length;\n            newG += buffer[width * (j + y - 1) * 4 + (i + x - 1) * 4 + 1] as i32 * kernel[y * 3 + x] / kernel_length;\n            newB += buffer[width * (j + y - 1) * 4 + (i + x - 1) * 4 + 2] as i32 * kernel[y * 3 + x] / kernel_length;\n          }\n        }\n        buffer[width * j * 4 + i * 4 + 0] = newR as u8;\n        buffer[width * j * 4 + i * 4 + 1] = newG as u8;\n        buffer[width * j * 4 + i * 4 + 2] = newB as u8;\n      }\n    }\n  } else {\n    return ();\n  }\n}\n```\n\n因为这段函数对应操作的内存数据实际上已经在 wasm 和 js 之间共享了，所以也是不需要返回值的，等计算完成后 js 直接去读之前建立的 TypedArray，甚至直接使用通过 TypedArray 创建的 ImageData，进行绘制上屏等后续操作。\n\n#### 4. js 读取数据\n\n在 demo 中，我们可以直接通过 `CanvasRenderingContext2D.putImageData()` 传入之前获取的 imageData，绘制上屏。\n\n### 其他方案\n\n实际上，我们如果目的是加速 js 计算，不仅仅有 WebAssembly 这一个方案可以选择，如果我们的环境中拥有可以访问 Node 的能力或者可以访问原生模块的能力（比如，我们的应用运行在 electron 环境，或者是一些移动客户端），也可以采用比如 addon 的方式来运行我们的计算部分，相比于 wasm，这部分的优缺点在于：\n\n优点：\n\n* 通常可以更好的控制优化，甚至做到汇编级别的优化定制，性能提升空间更高（同样也可能会面临数据拷贝的问题，也需要一定方式减少拷贝）。\n* 在重 addon 的环境下（例如，其他大量功能也依赖 addon），可以更好的处理函数调用关系、依赖库使用等，一定程度上减少体积和增加开发的便捷性，而 wasm 会被编译成一个独立的二进制文件，处于沙盒环境中，无法直接调用其他的动态库。\n\n缺点：\n\n* 无法做到像 wasm 一样跨平台，并且可以同时运行在网页、桌面环境、移动端等任何 Webview 存在的环境中。\n\n不过总之，如果使用得当，二者的性能都是可以优于原生的 js，都可以作为优化方案考虑。\n","slug":"使用RustWebAssembly0拷贝进行计算加速","published":1,"updated":"2021-12-23T05:50:07.546Z","_id":"ckxijpqsy000xd3mr42lnfyrt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>demo: <a href=\"https://github.com/aircloud/rust-wasm-demo\">https://github.com/aircloud/rust-wasm-demo</a>  </p>\n<p>其他资料：<a href=\"https://zhuanlan.zhihu.com/p/104299612\">入门 Rust 开发 WebAssembly</a></p>\n<p>一般来说，使用 WebAssembly 能够在一定程度上提高性能，不过有的时候我们也许会发现，使用 WebAssembly 之后，有的时候我们不仅发现性能没有提升，反而下降了许多甚至数倍，实际上这是因为，使用 WebAssembly 需要非常谨慎，有很多细节都会大幅度影响性能，比如：</p>\n<ul>\n<li>我们编译采用的是 debug 还是 release 方式。</li>\n<li>最后编译的结果是否采用了不同级别的优化，如果使用了 <code>opt-level = &#39;s&#39;</code> 那么通常速度也会下降很多。</li>\n<li>是否在 JS 和 rust 之间存在大量的数据拷贝，因为很多代码是工具链生成的，也许有的时候我们会忽视这一点。</li>\n</ul>\n<p>本文针对以上等一些问题特别是第三点，给出一个 wasm 优化的参考方案，并给出示例代码。</p>\n<h3 id=\"编译优化\"><a href=\"#编译优化\" class=\"headerlink\" title=\"编译优化\"></a>编译优化</h3><p>我们在优化数据拷贝之前，对于编译我们可以做一些前置的简单的工作。</p>\n<ul>\n<li>检查 Cargo.toml 脚本中 <code>[profile.release]</code> 中的 <code>opt-level</code> 选项，确认我们所使用的值：</li>\n</ul>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This flag controls the optimization <span class=\"keyword\">level</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span>: <span class=\"keyword\">no</span> optimizations, <span class=\"keyword\">also</span> turns <span class=\"keyword\">on</span> cfg(debug_assertions) (the <span class=\"keyword\">default</span>).</span><br><span class=\"line\"><span class=\"number\">1</span>: basic optimizations.</span><br><span class=\"line\"><span class=\"number\">2</span>: <span class=\"keyword\">some</span> optimizations.</span><br><span class=\"line\"><span class=\"number\">3</span>: <span class=\"keyword\">all</span> optimizations.</span><br><span class=\"line\">s: optimize <span class=\"keyword\">for</span> binary size.</span><br><span class=\"line\">z: optimize <span class=\"keyword\">for</span> binary size, but <span class=\"keyword\">also</span> turn <span class=\"keyword\">off</span> <span class=\"keyword\">loop</span> vectorization.</span><br><span class=\"line\">Note: The -O flag <span class=\"keyword\">is</span> an <span class=\"keyword\">alias</span> <span class=\"keyword\">for</span> -C opt-<span class=\"keyword\">level</span>=<span class=\"number\">2.</span></span><br><span class=\"line\"></span><br><span class=\"line\">The <span class=\"keyword\">default</span> <span class=\"keyword\">is</span> <span class=\"number\">0.</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们使用了 ‘s’ 或者 ‘z’，那么通常会牺牲一部分性能（对于 demo 而言，使用 ‘z’， wasm 的性能也只有 js 的 20%），因为其主要是对体积进行一定的优化，所以如果优化前的体积我们可以接受的话，通常不需要这样的优化。</p>\n<p>在以上的前提下，我们使用 <code>--release</code> 的方式编译，通常就可以了。</p>\n<h3 id=\"减少拷贝\"><a href=\"#减少拷贝\" class=\"headerlink\" title=\"减少拷贝\"></a>减少拷贝</h3><p>在这之前，我们需要有一个认知：</p>\n<p><strong>通过 rust 工具链编译的 wasm 代码，所有参数传入都是需要拷贝一次的，包括我们传入 ArrayBuffer 等 Buffer 类型的参数。</strong>这是由于 wasm 只能访问自己的线性内存，而这个拷贝，通常是我们在处理大规模计算的一个坎，有的时候虽然 wasm 计算快一点，但是拷贝的消耗还是比较大的，加之 js 有若干 v8 优化的加持，可能和 wasm 也相差不多。</p>\n<p>所以我们要把计算移植到 wasm 中的话，首先要解决的就是大规模数据拷贝的问题。</p>\n<p>这里的一般思路为：</p>\n<ol>\n<li>wasm 分配内存：调用 wasm 的方法，在 wasm 内存中分配空间，返回指针位置</li>\n<li>js 写入数据：js 端在 wasm 的 memory arraybuffer 上，按指针位置和数据量建立 view，把数据写入</li>\n<li>wasm 计算：调用 wasm 方法完成计算， 返回计算好的批量结果的指针位置和大小</li>\n<li>js 读取数据：js 端在 wasm 的 memory arraybuffer上，按指针位置和数据量建立 view，把数据读出</li>\n</ol>\n<p>接下来，我们通过一个 demo 来完成以上几点，demo 的主要功能为：</p>\n<ul>\n<li>初始化一个 ImageData，内容随机。</li>\n<li>分别使用 js 和 WebAssembly 进行高斯模糊计算，并计算二者的时间，进行对比。</li>\n</ul>\n<p>这里的 demo 只是辅助进行验证改方案的可行性并且给出一个示例，并不作为一个标准的 benchmark 去对比 js 和 WebAssembly 的性能，同时，也并没有 UI 展示，计算结果输出在控制台中。</p>\n<p>最终笔者运行的结果为，js 比 WebAssembly 慢 30% 左右。</p>\n<h4 id=\"1-wasm-分配内存\"><a href=\"#1-wasm-分配内存\" class=\"headerlink\" title=\"1. wasm 分配内存\"></a>1. wasm 分配内存</h4><p>这部分的通用做法，即我们在 wasm 的 rust 中分配一个数组（Vec），然后把其指针传递给 js：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// rust：</span></span><br><span class=\"line\"><span class=\"meta\">#[wasm_bindgen]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new_buffer</span></span>(key: <span class=\"built_in\">String</span>, len: <span class=\"built_in\">usize</span>) -&gt; *<span class=\"keyword\">const</span> <span class=\"built_in\">u8</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// GlobalBufferStorage 是一个 lazy_static</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> global_buffer_storage = GlobalBufferStorage.lock().unwrap();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> buffer = <span class=\"built_in\">vec!</span>[<span class=\"number\">255</span>; len];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ptr = buffer.as_ptr();</span><br><span class=\"line\">  global_buffer_storage.buffer_map.insert(key, buffer);</span><br><span class=\"line\">  ptr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了后续方便寻找到这段数据，我们可以使用一个 key 将这个 Vec 联系起来，并且在 Rust 中放入全局（可以使用 lazy_static!，因为这种类型的数据没有办法直接定义在全局），之后通过 key 来查找数据。</p>\n<p>在 js 中，我们就可以建立各种 TypedArray 对其进行操作：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ptr = this.wasm!.<span class=\"keyword\">new</span><span class=\"constructor\">_buffer(<span class=\"params\">key</span>, <span class=\"params\">len</span>)</span>;</span><br><span class=\"line\">const u8Arr = <span class=\"keyword\">new</span> <span class=\"constructor\">Uint8ClampedArray(<span class=\"params\">this</span>.<span class=\"params\">wasm</span>!.<span class=\"params\">get_wasm_buffer</span>()</span>, ptr, len);</span><br></pre></td></tr></table></figure>\n\n<p><strong>这个时候，我们在 js 或 rust 任何一侧改了这个数据之后，都可以在另外一侧访问到。</strong></p>\n<p>实际上，在 js 侧的比如 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ImageData/ImageData\">ImageData</a> 等一些对象中，也支持我们传递一个 TypedArray 进行初始化，这让我们在比如 canvas 等应用场景下，使用 wasm 分配的内存更为方便。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const imageData = <span class=\"keyword\">new</span> <span class=\"constructor\">ImageData(<span class=\"params\">u8Arr</span>, <span class=\"params\">width</span>, <span class=\"params\">height</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-js-写入数据\"><a href=\"#2-js-写入数据\" class=\"headerlink\" title=\"2. js 写入数据\"></a>2. js 写入数据</h4><p>如果我们需要在 js 侧写入数据，实际上这个时候我们得到的 TypedArray 已经和直接使用 js new 的 TypedArray 在使用上没有差别，可以正常按照数组的方式进行数据写入。</p>\n<p>不过，这里需要注意的是，js 写入通过 wasm 分配内存建立的 TypedArray，有些场景下在一定程度上速度要慢于直接使用 js new 的 TypedArray（不过在笔者的测试数据中，wasm 分配的方式反而是更快的），所以如果我们是一个高频的数据写入的场景，比如帧数据等，这个时候最好进行一次对比测试。</p>\n<h4 id=\"3-wasm-计算\"><a href=\"#3-wasm-计算\" class=\"headerlink\" title=\"3. wasm 计算\"></a>3. wasm 计算</h4><p>当我们真正需要进行计算的时候，我们可以调用 wasm 的计算函数，并且传入上文中定义的 key，这样 wasm 的 rust 函数可以直接找到这段数据，这里我们的 demo 为一段计算卷积的函数：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[wasm_bindgen]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">convolution</span></span>(key: <span class=\"built_in\">String</span>, width: <span class=\"built_in\">usize</span>, height: <span class=\"built_in\">usize</span>, kernel: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> global_buffer_storage = GlobalBufferStorage.lock().unwrap();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> kernel_length = kernel.iter().sum::&lt;<span class=\"built_in\">i32</span>&gt;() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(buffer) = global_buffer_storage.buffer_map.get_mut(&amp;key) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..width-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">1</span>..height-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> newR: <span class=\"built_in\">i32</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> newG: <span class=\"built_in\">i32</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> newB: <span class=\"built_in\">i32</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">3</span> &#123; <span class=\"comment\">// 取前后左右共9个格子</span></span><br><span class=\"line\">          <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">3</span> &#123;</span><br><span class=\"line\">            newR += buffer[width * (j + y - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + (i + x - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + <span class=\"number\">0</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> * kernel[y * <span class=\"number\">3</span> + x] / kernel_length;</span><br><span class=\"line\">            newG += buffer[width * (j + y - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + (i + x - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + <span class=\"number\">1</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> * kernel[y * <span class=\"number\">3</span> + x] / kernel_length;</span><br><span class=\"line\">            newB += buffer[width * (j + y - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + (i + x - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + <span class=\"number\">2</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> * kernel[y * <span class=\"number\">3</span> + x] / kernel_length;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        buffer[width * j * <span class=\"number\">4</span> + i * <span class=\"number\">4</span> + <span class=\"number\">0</span>] = newR <span class=\"keyword\">as</span> <span class=\"built_in\">u8</span>;</span><br><span class=\"line\">        buffer[width * j * <span class=\"number\">4</span> + i * <span class=\"number\">4</span> + <span class=\"number\">1</span>] = newG <span class=\"keyword\">as</span> <span class=\"built_in\">u8</span>;</span><br><span class=\"line\">        buffer[width * j * <span class=\"number\">4</span> + i * <span class=\"number\">4</span> + <span class=\"number\">2</span>] = newB <span class=\"keyword\">as</span> <span class=\"built_in\">u8</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为这段函数对应操作的内存数据实际上已经在 wasm 和 js 之间共享了，所以也是不需要返回值的，等计算完成后 js 直接去读之前建立的 TypedArray，甚至直接使用通过 TypedArray 创建的 ImageData，进行绘制上屏等后续操作。</p>\n<h4 id=\"4-js-读取数据\"><a href=\"#4-js-读取数据\" class=\"headerlink\" title=\"4. js 读取数据\"></a>4. js 读取数据</h4><p>在 demo 中，我们可以直接通过 <code>CanvasRenderingContext2D.putImageData()</code> 传入之前获取的 imageData，绘制上屏。</p>\n<h3 id=\"其他方案\"><a href=\"#其他方案\" class=\"headerlink\" title=\"其他方案\"></a>其他方案</h3><p>实际上，我们如果目的是加速 js 计算，不仅仅有 WebAssembly 这一个方案可以选择，如果我们的环境中拥有可以访问 Node 的能力或者可以访问原生模块的能力（比如，我们的应用运行在 electron 环境，或者是一些移动客户端），也可以采用比如 addon 的方式来运行我们的计算部分，相比于 wasm，这部分的优缺点在于：</p>\n<p>优点：</p>\n<ul>\n<li>通常可以更好的控制优化，甚至做到汇编级别的优化定制，性能提升空间更高（同样也可能会面临数据拷贝的问题，也需要一定方式减少拷贝）。</li>\n<li>在重 addon 的环境下（例如，其他大量功能也依赖 addon），可以更好的处理函数调用关系、依赖库使用等，一定程度上减少体积和增加开发的便捷性，而 wasm 会被编译成一个独立的二进制文件，处于沙盒环境中，无法直接调用其他的动态库。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>无法做到像 wasm 一样跨平台，并且可以同时运行在网页、桌面环境、移动端等任何 Webview 存在的环境中。</li>\n</ul>\n<p>不过总之，如果使用得当，二者的性能都是可以优于原生的 js，都可以作为优化方案考虑。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>demo: <a href=\"https://github.com/aircloud/rust-wasm-demo\">https://github.com/aircloud/rust-wasm-demo</a>  </p>\n<p>其他资料：<a href=\"https://zhuanlan.zhihu.com/p/104299612\">入门 Rust 开发 WebAssembly</a></p>\n<p>一般来说，使用 WebAssembly 能够在一定程度上提高性能，不过有的时候我们也许会发现，使用 WebAssembly 之后，有的时候我们不仅发现性能没有提升，反而下降了许多甚至数倍，实际上这是因为，使用 WebAssembly 需要非常谨慎，有很多细节都会大幅度影响性能，比如：</p>\n<ul>\n<li>我们编译采用的是 debug 还是 release 方式。</li>\n<li>最后编译的结果是否采用了不同级别的优化，如果使用了 <code>opt-level = &#39;s&#39;</code> 那么通常速度也会下降很多。</li>\n<li>是否在 JS 和 rust 之间存在大量的数据拷贝，因为很多代码是工具链生成的，也许有的时候我们会忽视这一点。</li>\n</ul>\n<p>本文针对以上等一些问题特别是第三点，给出一个 wasm 优化的参考方案，并给出示例代码。</p>\n<h3 id=\"编译优化\"><a href=\"#编译优化\" class=\"headerlink\" title=\"编译优化\"></a>编译优化</h3><p>我们在优化数据拷贝之前，对于编译我们可以做一些前置的简单的工作。</p>\n<ul>\n<li>检查 Cargo.toml 脚本中 <code>[profile.release]</code> 中的 <code>opt-level</code> 选项，确认我们所使用的值：</li>\n</ul>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This flag controls the optimization <span class=\"keyword\">level</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span>: <span class=\"keyword\">no</span> optimizations, <span class=\"keyword\">also</span> turns <span class=\"keyword\">on</span> cfg(debug_assertions) (the <span class=\"keyword\">default</span>).</span><br><span class=\"line\"><span class=\"number\">1</span>: basic optimizations.</span><br><span class=\"line\"><span class=\"number\">2</span>: <span class=\"keyword\">some</span> optimizations.</span><br><span class=\"line\"><span class=\"number\">3</span>: <span class=\"keyword\">all</span> optimizations.</span><br><span class=\"line\">s: optimize <span class=\"keyword\">for</span> binary size.</span><br><span class=\"line\">z: optimize <span class=\"keyword\">for</span> binary size, but <span class=\"keyword\">also</span> turn <span class=\"keyword\">off</span> <span class=\"keyword\">loop</span> vectorization.</span><br><span class=\"line\">Note: The -O flag <span class=\"keyword\">is</span> an <span class=\"keyword\">alias</span> <span class=\"keyword\">for</span> -C opt-<span class=\"keyword\">level</span>=<span class=\"number\">2.</span></span><br><span class=\"line\"></span><br><span class=\"line\">The <span class=\"keyword\">default</span> <span class=\"keyword\">is</span> <span class=\"number\">0.</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们使用了 ‘s’ 或者 ‘z’，那么通常会牺牲一部分性能（对于 demo 而言，使用 ‘z’， wasm 的性能也只有 js 的 20%），因为其主要是对体积进行一定的优化，所以如果优化前的体积我们可以接受的话，通常不需要这样的优化。</p>\n<p>在以上的前提下，我们使用 <code>--release</code> 的方式编译，通常就可以了。</p>\n<h3 id=\"减少拷贝\"><a href=\"#减少拷贝\" class=\"headerlink\" title=\"减少拷贝\"></a>减少拷贝</h3><p>在这之前，我们需要有一个认知：</p>\n<p><strong>通过 rust 工具链编译的 wasm 代码，所有参数传入都是需要拷贝一次的，包括我们传入 ArrayBuffer 等 Buffer 类型的参数。</strong>这是由于 wasm 只能访问自己的线性内存，而这个拷贝，通常是我们在处理大规模计算的一个坎，有的时候虽然 wasm 计算快一点，但是拷贝的消耗还是比较大的，加之 js 有若干 v8 优化的加持，可能和 wasm 也相差不多。</p>\n<p>所以我们要把计算移植到 wasm 中的话，首先要解决的就是大规模数据拷贝的问题。</p>\n<p>这里的一般思路为：</p>\n<ol>\n<li>wasm 分配内存：调用 wasm 的方法，在 wasm 内存中分配空间，返回指针位置</li>\n<li>js 写入数据：js 端在 wasm 的 memory arraybuffer 上，按指针位置和数据量建立 view，把数据写入</li>\n<li>wasm 计算：调用 wasm 方法完成计算， 返回计算好的批量结果的指针位置和大小</li>\n<li>js 读取数据：js 端在 wasm 的 memory arraybuffer上，按指针位置和数据量建立 view，把数据读出</li>\n</ol>\n<p>接下来，我们通过一个 demo 来完成以上几点，demo 的主要功能为：</p>\n<ul>\n<li>初始化一个 ImageData，内容随机。</li>\n<li>分别使用 js 和 WebAssembly 进行高斯模糊计算，并计算二者的时间，进行对比。</li>\n</ul>\n<p>这里的 demo 只是辅助进行验证改方案的可行性并且给出一个示例，并不作为一个标准的 benchmark 去对比 js 和 WebAssembly 的性能，同时，也并没有 UI 展示，计算结果输出在控制台中。</p>\n<p>最终笔者运行的结果为，js 比 WebAssembly 慢 30% 左右。</p>\n<h4 id=\"1-wasm-分配内存\"><a href=\"#1-wasm-分配内存\" class=\"headerlink\" title=\"1. wasm 分配内存\"></a>1. wasm 分配内存</h4><p>这部分的通用做法，即我们在 wasm 的 rust 中分配一个数组（Vec），然后把其指针传递给 js：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// rust：</span></span><br><span class=\"line\"><span class=\"meta\">#[wasm_bindgen]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new_buffer</span></span>(key: <span class=\"built_in\">String</span>, len: <span class=\"built_in\">usize</span>) -&gt; *<span class=\"keyword\">const</span> <span class=\"built_in\">u8</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// GlobalBufferStorage 是一个 lazy_static</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> global_buffer_storage = GlobalBufferStorage.lock().unwrap();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> buffer = <span class=\"built_in\">vec!</span>[<span class=\"number\">255</span>; len];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ptr = buffer.as_ptr();</span><br><span class=\"line\">  global_buffer_storage.buffer_map.insert(key, buffer);</span><br><span class=\"line\">  ptr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了后续方便寻找到这段数据，我们可以使用一个 key 将这个 Vec 联系起来，并且在 Rust 中放入全局（可以使用 lazy_static!，因为这种类型的数据没有办法直接定义在全局），之后通过 key 来查找数据。</p>\n<p>在 js 中，我们就可以建立各种 TypedArray 对其进行操作：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ptr = this.wasm!.<span class=\"keyword\">new</span><span class=\"constructor\">_buffer(<span class=\"params\">key</span>, <span class=\"params\">len</span>)</span>;</span><br><span class=\"line\">const u8Arr = <span class=\"keyword\">new</span> <span class=\"constructor\">Uint8ClampedArray(<span class=\"params\">this</span>.<span class=\"params\">wasm</span>!.<span class=\"params\">get_wasm_buffer</span>()</span>, ptr, len);</span><br></pre></td></tr></table></figure>\n\n<p><strong>这个时候，我们在 js 或 rust 任何一侧改了这个数据之后，都可以在另外一侧访问到。</strong></p>\n<p>实际上，在 js 侧的比如 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ImageData/ImageData\">ImageData</a> 等一些对象中，也支持我们传递一个 TypedArray 进行初始化，这让我们在比如 canvas 等应用场景下，使用 wasm 分配的内存更为方便。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const imageData = <span class=\"keyword\">new</span> <span class=\"constructor\">ImageData(<span class=\"params\">u8Arr</span>, <span class=\"params\">width</span>, <span class=\"params\">height</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-js-写入数据\"><a href=\"#2-js-写入数据\" class=\"headerlink\" title=\"2. js 写入数据\"></a>2. js 写入数据</h4><p>如果我们需要在 js 侧写入数据，实际上这个时候我们得到的 TypedArray 已经和直接使用 js new 的 TypedArray 在使用上没有差别，可以正常按照数组的方式进行数据写入。</p>\n<p>不过，这里需要注意的是，js 写入通过 wasm 分配内存建立的 TypedArray，有些场景下在一定程度上速度要慢于直接使用 js new 的 TypedArray（不过在笔者的测试数据中，wasm 分配的方式反而是更快的），所以如果我们是一个高频的数据写入的场景，比如帧数据等，这个时候最好进行一次对比测试。</p>\n<h4 id=\"3-wasm-计算\"><a href=\"#3-wasm-计算\" class=\"headerlink\" title=\"3. wasm 计算\"></a>3. wasm 计算</h4><p>当我们真正需要进行计算的时候，我们可以调用 wasm 的计算函数，并且传入上文中定义的 key，这样 wasm 的 rust 函数可以直接找到这段数据，这里我们的 demo 为一段计算卷积的函数：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[wasm_bindgen]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">convolution</span></span>(key: <span class=\"built_in\">String</span>, width: <span class=\"built_in\">usize</span>, height: <span class=\"built_in\">usize</span>, kernel: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> global_buffer_storage = GlobalBufferStorage.lock().unwrap();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> kernel_length = kernel.iter().sum::&lt;<span class=\"built_in\">i32</span>&gt;() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(buffer) = global_buffer_storage.buffer_map.get_mut(&amp;key) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..width-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">1</span>..height-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> newR: <span class=\"built_in\">i32</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> newG: <span class=\"built_in\">i32</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> newB: <span class=\"built_in\">i32</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">3</span> &#123; <span class=\"comment\">// 取前后左右共9个格子</span></span><br><span class=\"line\">          <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">3</span> &#123;</span><br><span class=\"line\">            newR += buffer[width * (j + y - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + (i + x - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + <span class=\"number\">0</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> * kernel[y * <span class=\"number\">3</span> + x] / kernel_length;</span><br><span class=\"line\">            newG += buffer[width * (j + y - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + (i + x - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + <span class=\"number\">1</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> * kernel[y * <span class=\"number\">3</span> + x] / kernel_length;</span><br><span class=\"line\">            newB += buffer[width * (j + y - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + (i + x - <span class=\"number\">1</span>) * <span class=\"number\">4</span> + <span class=\"number\">2</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> * kernel[y * <span class=\"number\">3</span> + x] / kernel_length;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        buffer[width * j * <span class=\"number\">4</span> + i * <span class=\"number\">4</span> + <span class=\"number\">0</span>] = newR <span class=\"keyword\">as</span> <span class=\"built_in\">u8</span>;</span><br><span class=\"line\">        buffer[width * j * <span class=\"number\">4</span> + i * <span class=\"number\">4</span> + <span class=\"number\">1</span>] = newG <span class=\"keyword\">as</span> <span class=\"built_in\">u8</span>;</span><br><span class=\"line\">        buffer[width * j * <span class=\"number\">4</span> + i * <span class=\"number\">4</span> + <span class=\"number\">2</span>] = newB <span class=\"keyword\">as</span> <span class=\"built_in\">u8</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为这段函数对应操作的内存数据实际上已经在 wasm 和 js 之间共享了，所以也是不需要返回值的，等计算完成后 js 直接去读之前建立的 TypedArray，甚至直接使用通过 TypedArray 创建的 ImageData，进行绘制上屏等后续操作。</p>\n<h4 id=\"4-js-读取数据\"><a href=\"#4-js-读取数据\" class=\"headerlink\" title=\"4. js 读取数据\"></a>4. js 读取数据</h4><p>在 demo 中，我们可以直接通过 <code>CanvasRenderingContext2D.putImageData()</code> 传入之前获取的 imageData，绘制上屏。</p>\n<h3 id=\"其他方案\"><a href=\"#其他方案\" class=\"headerlink\" title=\"其他方案\"></a>其他方案</h3><p>实际上，我们如果目的是加速 js 计算，不仅仅有 WebAssembly 这一个方案可以选择，如果我们的环境中拥有可以访问 Node 的能力或者可以访问原生模块的能力（比如，我们的应用运行在 electron 环境，或者是一些移动客户端），也可以采用比如 addon 的方式来运行我们的计算部分，相比于 wasm，这部分的优缺点在于：</p>\n<p>优点：</p>\n<ul>\n<li>通常可以更好的控制优化，甚至做到汇编级别的优化定制，性能提升空间更高（同样也可能会面临数据拷贝的问题，也需要一定方式减少拷贝）。</li>\n<li>在重 addon 的环境下（例如，其他大量功能也依赖 addon），可以更好的处理函数调用关系、依赖库使用等，一定程度上减少体积和增加开发的便捷性，而 wasm 会被编译成一个独立的二进制文件，处于沙盒环境中，无法直接调用其他的动态库。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>无法做到像 wasm 一样跨平台，并且可以同时运行在网页、桌面环境、移动端等任何 Webview 存在的环境中。</li>\n</ul>\n<p>不过总之，如果使用得当，二者的性能都是可以优于原生的 js，都可以作为优化方案考虑。</p>\n"},{"title":"入门WebAssembly以及使用其进行图像卷积处理","abbrlink":308376,"date":"2019-02-16T11:15:51.000Z","_content":"\n> WebAssembly 出现有很长时间了，但是由于日常工作并无直接接触，因此一直疏于尝试，最近终于利用一些业余时间简单入门了一下，因此在此总结。\n\n### 简介\n\n首先我们需要知道 WebAssembly 是一个什么东西，其实际是一个字节码编码方式，比较接近机器码（但是又无法直接执行），这样可以方便地做到跨平台同时省去像 JavaScript 等语言的解释时间，所以是有一定优势的，使用起来其实也比较灵活，凡是可以转化成字节码的，都是可以使用 WebAssembly。\n\n以下仅列举部分可以支持 WebAssembly 转化的语言：\n\n* [AssemblyScript](https://github.com/AssemblyScript/assemblyscript): 语法和 TypeScript 一致(事实上，其是 Typescript 的一个子集)，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；\n* c\\c++: 官方推荐的方式，详细使用见[文档](http://webassembly.org.cn/getting-started/developers-guide/);\n* [Rust](https://www.rust-lang.org/): 语法复杂、学习成本高，对前端来说可能会不适应。详细使用见[文档](https://github.com/rust-lang-nursery/rust-wasm);\n* [Kotlin](http://kotlinlang.org/): 语法和 Java、JS 相似，语言学习成本低，详细使用见[文档](https://kotlinlang.org/docs/reference/native-overview.html);\n* [Golang](https://golang.org/): 语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见[文档](https://blog.gopheracademy.com/advent-2017/go-wasm/)。\n\n尝试使用 WebAssembly 官方推荐的方式，我们首先可以在[这里](http://webassembly.org.cn/getting-started/developers-guide/)来下载。\n\n如果用腾讯内网有的文件是下载不下来的，这个时候我们可以给命令行增加一个代理（如果我们用的 Fiddler 或 Charles，开启的时候默认命令行也可以走代理，如果是 Whistle，我们需要手动设置代理），有些文件我们还可以下载好之后使用文件代理。\n\n```\nexport https_proxy=\"http://127.0.0.1:8899\"\nexport http_proxy=\"http://127.0.0.1:8899\"\n// 文件代理：\nhttps://s3.amazonaws.com/mozilla-games/emscripten/packages/node-v8.9.1-darwin-x64.tar.gz file:///Users/niexiaotao/node-v8.9.1-darwin-x64.tar.gz\n```\n\n## 初体验\n\n这里考虑到前端同学的上手难度，我们先使用 AssemblyScript 写一个极小的例子，一个斐波那契函数：\n\n```\nexport function f(x: i32): i32 {\n    if (x === 1 || x === 2) {\n        return 1;\n    }\n    return f(x - 1) + f(x - 2)\n}\n```\n\n通过类似 `asc f.ts -o f.wasm` 这样的命令编译成 f.wasm 之后，我们可以分别在 Node 环境和浏览器环境来执行：\n\nNode：\n\n```\nconst fs = require(\"fs\");\nconst wasm = new WebAssembly.Module(\n    fs.readFileSync(__dirname + \"/f.wasm\"), {}\n);\nconst myModule = new WebAssembly.Instance(wasm).exports;\nconsole.log(myModule.f(12));\n```\n\n浏览器：\n\n```\nfetch('f.wasm') // 网络加载 f.wasm 文件\n        .then(res => res.arrayBuffer()) // 转成 ArrayBuffer\n        .then( buffer =>\n            WebAssembly.compile(buffer)\n        )\n        .then(module => { // 调用模块实例上的 f 函数计算\n            const instance = new WebAssembly.Instance(module);\n            const { f } = instance.exports;\n            console.log('instance:', instance.exports);\n            console.log('f(20):', f(20));\n        });\n```\n\n于是，我们完成了 WebAssembly 的初体验。\n\n当然，这个例子太简单了。\n\n## 使用 WebAssembly 进行图像卷积处理\n\n实际上，WebAssembly 的目的在于解决一些复杂的计算问题，优化 JavaScript 的执行效率。所以我们可以使用 WebAssembly 来处理一些图像或者矩阵的计算问题。\n\n接下来，我们通过 WebAssembly 来处理一些图像的卷积问题，用于图像的风格变换，我们最终的例子可以在[这里](http://assembly.niexiaotao.com/)体验。\n\n每次进行卷积处理，我们的整个流程是这样的：\n\n* 将原图像使用 canvas 绘制到屏幕上。\n* 使用 `getImageData` 获取图像像素内容，并转化成类型数组。\n* 将上述类型数组通过共享内存的方式传递给 WebAssembly 部分。\n* WebAssembly 部分接收到数据，进行计算，并且通过共享内存的方式返回。\n* 将最终结果通过 canvas 画布更新。\n\n上述各个步骤中，绘制的部分集中在 JavaScript 端，而计算的部分集中在 WebAssembly，这两部分相互比较独立，可以分开编写，而双端数据通信是一个比较值得注意的地方，事实上，我们可以通过 ArrayBuffer 来实现双端通信，简单的说，JavaScript 端和 WebAssembly 可以共享一部分内存，并且都拥有读写能力，当一端写入新数据之后，另一段也可以读到，这样我们就可以进行通信了。\n\n关于数据通信的问题，这里还有一个比较直白的[科普文章](https://segmentfault.com/a/1190000010434237)，可以参考。\n\n在这里没有必要对整个项目代码进行展示，因此可以参考（[代码地址](https://github.com/aircloud/assemConvolution)），我们这里仅仅对部分关键代码进行说明。\n\n### 共享内存\n\n首先，我们需要声明一块共享内存，这其实可以使用 WebAssembly 的 API 来完成：\n\n```\nlet memory = new WebAssembly.Memory({ initial: ((memSize + 0xffff) & ~0xffff) >>> 16 });\n```\n\n这里经过这样的比较复杂的计算是因为 initial 传入的是以 page 为单位，详细可以参考[这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory)，实际上 memSize 即我们共享内存的字节数。\n\n然后这里涉及到 memSize 的计算，我们主要需要存储三块数据：卷积前的数据、卷积后的数据（由于卷积算法的特殊性以及为了避免更多麻烦，这里我们不进行数据共用），还有卷积核作为参数需要传递。\n\n这里我们共享内存所传递的数据按照如下的规则进行设计：\n\n![](http://niexiaotao.cn/img/ker1.jpg)\n\n传递给 WebAssembly 端的方式并不复杂，直接在 `WebAssembly.instantiate` 中声明即可。 \n\n```\nfetch(wasmPath)\n     .then(response => response.arrayBuffer())\n     .then(buffer => WebAssembly.instantiate(buffer, {\n         env: {\n             memory,\n             abort: function() {}\n         },\n         Math\n     })).then(module => {})\n                \n```\n\n然后我们在 AssemblyScript 中就可以进行读写了：\n\n```\n//写：\nstore<u32>(position, v) // position 为位置\n\n//读：\nload<u32>(position) // position 为位置\n```\n\n而在 JavaScript 端，我们也可以通过 `memory.buffer` 拿到数据，并且转化成类型数组：\n\n```\nlet mem = new Uint32Array(memory.buffer)\n//通过 mem.set(data) 可以在 JavaScript 端进行写入操作\n```\n\n这样，我们在 JavaScript 端和 AssemblyScript 端的读写都明晰了。\n\n这里需要注意的是，**JS端采用的是大端数据格式，而 AssemblyScript 中采用的是小端，因此其颜色数据格式为 AGBR**\n\n### 卷积计算\n\n我们所采用的卷积计算本身算法比较简单，并且不是本次的重点，但是这里需要注意的是：\n\n* 我们无法直接在 AssemblyScript 中声明数组并使用，因此除了 Kernel 通过共享内存的方式传递过来以外，我们应当尽量避免声明数组使用（虽然也有使用非共享内存数组的相关操作，但是使用起来比较繁琐）\n* 卷积应当对 R、G、B 三层单独进行，我这里 A 层不参与卷积。\n\n以上都在代码中有所体现，参考相关代码便可明了。\n\n卷积完成后，我们通过共享内存的方法写入类型数组，然后在 JavaScript 端合成数据，调用 `putImageData` 上屏即可。\n\n### 其他\n\n当然，本次图像卷积程序仅仅是对 Webassembly 和 AssemblyScript 的初步尝试，笔者也在学习阶段，如果上述说法有问题或者你想和我交流，也欢迎留言或者提相关 issue。\n","source":"_posts/入门WebAssembly以及使用其进行图像卷积处理.md","raw":"---\ntitle: 入门WebAssembly以及使用其进行图像卷积处理\ntags:\n  - WebAssembly\nabbrlink: 308376\ndate: 2019-02-16 19:15:51\n---\n\n> WebAssembly 出现有很长时间了，但是由于日常工作并无直接接触，因此一直疏于尝试，最近终于利用一些业余时间简单入门了一下，因此在此总结。\n\n### 简介\n\n首先我们需要知道 WebAssembly 是一个什么东西，其实际是一个字节码编码方式，比较接近机器码（但是又无法直接执行），这样可以方便地做到跨平台同时省去像 JavaScript 等语言的解释时间，所以是有一定优势的，使用起来其实也比较灵活，凡是可以转化成字节码的，都是可以使用 WebAssembly。\n\n以下仅列举部分可以支持 WebAssembly 转化的语言：\n\n* [AssemblyScript](https://github.com/AssemblyScript/assemblyscript): 语法和 TypeScript 一致(事实上，其是 Typescript 的一个子集)，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；\n* c\\c++: 官方推荐的方式，详细使用见[文档](http://webassembly.org.cn/getting-started/developers-guide/);\n* [Rust](https://www.rust-lang.org/): 语法复杂、学习成本高，对前端来说可能会不适应。详细使用见[文档](https://github.com/rust-lang-nursery/rust-wasm);\n* [Kotlin](http://kotlinlang.org/): 语法和 Java、JS 相似，语言学习成本低，详细使用见[文档](https://kotlinlang.org/docs/reference/native-overview.html);\n* [Golang](https://golang.org/): 语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见[文档](https://blog.gopheracademy.com/advent-2017/go-wasm/)。\n\n尝试使用 WebAssembly 官方推荐的方式，我们首先可以在[这里](http://webassembly.org.cn/getting-started/developers-guide/)来下载。\n\n如果用腾讯内网有的文件是下载不下来的，这个时候我们可以给命令行增加一个代理（如果我们用的 Fiddler 或 Charles，开启的时候默认命令行也可以走代理，如果是 Whistle，我们需要手动设置代理），有些文件我们还可以下载好之后使用文件代理。\n\n```\nexport https_proxy=\"http://127.0.0.1:8899\"\nexport http_proxy=\"http://127.0.0.1:8899\"\n// 文件代理：\nhttps://s3.amazonaws.com/mozilla-games/emscripten/packages/node-v8.9.1-darwin-x64.tar.gz file:///Users/niexiaotao/node-v8.9.1-darwin-x64.tar.gz\n```\n\n## 初体验\n\n这里考虑到前端同学的上手难度，我们先使用 AssemblyScript 写一个极小的例子，一个斐波那契函数：\n\n```\nexport function f(x: i32): i32 {\n    if (x === 1 || x === 2) {\n        return 1;\n    }\n    return f(x - 1) + f(x - 2)\n}\n```\n\n通过类似 `asc f.ts -o f.wasm` 这样的命令编译成 f.wasm 之后，我们可以分别在 Node 环境和浏览器环境来执行：\n\nNode：\n\n```\nconst fs = require(\"fs\");\nconst wasm = new WebAssembly.Module(\n    fs.readFileSync(__dirname + \"/f.wasm\"), {}\n);\nconst myModule = new WebAssembly.Instance(wasm).exports;\nconsole.log(myModule.f(12));\n```\n\n浏览器：\n\n```\nfetch('f.wasm') // 网络加载 f.wasm 文件\n        .then(res => res.arrayBuffer()) // 转成 ArrayBuffer\n        .then( buffer =>\n            WebAssembly.compile(buffer)\n        )\n        .then(module => { // 调用模块实例上的 f 函数计算\n            const instance = new WebAssembly.Instance(module);\n            const { f } = instance.exports;\n            console.log('instance:', instance.exports);\n            console.log('f(20):', f(20));\n        });\n```\n\n于是，我们完成了 WebAssembly 的初体验。\n\n当然，这个例子太简单了。\n\n## 使用 WebAssembly 进行图像卷积处理\n\n实际上，WebAssembly 的目的在于解决一些复杂的计算问题，优化 JavaScript 的执行效率。所以我们可以使用 WebAssembly 来处理一些图像或者矩阵的计算问题。\n\n接下来，我们通过 WebAssembly 来处理一些图像的卷积问题，用于图像的风格变换，我们最终的例子可以在[这里](http://assembly.niexiaotao.com/)体验。\n\n每次进行卷积处理，我们的整个流程是这样的：\n\n* 将原图像使用 canvas 绘制到屏幕上。\n* 使用 `getImageData` 获取图像像素内容，并转化成类型数组。\n* 将上述类型数组通过共享内存的方式传递给 WebAssembly 部分。\n* WebAssembly 部分接收到数据，进行计算，并且通过共享内存的方式返回。\n* 将最终结果通过 canvas 画布更新。\n\n上述各个步骤中，绘制的部分集中在 JavaScript 端，而计算的部分集中在 WebAssembly，这两部分相互比较独立，可以分开编写，而双端数据通信是一个比较值得注意的地方，事实上，我们可以通过 ArrayBuffer 来实现双端通信，简单的说，JavaScript 端和 WebAssembly 可以共享一部分内存，并且都拥有读写能力，当一端写入新数据之后，另一段也可以读到，这样我们就可以进行通信了。\n\n关于数据通信的问题，这里还有一个比较直白的[科普文章](https://segmentfault.com/a/1190000010434237)，可以参考。\n\n在这里没有必要对整个项目代码进行展示，因此可以参考（[代码地址](https://github.com/aircloud/assemConvolution)），我们这里仅仅对部分关键代码进行说明。\n\n### 共享内存\n\n首先，我们需要声明一块共享内存，这其实可以使用 WebAssembly 的 API 来完成：\n\n```\nlet memory = new WebAssembly.Memory({ initial: ((memSize + 0xffff) & ~0xffff) >>> 16 });\n```\n\n这里经过这样的比较复杂的计算是因为 initial 传入的是以 page 为单位，详细可以参考[这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory)，实际上 memSize 即我们共享内存的字节数。\n\n然后这里涉及到 memSize 的计算，我们主要需要存储三块数据：卷积前的数据、卷积后的数据（由于卷积算法的特殊性以及为了避免更多麻烦，这里我们不进行数据共用），还有卷积核作为参数需要传递。\n\n这里我们共享内存所传递的数据按照如下的规则进行设计：\n\n![](http://niexiaotao.cn/img/ker1.jpg)\n\n传递给 WebAssembly 端的方式并不复杂，直接在 `WebAssembly.instantiate` 中声明即可。 \n\n```\nfetch(wasmPath)\n     .then(response => response.arrayBuffer())\n     .then(buffer => WebAssembly.instantiate(buffer, {\n         env: {\n             memory,\n             abort: function() {}\n         },\n         Math\n     })).then(module => {})\n                \n```\n\n然后我们在 AssemblyScript 中就可以进行读写了：\n\n```\n//写：\nstore<u32>(position, v) // position 为位置\n\n//读：\nload<u32>(position) // position 为位置\n```\n\n而在 JavaScript 端，我们也可以通过 `memory.buffer` 拿到数据，并且转化成类型数组：\n\n```\nlet mem = new Uint32Array(memory.buffer)\n//通过 mem.set(data) 可以在 JavaScript 端进行写入操作\n```\n\n这样，我们在 JavaScript 端和 AssemblyScript 端的读写都明晰了。\n\n这里需要注意的是，**JS端采用的是大端数据格式，而 AssemblyScript 中采用的是小端，因此其颜色数据格式为 AGBR**\n\n### 卷积计算\n\n我们所采用的卷积计算本身算法比较简单，并且不是本次的重点，但是这里需要注意的是：\n\n* 我们无法直接在 AssemblyScript 中声明数组并使用，因此除了 Kernel 通过共享内存的方式传递过来以外，我们应当尽量避免声明数组使用（虽然也有使用非共享内存数组的相关操作，但是使用起来比较繁琐）\n* 卷积应当对 R、G、B 三层单独进行，我这里 A 层不参与卷积。\n\n以上都在代码中有所体现，参考相关代码便可明了。\n\n卷积完成后，我们通过共享内存的方法写入类型数组，然后在 JavaScript 端合成数据，调用 `putImageData` 上屏即可。\n\n### 其他\n\n当然，本次图像卷积程序仅仅是对 Webassembly 和 AssemblyScript 的初步尝试，笔者也在学习阶段，如果上述说法有问题或者你想和我交流，也欢迎留言或者提相关 issue。\n","slug":"入门WebAssembly以及使用其进行图像卷积处理","published":1,"updated":"2021-12-23T05:50:07.547Z","_id":"ckxijpqsz000zd3mrfl89hrho","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>WebAssembly 出现有很长时间了，但是由于日常工作并无直接接触，因此一直疏于尝试，最近终于利用一些业余时间简单入门了一下，因此在此总结。</p>\n</blockquote>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>首先我们需要知道 WebAssembly 是一个什么东西，其实际是一个字节码编码方式，比较接近机器码（但是又无法直接执行），这样可以方便地做到跨平台同时省去像 JavaScript 等语言的解释时间，所以是有一定优势的，使用起来其实也比较灵活，凡是可以转化成字节码的，都是可以使用 WebAssembly。</p>\n<p>以下仅列举部分可以支持 WebAssembly 转化的语言：</p>\n<ul>\n<li><a href=\"https://github.com/AssemblyScript/assemblyscript\">AssemblyScript</a>: 语法和 TypeScript 一致(事实上，其是 Typescript 的一个子集)，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；</li>\n<li>c\\c++: 官方推荐的方式，详细使用见<a href=\"http://webassembly.org.cn/getting-started/developers-guide/\">文档</a>;</li>\n<li><a href=\"https://www.rust-lang.org/\">Rust</a>: 语法复杂、学习成本高，对前端来说可能会不适应。详细使用见<a href=\"https://github.com/rust-lang-nursery/rust-wasm\">文档</a>;</li>\n<li><a href=\"http://kotlinlang.org/\">Kotlin</a>: 语法和 Java、JS 相似，语言学习成本低，详细使用见<a href=\"https://kotlinlang.org/docs/reference/native-overview.html\">文档</a>;</li>\n<li><a href=\"https://golang.org/\">Golang</a>: 语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见<a href=\"https://blog.gopheracademy.com/advent-2017/go-wasm/\">文档</a>。</li>\n</ul>\n<p>尝试使用 WebAssembly 官方推荐的方式，我们首先可以在<a href=\"http://webassembly.org.cn/getting-started/developers-guide/\">这里</a>来下载。</p>\n<p>如果用腾讯内网有的文件是下载不下来的，这个时候我们可以给命令行增加一个代理（如果我们用的 Fiddler 或 Charles，开启的时候默认命令行也可以走代理，如果是 Whistle，我们需要手动设置代理），有些文件我们还可以下载好之后使用文件代理。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export https_proxy=<span class=\"string\">&quot;http://127.0.0.1:8899&quot;</span></span><br><span class=\"line\">export http_proxy=<span class=\"string\">&quot;http://127.0.0.1:8899&quot;</span></span><br><span class=\"line\"><span class=\"regexp\">//</span> 文件代理：</span><br><span class=\"line\">https:<span class=\"regexp\">//</span>s3.amazonaws.com<span class=\"regexp\">/mozilla-games/</span>emscripten<span class=\"regexp\">/packages/</span>node-v8.<span class=\"number\">9.1</span>-darwin-x64.tar.gz file:<span class=\"regexp\">//</span><span class=\"regexp\">/Users/</span>niexiaotao/node-v8.<span class=\"number\">9.1</span>-darwin-x64.tar.gz</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初体验\"><a href=\"#初体验\" class=\"headerlink\" title=\"初体验\"></a>初体验</h2><p>这里考虑到前端同学的上手难度，我们先使用 AssemblyScript 写一个极小的例子，一个斐波那契函数：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function f(<span class=\"keyword\">x</span>: <span class=\"type\">i32</span>): <span class=\"type\">i32</span> &#123;</span><br><span class=\"line\">    if (<span class=\"keyword\">x</span> <span class=\"operator\">=</span><span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">1</span> || <span class=\"keyword\">x</span> <span class=\"operator\">=</span><span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        return <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return f(<span class=\"keyword\">x</span> - <span class=\"number\">1</span>) + f(<span class=\"keyword\">x</span> - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过类似 <code>asc f.ts -o f.wasm</code> 这样的命令编译成 f.wasm 之后，我们可以分别在 Node 环境和浏览器环境来执行：</p>\n<p>Node：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasm = <span class=\"keyword\">new</span> WebAssembly.Module(</span><br><span class=\"line\">    fs.readFileSync(__dirname + <span class=\"string\">&quot;/f.wasm&quot;</span>), &#123;&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">const</span> myModule = <span class=\"keyword\">new</span> WebAssembly.Instance(wasm).<span class=\"built_in\">exports</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myModule.f(<span class=\"number\">12</span>));</span><br></pre></td></tr></table></figure>\n\n<p>浏览器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">&#x27;f.wasm&#x27;</span>) <span class=\"comment\">// 网络加载 f.wasm 文件</span></span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.arrayBuffer()) <span class=\"comment\">// 转成 ArrayBuffer</span></span><br><span class=\"line\">        .then( <span class=\"function\"><span class=\"params\">buffer</span> =&gt;</span></span><br><span class=\"line\">            WebAssembly.compile(buffer)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123; <span class=\"comment\">// 调用模块实例上的 f 函数计算</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> instance = <span class=\"keyword\">new</span> WebAssembly.Instance(<span class=\"built_in\">module</span>);</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; f &#125; = instance.exports;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;instance:&#x27;</span>, instance.exports);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;f(20):&#x27;</span>, f(<span class=\"number\">20</span>));</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>于是，我们完成了 WebAssembly 的初体验。</p>\n<p>当然，这个例子太简单了。</p>\n<h2 id=\"使用-WebAssembly-进行图像卷积处理\"><a href=\"#使用-WebAssembly-进行图像卷积处理\" class=\"headerlink\" title=\"使用 WebAssembly 进行图像卷积处理\"></a>使用 WebAssembly 进行图像卷积处理</h2><p>实际上，WebAssembly 的目的在于解决一些复杂的计算问题，优化 JavaScript 的执行效率。所以我们可以使用 WebAssembly 来处理一些图像或者矩阵的计算问题。</p>\n<p>接下来，我们通过 WebAssembly 来处理一些图像的卷积问题，用于图像的风格变换，我们最终的例子可以在<a href=\"http://assembly.niexiaotao.com/\">这里</a>体验。</p>\n<p>每次进行卷积处理，我们的整个流程是这样的：</p>\n<ul>\n<li>将原图像使用 canvas 绘制到屏幕上。</li>\n<li>使用 <code>getImageData</code> 获取图像像素内容，并转化成类型数组。</li>\n<li>将上述类型数组通过共享内存的方式传递给 WebAssembly 部分。</li>\n<li>WebAssembly 部分接收到数据，进行计算，并且通过共享内存的方式返回。</li>\n<li>将最终结果通过 canvas 画布更新。</li>\n</ul>\n<p>上述各个步骤中，绘制的部分集中在 JavaScript 端，而计算的部分集中在 WebAssembly，这两部分相互比较独立，可以分开编写，而双端数据通信是一个比较值得注意的地方，事实上，我们可以通过 ArrayBuffer 来实现双端通信，简单的说，JavaScript 端和 WebAssembly 可以共享一部分内存，并且都拥有读写能力，当一端写入新数据之后，另一段也可以读到，这样我们就可以进行通信了。</p>\n<p>关于数据通信的问题，这里还有一个比较直白的<a href=\"https://segmentfault.com/a/1190000010434237\">科普文章</a>，可以参考。</p>\n<p>在这里没有必要对整个项目代码进行展示，因此可以参考（<a href=\"https://github.com/aircloud/assemConvolution\">代码地址</a>），我们这里仅仅对部分关键代码进行说明。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>首先，我们需要声明一块共享内存，这其实可以使用 WebAssembly 的 API 来完成：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> memory = <span class=\"keyword\">new</span> WebAssembly.<span class=\"constructor\">Memory(&#123; <span class=\"params\">initial</span>: ((<span class=\"params\">memSize</span> + 0xffff)</span> &amp; ~<span class=\"number\">0xffff</span>) &gt;&gt;&gt; <span class=\"number\">16</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里经过这样的比较复杂的计算是因为 initial 传入的是以 page 为单位，详细可以参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory\">这里</a>，实际上 memSize 即我们共享内存的字节数。</p>\n<p>然后这里涉及到 memSize 的计算，我们主要需要存储三块数据：卷积前的数据、卷积后的数据（由于卷积算法的特殊性以及为了避免更多麻烦，这里我们不进行数据共用），还有卷积核作为参数需要传递。</p>\n<p>这里我们共享内存所传递的数据按照如下的规则进行设计：</p>\n<p><img src=\"http://niexiaotao.cn/img/ker1.jpg\"></p>\n<p>传递给 WebAssembly 端的方式并不复杂，直接在 <code>WebAssembly.instantiate</code> 中声明即可。 </p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(wasmPath)</span><br><span class=\"line\">     .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.arrayBuffer())</span><br><span class=\"line\">     .then(<span class=\"function\"><span class=\"params\">buffer</span> =&gt;</span> WebAssembly.instantiate(buffer, &#123;</span><br><span class=\"line\">         <span class=\"attr\">env</span>: &#123;</span><br><span class=\"line\">             memory,</span><br><span class=\"line\">             <span class=\"attr\">abort</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         Math</span><br><span class=\"line\">     &#125;)).then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123;&#125;)</span><br><span class=\"line\">                </span><br></pre></td></tr></table></figure>\n\n<p>然后我们在 AssemblyScript 中就可以进行读写了：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span>写：</span><br><span class=\"line\">store&lt;u32&gt;(position, v) <span class=\"regexp\">//</span> position 为位置</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>读：</span><br><span class=\"line\">load&lt;u32&gt;(position) <span class=\"regexp\">//</span> position 为位置</span><br></pre></td></tr></table></figure>\n\n<p>而在 JavaScript 端，我们也可以通过 <code>memory.buffer</code> 拿到数据，并且转化成类型数组：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mem = <span class=\"keyword\">new</span> <span class=\"constructor\">Uint32Array(<span class=\"params\">memory</span>.<span class=\"params\">buffer</span>)</span></span><br><span class=\"line\"><span class=\"comment\">//通过 mem.set(data) 可以在 JavaScript 端进行写入操作</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，我们在 JavaScript 端和 AssemblyScript 端的读写都明晰了。</p>\n<p>这里需要注意的是，<strong>JS端采用的是大端数据格式，而 AssemblyScript 中采用的是小端，因此其颜色数据格式为 AGBR</strong></p>\n<h3 id=\"卷积计算\"><a href=\"#卷积计算\" class=\"headerlink\" title=\"卷积计算\"></a>卷积计算</h3><p>我们所采用的卷积计算本身算法比较简单，并且不是本次的重点，但是这里需要注意的是：</p>\n<ul>\n<li>我们无法直接在 AssemblyScript 中声明数组并使用，因此除了 Kernel 通过共享内存的方式传递过来以外，我们应当尽量避免声明数组使用（虽然也有使用非共享内存数组的相关操作，但是使用起来比较繁琐）</li>\n<li>卷积应当对 R、G、B 三层单独进行，我这里 A 层不参与卷积。</li>\n</ul>\n<p>以上都在代码中有所体现，参考相关代码便可明了。</p>\n<p>卷积完成后，我们通过共享内存的方法写入类型数组，然后在 JavaScript 端合成数据，调用 <code>putImageData</code> 上屏即可。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>当然，本次图像卷积程序仅仅是对 Webassembly 和 AssemblyScript 的初步尝试，笔者也在学习阶段，如果上述说法有问题或者你想和我交流，也欢迎留言或者提相关 issue。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>WebAssembly 出现有很长时间了，但是由于日常工作并无直接接触，因此一直疏于尝试，最近终于利用一些业余时间简单入门了一下，因此在此总结。</p>\n</blockquote>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>首先我们需要知道 WebAssembly 是一个什么东西，其实际是一个字节码编码方式，比较接近机器码（但是又无法直接执行），这样可以方便地做到跨平台同时省去像 JavaScript 等语言的解释时间，所以是有一定优势的，使用起来其实也比较灵活，凡是可以转化成字节码的，都是可以使用 WebAssembly。</p>\n<p>以下仅列举部分可以支持 WebAssembly 转化的语言：</p>\n<ul>\n<li><a href=\"https://github.com/AssemblyScript/assemblyscript\">AssemblyScript</a>: 语法和 TypeScript 一致(事实上，其是 Typescript 的一个子集)，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；</li>\n<li>c\\c++: 官方推荐的方式，详细使用见<a href=\"http://webassembly.org.cn/getting-started/developers-guide/\">文档</a>;</li>\n<li><a href=\"https://www.rust-lang.org/\">Rust</a>: 语法复杂、学习成本高，对前端来说可能会不适应。详细使用见<a href=\"https://github.com/rust-lang-nursery/rust-wasm\">文档</a>;</li>\n<li><a href=\"http://kotlinlang.org/\">Kotlin</a>: 语法和 Java、JS 相似，语言学习成本低，详细使用见<a href=\"https://kotlinlang.org/docs/reference/native-overview.html\">文档</a>;</li>\n<li><a href=\"https://golang.org/\">Golang</a>: 语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见<a href=\"https://blog.gopheracademy.com/advent-2017/go-wasm/\">文档</a>。</li>\n</ul>\n<p>尝试使用 WebAssembly 官方推荐的方式，我们首先可以在<a href=\"http://webassembly.org.cn/getting-started/developers-guide/\">这里</a>来下载。</p>\n<p>如果用腾讯内网有的文件是下载不下来的，这个时候我们可以给命令行增加一个代理（如果我们用的 Fiddler 或 Charles，开启的时候默认命令行也可以走代理，如果是 Whistle，我们需要手动设置代理），有些文件我们还可以下载好之后使用文件代理。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export https_proxy=<span class=\"string\">&quot;http://127.0.0.1:8899&quot;</span></span><br><span class=\"line\">export http_proxy=<span class=\"string\">&quot;http://127.0.0.1:8899&quot;</span></span><br><span class=\"line\"><span class=\"regexp\">//</span> 文件代理：</span><br><span class=\"line\">https:<span class=\"regexp\">//</span>s3.amazonaws.com<span class=\"regexp\">/mozilla-games/</span>emscripten<span class=\"regexp\">/packages/</span>node-v8.<span class=\"number\">9.1</span>-darwin-x64.tar.gz file:<span class=\"regexp\">//</span><span class=\"regexp\">/Users/</span>niexiaotao/node-v8.<span class=\"number\">9.1</span>-darwin-x64.tar.gz</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初体验\"><a href=\"#初体验\" class=\"headerlink\" title=\"初体验\"></a>初体验</h2><p>这里考虑到前端同学的上手难度，我们先使用 AssemblyScript 写一个极小的例子，一个斐波那契函数：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function f(<span class=\"keyword\">x</span>: <span class=\"type\">i32</span>): <span class=\"type\">i32</span> &#123;</span><br><span class=\"line\">    if (<span class=\"keyword\">x</span> <span class=\"operator\">=</span><span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">1</span> || <span class=\"keyword\">x</span> <span class=\"operator\">=</span><span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        return <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return f(<span class=\"keyword\">x</span> - <span class=\"number\">1</span>) + f(<span class=\"keyword\">x</span> - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过类似 <code>asc f.ts -o f.wasm</code> 这样的命令编译成 f.wasm 之后，我们可以分别在 Node 环境和浏览器环境来执行：</p>\n<p>Node：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasm = <span class=\"keyword\">new</span> WebAssembly.Module(</span><br><span class=\"line\">    fs.readFileSync(__dirname + <span class=\"string\">&quot;/f.wasm&quot;</span>), &#123;&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">const</span> myModule = <span class=\"keyword\">new</span> WebAssembly.Instance(wasm).<span class=\"built_in\">exports</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myModule.f(<span class=\"number\">12</span>));</span><br></pre></td></tr></table></figure>\n\n<p>浏览器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">&#x27;f.wasm&#x27;</span>) <span class=\"comment\">// 网络加载 f.wasm 文件</span></span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.arrayBuffer()) <span class=\"comment\">// 转成 ArrayBuffer</span></span><br><span class=\"line\">        .then( <span class=\"function\"><span class=\"params\">buffer</span> =&gt;</span></span><br><span class=\"line\">            WebAssembly.compile(buffer)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123; <span class=\"comment\">// 调用模块实例上的 f 函数计算</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> instance = <span class=\"keyword\">new</span> WebAssembly.Instance(<span class=\"built_in\">module</span>);</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; f &#125; = instance.exports;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;instance:&#x27;</span>, instance.exports);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;f(20):&#x27;</span>, f(<span class=\"number\">20</span>));</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>于是，我们完成了 WebAssembly 的初体验。</p>\n<p>当然，这个例子太简单了。</p>\n<h2 id=\"使用-WebAssembly-进行图像卷积处理\"><a href=\"#使用-WebAssembly-进行图像卷积处理\" class=\"headerlink\" title=\"使用 WebAssembly 进行图像卷积处理\"></a>使用 WebAssembly 进行图像卷积处理</h2><p>实际上，WebAssembly 的目的在于解决一些复杂的计算问题，优化 JavaScript 的执行效率。所以我们可以使用 WebAssembly 来处理一些图像或者矩阵的计算问题。</p>\n<p>接下来，我们通过 WebAssembly 来处理一些图像的卷积问题，用于图像的风格变换，我们最终的例子可以在<a href=\"http://assembly.niexiaotao.com/\">这里</a>体验。</p>\n<p>每次进行卷积处理，我们的整个流程是这样的：</p>\n<ul>\n<li>将原图像使用 canvas 绘制到屏幕上。</li>\n<li>使用 <code>getImageData</code> 获取图像像素内容，并转化成类型数组。</li>\n<li>将上述类型数组通过共享内存的方式传递给 WebAssembly 部分。</li>\n<li>WebAssembly 部分接收到数据，进行计算，并且通过共享内存的方式返回。</li>\n<li>将最终结果通过 canvas 画布更新。</li>\n</ul>\n<p>上述各个步骤中，绘制的部分集中在 JavaScript 端，而计算的部分集中在 WebAssembly，这两部分相互比较独立，可以分开编写，而双端数据通信是一个比较值得注意的地方，事实上，我们可以通过 ArrayBuffer 来实现双端通信，简单的说，JavaScript 端和 WebAssembly 可以共享一部分内存，并且都拥有读写能力，当一端写入新数据之后，另一段也可以读到，这样我们就可以进行通信了。</p>\n<p>关于数据通信的问题，这里还有一个比较直白的<a href=\"https://segmentfault.com/a/1190000010434237\">科普文章</a>，可以参考。</p>\n<p>在这里没有必要对整个项目代码进行展示，因此可以参考（<a href=\"https://github.com/aircloud/assemConvolution\">代码地址</a>），我们这里仅仅对部分关键代码进行说明。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>首先，我们需要声明一块共享内存，这其实可以使用 WebAssembly 的 API 来完成：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> memory = <span class=\"keyword\">new</span> WebAssembly.<span class=\"constructor\">Memory(&#123; <span class=\"params\">initial</span>: ((<span class=\"params\">memSize</span> + 0xffff)</span> &amp; ~<span class=\"number\">0xffff</span>) &gt;&gt;&gt; <span class=\"number\">16</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里经过这样的比较复杂的计算是因为 initial 传入的是以 page 为单位，详细可以参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory\">这里</a>，实际上 memSize 即我们共享内存的字节数。</p>\n<p>然后这里涉及到 memSize 的计算，我们主要需要存储三块数据：卷积前的数据、卷积后的数据（由于卷积算法的特殊性以及为了避免更多麻烦，这里我们不进行数据共用），还有卷积核作为参数需要传递。</p>\n<p>这里我们共享内存所传递的数据按照如下的规则进行设计：</p>\n<p><img src=\"http://niexiaotao.cn/img/ker1.jpg\"></p>\n<p>传递给 WebAssembly 端的方式并不复杂，直接在 <code>WebAssembly.instantiate</code> 中声明即可。 </p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(wasmPath)</span><br><span class=\"line\">     .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.arrayBuffer())</span><br><span class=\"line\">     .then(<span class=\"function\"><span class=\"params\">buffer</span> =&gt;</span> WebAssembly.instantiate(buffer, &#123;</span><br><span class=\"line\">         <span class=\"attr\">env</span>: &#123;</span><br><span class=\"line\">             memory,</span><br><span class=\"line\">             <span class=\"attr\">abort</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         Math</span><br><span class=\"line\">     &#125;)).then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123;&#125;)</span><br><span class=\"line\">                </span><br></pre></td></tr></table></figure>\n\n<p>然后我们在 AssemblyScript 中就可以进行读写了：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span>写：</span><br><span class=\"line\">store&lt;u32&gt;(position, v) <span class=\"regexp\">//</span> position 为位置</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>读：</span><br><span class=\"line\">load&lt;u32&gt;(position) <span class=\"regexp\">//</span> position 为位置</span><br></pre></td></tr></table></figure>\n\n<p>而在 JavaScript 端，我们也可以通过 <code>memory.buffer</code> 拿到数据，并且转化成类型数组：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mem = <span class=\"keyword\">new</span> <span class=\"constructor\">Uint32Array(<span class=\"params\">memory</span>.<span class=\"params\">buffer</span>)</span></span><br><span class=\"line\"><span class=\"comment\">//通过 mem.set(data) 可以在 JavaScript 端进行写入操作</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，我们在 JavaScript 端和 AssemblyScript 端的读写都明晰了。</p>\n<p>这里需要注意的是，<strong>JS端采用的是大端数据格式，而 AssemblyScript 中采用的是小端，因此其颜色数据格式为 AGBR</strong></p>\n<h3 id=\"卷积计算\"><a href=\"#卷积计算\" class=\"headerlink\" title=\"卷积计算\"></a>卷积计算</h3><p>我们所采用的卷积计算本身算法比较简单，并且不是本次的重点，但是这里需要注意的是：</p>\n<ul>\n<li>我们无法直接在 AssemblyScript 中声明数组并使用，因此除了 Kernel 通过共享内存的方式传递过来以外，我们应当尽量避免声明数组使用（虽然也有使用非共享内存数组的相关操作，但是使用起来比较繁琐）</li>\n<li>卷积应当对 R、G、B 三层单独进行，我这里 A 层不参与卷积。</li>\n</ul>\n<p>以上都在代码中有所体现，参考相关代码便可明了。</p>\n<p>卷积完成后，我们通过共享内存的方法写入类型数组，然后在 JavaScript 端合成数据，调用 <code>putImageData</code> 上屏即可。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>当然，本次图像卷积程序仅仅是对 Webassembly 和 AssemblyScript 的初步尝试，笔者也在学习阶段，如果上述说法有问题或者你想和我交流，也欢迎留言或者提相关 issue。</p>\n"},{"title":"十条编写优化的 JavaScript 代码的建议","abbrlink":3677661280,"date":"2018-05-29T08:59:40.000Z","_content":"\n本文总结了十条编写优秀的 JavaScript 代码的习惯，主要针对 V8 引擎：\n\n1.始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。V8 在对 js 代码解析的时候会有构建隐藏类的过程，以相同的顺序实例化（属性赋值）的对象会共享相同的隐藏类。下面给出一个不好的实践：\n\n```javascript\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\nvar p1 = new Point(1, 2);\np1.a = 5;\np1.b = 6;\nvar p2 = new Point(3, 4);\np2.b = 7;\np2.a = 8;\n// 由于 a 和 b 的赋值顺序不同，p1 和 p2 无法共享隐藏类\n```\n\n2.避免分配动态属性。在实例化之后向对象添加属性将强制隐藏类更改，并减慢为先前隐藏类优化的所有方法。相反，在其构造函数中分配所有对象的属性。  \n\n3.重复执行相同方法的代码将比仅执行一次（由于内联缓存）执行许多不同方法的代码运行得更快。  \n\n4.避免创建稀疏数组。稀疏数组由于不是所有的元素都存在，因此是一个哈希表，因此访问稀疏数组中的元素代价更高。另外，尽量不要采用预分配数量的大数组，更好的办法是随着你的需要把它的容量增大。最后，尽量不要删除数组中的元素，它会让数组变得稀疏。  \n\n5.标记值：V8采用32位来表示对象和数字，其中用一位来区别对象（flag = 0）或数字（flag = 1），因此这被称之为 SMI (Small Integer)因为它只有31位。因此，如果一个数字大于31位，V8需要对其进行包装，将其变成双精度并且用一个对象来封装它，因此应该尽量使用31位有符号数字从而避免昂贵的封装操作。  \n\n6.检查你的依赖，去掉不需要 import 的内容。  \n\n7.将你的代码分割成一些小的 chunks ，而不是整个引入。 \n \n8.尽可能使用 defer 来推迟加载 JavaScript，另外只加载当前路由需要的代码段。\n  \n9.使用 dev tools 和 DeviceTiming 来寻找代码瓶颈。  \n\n10.使用诸如Optimize.js这样的工具来帮助解析器决定何时需要提前解析以及何时需要延后解析。  \n  \n以上内容来源：\n* [How JavaScript works: Parsing, Abstract Syntax Trees (ASTs) + 5 tips on how to minimize parse time](https://blog.sessionstack.com/how-javascript-works-parsing-abstract-syntax-trees-asts-5-tips-on-how-to-minimize-parse-time-abfcf7e8a0c8)\n* [How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code](https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e)\n\n","source":"_posts/十条编写优化的JavaScript代码的建议.md","raw":"---\ntitle: 十条编写优化的 JavaScript 代码的建议\ntags:\n  - javascript\nabbrlink: 3677661280\ndate: 2018-05-29 16:59:40\n---\n\n本文总结了十条编写优秀的 JavaScript 代码的习惯，主要针对 V8 引擎：\n\n1.始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。V8 在对 js 代码解析的时候会有构建隐藏类的过程，以相同的顺序实例化（属性赋值）的对象会共享相同的隐藏类。下面给出一个不好的实践：\n\n```javascript\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\nvar p1 = new Point(1, 2);\np1.a = 5;\np1.b = 6;\nvar p2 = new Point(3, 4);\np2.b = 7;\np2.a = 8;\n// 由于 a 和 b 的赋值顺序不同，p1 和 p2 无法共享隐藏类\n```\n\n2.避免分配动态属性。在实例化之后向对象添加属性将强制隐藏类更改，并减慢为先前隐藏类优化的所有方法。相反，在其构造函数中分配所有对象的属性。  \n\n3.重复执行相同方法的代码将比仅执行一次（由于内联缓存）执行许多不同方法的代码运行得更快。  \n\n4.避免创建稀疏数组。稀疏数组由于不是所有的元素都存在，因此是一个哈希表，因此访问稀疏数组中的元素代价更高。另外，尽量不要采用预分配数量的大数组，更好的办法是随着你的需要把它的容量增大。最后，尽量不要删除数组中的元素，它会让数组变得稀疏。  \n\n5.标记值：V8采用32位来表示对象和数字，其中用一位来区别对象（flag = 0）或数字（flag = 1），因此这被称之为 SMI (Small Integer)因为它只有31位。因此，如果一个数字大于31位，V8需要对其进行包装，将其变成双精度并且用一个对象来封装它，因此应该尽量使用31位有符号数字从而避免昂贵的封装操作。  \n\n6.检查你的依赖，去掉不需要 import 的内容。  \n\n7.将你的代码分割成一些小的 chunks ，而不是整个引入。 \n \n8.尽可能使用 defer 来推迟加载 JavaScript，另外只加载当前路由需要的代码段。\n  \n9.使用 dev tools 和 DeviceTiming 来寻找代码瓶颈。  \n\n10.使用诸如Optimize.js这样的工具来帮助解析器决定何时需要提前解析以及何时需要延后解析。  \n  \n以上内容来源：\n* [How JavaScript works: Parsing, Abstract Syntax Trees (ASTs) + 5 tips on how to minimize parse time](https://blog.sessionstack.com/how-javascript-works-parsing-abstract-syntax-trees-asts-5-tips-on-how-to-minimize-parse-time-abfcf7e8a0c8)\n* [How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code](https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e)\n\n","slug":"十条编写优化的JavaScript代码的建议","published":1,"updated":"2021-12-23T05:50:07.547Z","_id":"ckxijpqt00010d3mra91kfmla","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文总结了十条编写优秀的 JavaScript 代码的习惯，主要针对 V8 引擎：</p>\n<p>1.始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。V8 在对 js 代码解析的时候会有构建隐藏类的过程，以相同的顺序实例化（属性赋值）的对象会共享相同的隐藏类。下面给出一个不好的实践：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">p1.a = <span class=\"number\">5</span>;</span><br><span class=\"line\">p1.b = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">p2.b = <span class=\"number\">7</span>;</span><br><span class=\"line\">p2.a = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"comment\">// 由于 a 和 b 的赋值顺序不同，p1 和 p2 无法共享隐藏类</span></span><br></pre></td></tr></table></figure>\n\n<p>2.避免分配动态属性。在实例化之后向对象添加属性将强制隐藏类更改，并减慢为先前隐藏类优化的所有方法。相反，在其构造函数中分配所有对象的属性。  </p>\n<p>3.重复执行相同方法的代码将比仅执行一次（由于内联缓存）执行许多不同方法的代码运行得更快。  </p>\n<p>4.避免创建稀疏数组。稀疏数组由于不是所有的元素都存在，因此是一个哈希表，因此访问稀疏数组中的元素代价更高。另外，尽量不要采用预分配数量的大数组，更好的办法是随着你的需要把它的容量增大。最后，尽量不要删除数组中的元素，它会让数组变得稀疏。  </p>\n<p>5.标记值：V8采用32位来表示对象和数字，其中用一位来区别对象（flag = 0）或数字（flag = 1），因此这被称之为 SMI (Small Integer)因为它只有31位。因此，如果一个数字大于31位，V8需要对其进行包装，将其变成双精度并且用一个对象来封装它，因此应该尽量使用31位有符号数字从而避免昂贵的封装操作。  </p>\n<p>6.检查你的依赖，去掉不需要 import 的内容。  </p>\n<p>7.将你的代码分割成一些小的 chunks ，而不是整个引入。 </p>\n<p>8.尽可能使用 defer 来推迟加载 JavaScript，另外只加载当前路由需要的代码段。</p>\n<p>9.使用 dev tools 和 DeviceTiming 来寻找代码瓶颈。  </p>\n<p>10.使用诸如Optimize.js这样的工具来帮助解析器决定何时需要提前解析以及何时需要延后解析。  </p>\n<p>以上内容来源：</p>\n<ul>\n<li><a href=\"https://blog.sessionstack.com/how-javascript-works-parsing-abstract-syntax-trees-asts-5-tips-on-how-to-minimize-parse-time-abfcf7e8a0c8\">How JavaScript works: Parsing, Abstract Syntax Trees (ASTs) + 5 tips on how to minimize parse time</a></li>\n<li><a href=\"https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e\">How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>本文总结了十条编写优秀的 JavaScript 代码的习惯，主要针对 V8 引擎：</p>\n<p>1.始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。V8 在对 js 代码解析的时候会有构建隐藏类的过程，以相同的顺序实例化（属性赋值）的对象会共享相同的隐藏类。下面给出一个不好的实践：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">p1.a = <span class=\"number\">5</span>;</span><br><span class=\"line\">p1.b = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">p2.b = <span class=\"number\">7</span>;</span><br><span class=\"line\">p2.a = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"comment\">// 由于 a 和 b 的赋值顺序不同，p1 和 p2 无法共享隐藏类</span></span><br></pre></td></tr></table></figure>\n\n<p>2.避免分配动态属性。在实例化之后向对象添加属性将强制隐藏类更改，并减慢为先前隐藏类优化的所有方法。相反，在其构造函数中分配所有对象的属性。  </p>\n<p>3.重复执行相同方法的代码将比仅执行一次（由于内联缓存）执行许多不同方法的代码运行得更快。  </p>\n<p>4.避免创建稀疏数组。稀疏数组由于不是所有的元素都存在，因此是一个哈希表，因此访问稀疏数组中的元素代价更高。另外，尽量不要采用预分配数量的大数组，更好的办法是随着你的需要把它的容量增大。最后，尽量不要删除数组中的元素，它会让数组变得稀疏。  </p>\n<p>5.标记值：V8采用32位来表示对象和数字，其中用一位来区别对象（flag = 0）或数字（flag = 1），因此这被称之为 SMI (Small Integer)因为它只有31位。因此，如果一个数字大于31位，V8需要对其进行包装，将其变成双精度并且用一个对象来封装它，因此应该尽量使用31位有符号数字从而避免昂贵的封装操作。  </p>\n<p>6.检查你的依赖，去掉不需要 import 的内容。  </p>\n<p>7.将你的代码分割成一些小的 chunks ，而不是整个引入。 </p>\n<p>8.尽可能使用 defer 来推迟加载 JavaScript，另外只加载当前路由需要的代码段。</p>\n<p>9.使用 dev tools 和 DeviceTiming 来寻找代码瓶颈。  </p>\n<p>10.使用诸如Optimize.js这样的工具来帮助解析器决定何时需要提前解析以及何时需要延后解析。  </p>\n<p>以上内容来源：</p>\n<ul>\n<li><a href=\"https://blog.sessionstack.com/how-javascript-works-parsing-abstract-syntax-trees-asts-5-tips-on-how-to-minimize-parse-time-abfcf7e8a0c8\">How JavaScript works: Parsing, Abstract Syntax Trees (ASTs) + 5 tips on how to minimize parse time</a></li>\n<li><a href=\"https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e\">How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code</a></li>\n</ul>\n"},{"title":"多组件单页列表应用的代码组织实践","abbrlink":2896282203,"date":"2018-11-10T14:25:44.000Z","_content":"\n本文主要对多组件单页面列表应用的代码组织实践进行总结，从而给相关应用的 Web 开发提供参考。\n\n### 什么是多组件单页面列表应用？\n\n目前，其实多组件单页面列表应用非常常见，也是我们日常生活中使用非常高频的一个类别的应用，最典型的比如新闻信息流产品腾讯新闻、今日头条等这类新闻应用，在这类新闻应用中，往往图片、图文、视频、问答、投票等多种模块混杂排列。再简单一点的话，知乎、豆瓣甚至一些论坛以及一些购物软件，也可以归为此类应用。\n\n由于笔者在负责QQ看点搜索模块的相关内容， 因此，这里给出一个QQ看点搜索的展示图：\n\n![](/img/kd.jpg)\n\n这类应用其实有如下特点：\n\n* 属于长列表滚动，内容随着滚动不断加载，一般在用户返回之前可能积累了大量的内容，因此可能会造成一定的性能问题。\n* 模块众多，并且模块的种类和样式更新迭代快，这给我们在复用组件的选择上带来了挑战，如果我们盲目复用组件，则会造成胶水代码越来越多，如果不复用组件，那么代码量会随着业务发展线性增长，这都给我们后续的维护带来了挑战。\n\n当然，一般的基于 Web 的应用（实际上，QQ看点搜索并不完全是纯粹的 WebView 应用）所面临的问题这里也都会遇到。不过，上述两类问题应该算是这类应用的比较重要的问题，其实归根到底，前者是性能问题（面向用户），后者是维护问题（面向开发者）。\n\n如何解决这里的性能问题，其实已经有很多常规的方案可以借鉴了，这并不是本篇文章的重点，除了传统 Web 用到的性能优化方法，这里仅仅列举一些常规的做法：\n\n* 图片等资源的懒加载。\n* 列表虚拟滚动，即使用有限的元素，优化CSS写法等。\n* 使用跨端融合方案渲染，例如 Weex、ReactNative、Hippy 等。\n\n### 多组件单页面应用的维护困境\n\n对于这类多组件单页面应用，一般都是增量发展的，即最开始只有很个别的几个模块，随着业务越来越复杂，模块越来越多，逻辑也越来越复杂。\n\n我们一开始，肯定可以想到一个模块（即上文中灰色分割线分割的一块）是一个组件，不同组件之间抽离出公共的函数，或者采用 mixin 将公共的部分抽离，至于数据端，由于这类应用通常在深度上不复杂，直接采用 React 或者 Vue 提供的父子组件通信的方式一般就够用了。这样设计既满足组件化的思路，也能够方便的维护项目，比较适合项目的初期。\n\n但是随着项目发展，我们会发现，问题慢慢地产生了：\n\n* 单元组件非常不好界定，比如一个左图右文的图文混排组件（例如刘亦菲的热点），之后又会增加左视频右文字，和图文展示的区别不大但是加了视频的播放时长，之后又加了左视频集合右文字（例如双世宠妃第一部分），如果我们把这多类内容当作一个组件，我们的组件中就会有非常多的判断代码，那么就会有大量的代码冗余，或者设计复杂的 mixin 和工具函数。\n* 除了我们自身的问题，往往随着内容增多，后端返回的数据内容也会非常的不一致，在相似甚至相同的组件中，数据格式也不尽相同，我们需要在我们的单元组件中，来解析判断多种数据格式。\n* 第三点就是样式更新隐患，当我们的组件多了之后，如果我们对我们的组件进行更新，那么很可能需要同时更新多处（嗯，全局替换也许是个不错的主意），这也是相当有风险的，也许会无意间改动我们并不想改动的 UI。\n\n如果我们等项目复杂后面对这个问题，我们会发现改动前期的代码工作量比较巨大，但是这又是我们不得不做的事情，这类问题的产生，实际上主要原因是我们的组件设计规划的不合理，我们完全可以在最初的项目中，通过一定的设计规划，来规避这些问题。\n\n### 多组件单页面应用的组件规划\n\n既然，我们现在希望设计一套比较好的组件规划，我们就需要重新审视我们的项目，对于我们的项目而言，一个业务模块一个组件的方式，的确简单方便，但是这样粗放的组件划分原则，实际上并不能完全满足我们复杂的维护需求，反而会给我们带来困扰。\n\n经过一系列的重构和整理，目前QQ看点搜索的组件规划逻辑是这样的：\n\n![](/img/kds.jpg)\n\n这里为了方便理解，我们采取上面样例图片中比较常见的一类业务：图文混排条目（左图右文和右图左文）来进行举例，如何设计组件来让提高我们项目的可维护性。\n\n这里首先是零件层，零件层应该有如下内容：\n\n* 图片零件，定宽，定高，自带懒加载，正常情况下只需传入一个 URL 即可使用。\n* 标题组件，一行标题和两行标题可以设计成两个组件，但进行 CSS 层面的复用。\n* 描述内容组件，例如双世宠妃的两行剧集描述。\n* 元信息内容组件，例如普通图文的来源和发表时间。\n* 时长组件，视频图文中用到。\n* 带有描述性的图片组件，视频图文中用到。\n* 图标组件：可以承载图标。\n\n以上各个组件的内容，几乎都足够简单，只需传入一个 props 作为内容，一般情况下，组件中不能出现 if 或 switch 等逻辑。\n\n接下来是组合器部分，组合器也是零件，只不过是零件的组合，其实也可以设计的比较薄弱，从而将更多的功能在布局器中完成，但是个别的时候，有这一层会给我们带来一定的方便，这里比如：\n\n* 图标+文字的组合器标题。\n\n对于零件层和组合层，一般情况下都不需要有影响外部的 margin 和 padding，即如果不增加任何多余样式罗列零件层和组合层，其上下左右四边应该是互相贴合的。\n\n接下来是布局层，这里的布局层，其实可以进行多种方式的设计，根据设计不同其数目也不同，这里给出一种设计方式：\n\n* 第一种是左图右文形式，右边可以选择普通图片、普通图片+时长组件、普通图片+描述。右边可以在一行标题、两行标题、描述零件、元信息零件中任意选择和组合。\n* 第二种是右图左文形式，左边的可配置内容和上文右边相同。\n\n当然，这两种整合成一种也无妨。\n\n在布局层，是拥有事件能力的，但是其主要应该是绑定响应时间并且调用通过 props 传入的回调函数，其不应该自己执行事件的响应逻辑。\n\n最后是控制器层，**在控制器层，除了包裹标签之外，不应该出现任何 html 标签，其也不应当引用除了布局层组件以外的更深层次的组件。控制层的主要作用是进行数据处理。**\n\n控制层的分类方式和上述几层稍有不同，这里，我们就不是按照 UI 来分不同的控制器了，而是按照数据或者业务来分类，因为这里我们主要是进行数据逻辑的处理，和 UI 的关系不是那么重要了（已经将 UI 的压力进行了下沉）。\n\n通过上述的做法，之后如果有新的需求增加进来，我们根据需要，在不同层级的组件增加内容就好了。\n\n### 总结\n\n通过以上的逻辑，我们把组件划分的更加清晰明确，将 UI 展示和数据逻辑分离，并且方便我们对样式进行迭代升级。\n\n当然，这个时候你也许还会问，如果我对部分组件样式进行升级改造，怎么样防止对原有的样式无影响呢？暂时还没有好的办法，不过，我们正在做的 UI 自动化测试套件——mangosteen，可以完美解决这个问题，敬请期待。","source":"_posts/多组件单页列表应用的代码组织实践.md","raw":"---\ntitle: 多组件单页列表应用的代码组织实践\ntags:\n  - 组件化\nabbrlink: 2896282203\ndate: 2018-11-10 22:25:44\n---\n\n本文主要对多组件单页面列表应用的代码组织实践进行总结，从而给相关应用的 Web 开发提供参考。\n\n### 什么是多组件单页面列表应用？\n\n目前，其实多组件单页面列表应用非常常见，也是我们日常生活中使用非常高频的一个类别的应用，最典型的比如新闻信息流产品腾讯新闻、今日头条等这类新闻应用，在这类新闻应用中，往往图片、图文、视频、问答、投票等多种模块混杂排列。再简单一点的话，知乎、豆瓣甚至一些论坛以及一些购物软件，也可以归为此类应用。\n\n由于笔者在负责QQ看点搜索模块的相关内容， 因此，这里给出一个QQ看点搜索的展示图：\n\n![](/img/kd.jpg)\n\n这类应用其实有如下特点：\n\n* 属于长列表滚动，内容随着滚动不断加载，一般在用户返回之前可能积累了大量的内容，因此可能会造成一定的性能问题。\n* 模块众多，并且模块的种类和样式更新迭代快，这给我们在复用组件的选择上带来了挑战，如果我们盲目复用组件，则会造成胶水代码越来越多，如果不复用组件，那么代码量会随着业务发展线性增长，这都给我们后续的维护带来了挑战。\n\n当然，一般的基于 Web 的应用（实际上，QQ看点搜索并不完全是纯粹的 WebView 应用）所面临的问题这里也都会遇到。不过，上述两类问题应该算是这类应用的比较重要的问题，其实归根到底，前者是性能问题（面向用户），后者是维护问题（面向开发者）。\n\n如何解决这里的性能问题，其实已经有很多常规的方案可以借鉴了，这并不是本篇文章的重点，除了传统 Web 用到的性能优化方法，这里仅仅列举一些常规的做法：\n\n* 图片等资源的懒加载。\n* 列表虚拟滚动，即使用有限的元素，优化CSS写法等。\n* 使用跨端融合方案渲染，例如 Weex、ReactNative、Hippy 等。\n\n### 多组件单页面应用的维护困境\n\n对于这类多组件单页面应用，一般都是增量发展的，即最开始只有很个别的几个模块，随着业务越来越复杂，模块越来越多，逻辑也越来越复杂。\n\n我们一开始，肯定可以想到一个模块（即上文中灰色分割线分割的一块）是一个组件，不同组件之间抽离出公共的函数，或者采用 mixin 将公共的部分抽离，至于数据端，由于这类应用通常在深度上不复杂，直接采用 React 或者 Vue 提供的父子组件通信的方式一般就够用了。这样设计既满足组件化的思路，也能够方便的维护项目，比较适合项目的初期。\n\n但是随着项目发展，我们会发现，问题慢慢地产生了：\n\n* 单元组件非常不好界定，比如一个左图右文的图文混排组件（例如刘亦菲的热点），之后又会增加左视频右文字，和图文展示的区别不大但是加了视频的播放时长，之后又加了左视频集合右文字（例如双世宠妃第一部分），如果我们把这多类内容当作一个组件，我们的组件中就会有非常多的判断代码，那么就会有大量的代码冗余，或者设计复杂的 mixin 和工具函数。\n* 除了我们自身的问题，往往随着内容增多，后端返回的数据内容也会非常的不一致，在相似甚至相同的组件中，数据格式也不尽相同，我们需要在我们的单元组件中，来解析判断多种数据格式。\n* 第三点就是样式更新隐患，当我们的组件多了之后，如果我们对我们的组件进行更新，那么很可能需要同时更新多处（嗯，全局替换也许是个不错的主意），这也是相当有风险的，也许会无意间改动我们并不想改动的 UI。\n\n如果我们等项目复杂后面对这个问题，我们会发现改动前期的代码工作量比较巨大，但是这又是我们不得不做的事情，这类问题的产生，实际上主要原因是我们的组件设计规划的不合理，我们完全可以在最初的项目中，通过一定的设计规划，来规避这些问题。\n\n### 多组件单页面应用的组件规划\n\n既然，我们现在希望设计一套比较好的组件规划，我们就需要重新审视我们的项目，对于我们的项目而言，一个业务模块一个组件的方式，的确简单方便，但是这样粗放的组件划分原则，实际上并不能完全满足我们复杂的维护需求，反而会给我们带来困扰。\n\n经过一系列的重构和整理，目前QQ看点搜索的组件规划逻辑是这样的：\n\n![](/img/kds.jpg)\n\n这里为了方便理解，我们采取上面样例图片中比较常见的一类业务：图文混排条目（左图右文和右图左文）来进行举例，如何设计组件来让提高我们项目的可维护性。\n\n这里首先是零件层，零件层应该有如下内容：\n\n* 图片零件，定宽，定高，自带懒加载，正常情况下只需传入一个 URL 即可使用。\n* 标题组件，一行标题和两行标题可以设计成两个组件，但进行 CSS 层面的复用。\n* 描述内容组件，例如双世宠妃的两行剧集描述。\n* 元信息内容组件，例如普通图文的来源和发表时间。\n* 时长组件，视频图文中用到。\n* 带有描述性的图片组件，视频图文中用到。\n* 图标组件：可以承载图标。\n\n以上各个组件的内容，几乎都足够简单，只需传入一个 props 作为内容，一般情况下，组件中不能出现 if 或 switch 等逻辑。\n\n接下来是组合器部分，组合器也是零件，只不过是零件的组合，其实也可以设计的比较薄弱，从而将更多的功能在布局器中完成，但是个别的时候，有这一层会给我们带来一定的方便，这里比如：\n\n* 图标+文字的组合器标题。\n\n对于零件层和组合层，一般情况下都不需要有影响外部的 margin 和 padding，即如果不增加任何多余样式罗列零件层和组合层，其上下左右四边应该是互相贴合的。\n\n接下来是布局层，这里的布局层，其实可以进行多种方式的设计，根据设计不同其数目也不同，这里给出一种设计方式：\n\n* 第一种是左图右文形式，右边可以选择普通图片、普通图片+时长组件、普通图片+描述。右边可以在一行标题、两行标题、描述零件、元信息零件中任意选择和组合。\n* 第二种是右图左文形式，左边的可配置内容和上文右边相同。\n\n当然，这两种整合成一种也无妨。\n\n在布局层，是拥有事件能力的，但是其主要应该是绑定响应时间并且调用通过 props 传入的回调函数，其不应该自己执行事件的响应逻辑。\n\n最后是控制器层，**在控制器层，除了包裹标签之外，不应该出现任何 html 标签，其也不应当引用除了布局层组件以外的更深层次的组件。控制层的主要作用是进行数据处理。**\n\n控制层的分类方式和上述几层稍有不同，这里，我们就不是按照 UI 来分不同的控制器了，而是按照数据或者业务来分类，因为这里我们主要是进行数据逻辑的处理，和 UI 的关系不是那么重要了（已经将 UI 的压力进行了下沉）。\n\n通过上述的做法，之后如果有新的需求增加进来，我们根据需要，在不同层级的组件增加内容就好了。\n\n### 总结\n\n通过以上的逻辑，我们把组件划分的更加清晰明确，将 UI 展示和数据逻辑分离，并且方便我们对样式进行迭代升级。\n\n当然，这个时候你也许还会问，如果我对部分组件样式进行升级改造，怎么样防止对原有的样式无影响呢？暂时还没有好的办法，不过，我们正在做的 UI 自动化测试套件——mangosteen，可以完美解决这个问题，敬请期待。","slug":"多组件单页列表应用的代码组织实践","published":1,"updated":"2021-12-23T05:50:07.548Z","_id":"ckxijpqt00012d3mrgbxfevmn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要对多组件单页面列表应用的代码组织实践进行总结，从而给相关应用的 Web 开发提供参考。</p>\n<h3 id=\"什么是多组件单页面列表应用？\"><a href=\"#什么是多组件单页面列表应用？\" class=\"headerlink\" title=\"什么是多组件单页面列表应用？\"></a>什么是多组件单页面列表应用？</h3><p>目前，其实多组件单页面列表应用非常常见，也是我们日常生活中使用非常高频的一个类别的应用，最典型的比如新闻信息流产品腾讯新闻、今日头条等这类新闻应用，在这类新闻应用中，往往图片、图文、视频、问答、投票等多种模块混杂排列。再简单一点的话，知乎、豆瓣甚至一些论坛以及一些购物软件，也可以归为此类应用。</p>\n<p>由于笔者在负责QQ看点搜索模块的相关内容， 因此，这里给出一个QQ看点搜索的展示图：</p>\n<p><img src=\"/img/kd.jpg\"></p>\n<p>这类应用其实有如下特点：</p>\n<ul>\n<li>属于长列表滚动，内容随着滚动不断加载，一般在用户返回之前可能积累了大量的内容，因此可能会造成一定的性能问题。</li>\n<li>模块众多，并且模块的种类和样式更新迭代快，这给我们在复用组件的选择上带来了挑战，如果我们盲目复用组件，则会造成胶水代码越来越多，如果不复用组件，那么代码量会随着业务发展线性增长，这都给我们后续的维护带来了挑战。</li>\n</ul>\n<p>当然，一般的基于 Web 的应用（实际上，QQ看点搜索并不完全是纯粹的 WebView 应用）所面临的问题这里也都会遇到。不过，上述两类问题应该算是这类应用的比较重要的问题，其实归根到底，前者是性能问题（面向用户），后者是维护问题（面向开发者）。</p>\n<p>如何解决这里的性能问题，其实已经有很多常规的方案可以借鉴了，这并不是本篇文章的重点，除了传统 Web 用到的性能优化方法，这里仅仅列举一些常规的做法：</p>\n<ul>\n<li>图片等资源的懒加载。</li>\n<li>列表虚拟滚动，即使用有限的元素，优化CSS写法等。</li>\n<li>使用跨端融合方案渲染，例如 Weex、ReactNative、Hippy 等。</li>\n</ul>\n<h3 id=\"多组件单页面应用的维护困境\"><a href=\"#多组件单页面应用的维护困境\" class=\"headerlink\" title=\"多组件单页面应用的维护困境\"></a>多组件单页面应用的维护困境</h3><p>对于这类多组件单页面应用，一般都是增量发展的，即最开始只有很个别的几个模块，随着业务越来越复杂，模块越来越多，逻辑也越来越复杂。</p>\n<p>我们一开始，肯定可以想到一个模块（即上文中灰色分割线分割的一块）是一个组件，不同组件之间抽离出公共的函数，或者采用 mixin 将公共的部分抽离，至于数据端，由于这类应用通常在深度上不复杂，直接采用 React 或者 Vue 提供的父子组件通信的方式一般就够用了。这样设计既满足组件化的思路，也能够方便的维护项目，比较适合项目的初期。</p>\n<p>但是随着项目发展，我们会发现，问题慢慢地产生了：</p>\n<ul>\n<li>单元组件非常不好界定，比如一个左图右文的图文混排组件（例如刘亦菲的热点），之后又会增加左视频右文字，和图文展示的区别不大但是加了视频的播放时长，之后又加了左视频集合右文字（例如双世宠妃第一部分），如果我们把这多类内容当作一个组件，我们的组件中就会有非常多的判断代码，那么就会有大量的代码冗余，或者设计复杂的 mixin 和工具函数。</li>\n<li>除了我们自身的问题，往往随着内容增多，后端返回的数据内容也会非常的不一致，在相似甚至相同的组件中，数据格式也不尽相同，我们需要在我们的单元组件中，来解析判断多种数据格式。</li>\n<li>第三点就是样式更新隐患，当我们的组件多了之后，如果我们对我们的组件进行更新，那么很可能需要同时更新多处（嗯，全局替换也许是个不错的主意），这也是相当有风险的，也许会无意间改动我们并不想改动的 UI。</li>\n</ul>\n<p>如果我们等项目复杂后面对这个问题，我们会发现改动前期的代码工作量比较巨大，但是这又是我们不得不做的事情，这类问题的产生，实际上主要原因是我们的组件设计规划的不合理，我们完全可以在最初的项目中，通过一定的设计规划，来规避这些问题。</p>\n<h3 id=\"多组件单页面应用的组件规划\"><a href=\"#多组件单页面应用的组件规划\" class=\"headerlink\" title=\"多组件单页面应用的组件规划\"></a>多组件单页面应用的组件规划</h3><p>既然，我们现在希望设计一套比较好的组件规划，我们就需要重新审视我们的项目，对于我们的项目而言，一个业务模块一个组件的方式，的确简单方便，但是这样粗放的组件划分原则，实际上并不能完全满足我们复杂的维护需求，反而会给我们带来困扰。</p>\n<p>经过一系列的重构和整理，目前QQ看点搜索的组件规划逻辑是这样的：</p>\n<p><img src=\"/img/kds.jpg\"></p>\n<p>这里为了方便理解，我们采取上面样例图片中比较常见的一类业务：图文混排条目（左图右文和右图左文）来进行举例，如何设计组件来让提高我们项目的可维护性。</p>\n<p>这里首先是零件层，零件层应该有如下内容：</p>\n<ul>\n<li>图片零件，定宽，定高，自带懒加载，正常情况下只需传入一个 URL 即可使用。</li>\n<li>标题组件，一行标题和两行标题可以设计成两个组件，但进行 CSS 层面的复用。</li>\n<li>描述内容组件，例如双世宠妃的两行剧集描述。</li>\n<li>元信息内容组件，例如普通图文的来源和发表时间。</li>\n<li>时长组件，视频图文中用到。</li>\n<li>带有描述性的图片组件，视频图文中用到。</li>\n<li>图标组件：可以承载图标。</li>\n</ul>\n<p>以上各个组件的内容，几乎都足够简单，只需传入一个 props 作为内容，一般情况下，组件中不能出现 if 或 switch 等逻辑。</p>\n<p>接下来是组合器部分，组合器也是零件，只不过是零件的组合，其实也可以设计的比较薄弱，从而将更多的功能在布局器中完成，但是个别的时候，有这一层会给我们带来一定的方便，这里比如：</p>\n<ul>\n<li>图标+文字的组合器标题。</li>\n</ul>\n<p>对于零件层和组合层，一般情况下都不需要有影响外部的 margin 和 padding，即如果不增加任何多余样式罗列零件层和组合层，其上下左右四边应该是互相贴合的。</p>\n<p>接下来是布局层，这里的布局层，其实可以进行多种方式的设计，根据设计不同其数目也不同，这里给出一种设计方式：</p>\n<ul>\n<li>第一种是左图右文形式，右边可以选择普通图片、普通图片+时长组件、普通图片+描述。右边可以在一行标题、两行标题、描述零件、元信息零件中任意选择和组合。</li>\n<li>第二种是右图左文形式，左边的可配置内容和上文右边相同。</li>\n</ul>\n<p>当然，这两种整合成一种也无妨。</p>\n<p>在布局层，是拥有事件能力的，但是其主要应该是绑定响应时间并且调用通过 props 传入的回调函数，其不应该自己执行事件的响应逻辑。</p>\n<p>最后是控制器层，<strong>在控制器层，除了包裹标签之外，不应该出现任何 html 标签，其也不应当引用除了布局层组件以外的更深层次的组件。控制层的主要作用是进行数据处理。</strong></p>\n<p>控制层的分类方式和上述几层稍有不同，这里，我们就不是按照 UI 来分不同的控制器了，而是按照数据或者业务来分类，因为这里我们主要是进行数据逻辑的处理，和 UI 的关系不是那么重要了（已经将 UI 的压力进行了下沉）。</p>\n<p>通过上述的做法，之后如果有新的需求增加进来，我们根据需要，在不同层级的组件增加内容就好了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过以上的逻辑，我们把组件划分的更加清晰明确，将 UI 展示和数据逻辑分离，并且方便我们对样式进行迭代升级。</p>\n<p>当然，这个时候你也许还会问，如果我对部分组件样式进行升级改造，怎么样防止对原有的样式无影响呢？暂时还没有好的办法，不过，我们正在做的 UI 自动化测试套件——mangosteen，可以完美解决这个问题，敬请期待。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文主要对多组件单页面列表应用的代码组织实践进行总结，从而给相关应用的 Web 开发提供参考。</p>\n<h3 id=\"什么是多组件单页面列表应用？\"><a href=\"#什么是多组件单页面列表应用？\" class=\"headerlink\" title=\"什么是多组件单页面列表应用？\"></a>什么是多组件单页面列表应用？</h3><p>目前，其实多组件单页面列表应用非常常见，也是我们日常生活中使用非常高频的一个类别的应用，最典型的比如新闻信息流产品腾讯新闻、今日头条等这类新闻应用，在这类新闻应用中，往往图片、图文、视频、问答、投票等多种模块混杂排列。再简单一点的话，知乎、豆瓣甚至一些论坛以及一些购物软件，也可以归为此类应用。</p>\n<p>由于笔者在负责QQ看点搜索模块的相关内容， 因此，这里给出一个QQ看点搜索的展示图：</p>\n<p><img src=\"/img/kd.jpg\"></p>\n<p>这类应用其实有如下特点：</p>\n<ul>\n<li>属于长列表滚动，内容随着滚动不断加载，一般在用户返回之前可能积累了大量的内容，因此可能会造成一定的性能问题。</li>\n<li>模块众多，并且模块的种类和样式更新迭代快，这给我们在复用组件的选择上带来了挑战，如果我们盲目复用组件，则会造成胶水代码越来越多，如果不复用组件，那么代码量会随着业务发展线性增长，这都给我们后续的维护带来了挑战。</li>\n</ul>\n<p>当然，一般的基于 Web 的应用（实际上，QQ看点搜索并不完全是纯粹的 WebView 应用）所面临的问题这里也都会遇到。不过，上述两类问题应该算是这类应用的比较重要的问题，其实归根到底，前者是性能问题（面向用户），后者是维护问题（面向开发者）。</p>\n<p>如何解决这里的性能问题，其实已经有很多常规的方案可以借鉴了，这并不是本篇文章的重点，除了传统 Web 用到的性能优化方法，这里仅仅列举一些常规的做法：</p>\n<ul>\n<li>图片等资源的懒加载。</li>\n<li>列表虚拟滚动，即使用有限的元素，优化CSS写法等。</li>\n<li>使用跨端融合方案渲染，例如 Weex、ReactNative、Hippy 等。</li>\n</ul>\n<h3 id=\"多组件单页面应用的维护困境\"><a href=\"#多组件单页面应用的维护困境\" class=\"headerlink\" title=\"多组件单页面应用的维护困境\"></a>多组件单页面应用的维护困境</h3><p>对于这类多组件单页面应用，一般都是增量发展的，即最开始只有很个别的几个模块，随着业务越来越复杂，模块越来越多，逻辑也越来越复杂。</p>\n<p>我们一开始，肯定可以想到一个模块（即上文中灰色分割线分割的一块）是一个组件，不同组件之间抽离出公共的函数，或者采用 mixin 将公共的部分抽离，至于数据端，由于这类应用通常在深度上不复杂，直接采用 React 或者 Vue 提供的父子组件通信的方式一般就够用了。这样设计既满足组件化的思路，也能够方便的维护项目，比较适合项目的初期。</p>\n<p>但是随着项目发展，我们会发现，问题慢慢地产生了：</p>\n<ul>\n<li>单元组件非常不好界定，比如一个左图右文的图文混排组件（例如刘亦菲的热点），之后又会增加左视频右文字，和图文展示的区别不大但是加了视频的播放时长，之后又加了左视频集合右文字（例如双世宠妃第一部分），如果我们把这多类内容当作一个组件，我们的组件中就会有非常多的判断代码，那么就会有大量的代码冗余，或者设计复杂的 mixin 和工具函数。</li>\n<li>除了我们自身的问题，往往随着内容增多，后端返回的数据内容也会非常的不一致，在相似甚至相同的组件中，数据格式也不尽相同，我们需要在我们的单元组件中，来解析判断多种数据格式。</li>\n<li>第三点就是样式更新隐患，当我们的组件多了之后，如果我们对我们的组件进行更新，那么很可能需要同时更新多处（嗯，全局替换也许是个不错的主意），这也是相当有风险的，也许会无意间改动我们并不想改动的 UI。</li>\n</ul>\n<p>如果我们等项目复杂后面对这个问题，我们会发现改动前期的代码工作量比较巨大，但是这又是我们不得不做的事情，这类问题的产生，实际上主要原因是我们的组件设计规划的不合理，我们完全可以在最初的项目中，通过一定的设计规划，来规避这些问题。</p>\n<h3 id=\"多组件单页面应用的组件规划\"><a href=\"#多组件单页面应用的组件规划\" class=\"headerlink\" title=\"多组件单页面应用的组件规划\"></a>多组件单页面应用的组件规划</h3><p>既然，我们现在希望设计一套比较好的组件规划，我们就需要重新审视我们的项目，对于我们的项目而言，一个业务模块一个组件的方式，的确简单方便，但是这样粗放的组件划分原则，实际上并不能完全满足我们复杂的维护需求，反而会给我们带来困扰。</p>\n<p>经过一系列的重构和整理，目前QQ看点搜索的组件规划逻辑是这样的：</p>\n<p><img src=\"/img/kds.jpg\"></p>\n<p>这里为了方便理解，我们采取上面样例图片中比较常见的一类业务：图文混排条目（左图右文和右图左文）来进行举例，如何设计组件来让提高我们项目的可维护性。</p>\n<p>这里首先是零件层，零件层应该有如下内容：</p>\n<ul>\n<li>图片零件，定宽，定高，自带懒加载，正常情况下只需传入一个 URL 即可使用。</li>\n<li>标题组件，一行标题和两行标题可以设计成两个组件，但进行 CSS 层面的复用。</li>\n<li>描述内容组件，例如双世宠妃的两行剧集描述。</li>\n<li>元信息内容组件，例如普通图文的来源和发表时间。</li>\n<li>时长组件，视频图文中用到。</li>\n<li>带有描述性的图片组件，视频图文中用到。</li>\n<li>图标组件：可以承载图标。</li>\n</ul>\n<p>以上各个组件的内容，几乎都足够简单，只需传入一个 props 作为内容，一般情况下，组件中不能出现 if 或 switch 等逻辑。</p>\n<p>接下来是组合器部分，组合器也是零件，只不过是零件的组合，其实也可以设计的比较薄弱，从而将更多的功能在布局器中完成，但是个别的时候，有这一层会给我们带来一定的方便，这里比如：</p>\n<ul>\n<li>图标+文字的组合器标题。</li>\n</ul>\n<p>对于零件层和组合层，一般情况下都不需要有影响外部的 margin 和 padding，即如果不增加任何多余样式罗列零件层和组合层，其上下左右四边应该是互相贴合的。</p>\n<p>接下来是布局层，这里的布局层，其实可以进行多种方式的设计，根据设计不同其数目也不同，这里给出一种设计方式：</p>\n<ul>\n<li>第一种是左图右文形式，右边可以选择普通图片、普通图片+时长组件、普通图片+描述。右边可以在一行标题、两行标题、描述零件、元信息零件中任意选择和组合。</li>\n<li>第二种是右图左文形式，左边的可配置内容和上文右边相同。</li>\n</ul>\n<p>当然，这两种整合成一种也无妨。</p>\n<p>在布局层，是拥有事件能力的，但是其主要应该是绑定响应时间并且调用通过 props 传入的回调函数，其不应该自己执行事件的响应逻辑。</p>\n<p>最后是控制器层，<strong>在控制器层，除了包裹标签之外，不应该出现任何 html 标签，其也不应当引用除了布局层组件以外的更深层次的组件。控制层的主要作用是进行数据处理。</strong></p>\n<p>控制层的分类方式和上述几层稍有不同，这里，我们就不是按照 UI 来分不同的控制器了，而是按照数据或者业务来分类，因为这里我们主要是进行数据逻辑的处理，和 UI 的关系不是那么重要了（已经将 UI 的压力进行了下沉）。</p>\n<p>通过上述的做法，之后如果有新的需求增加进来，我们根据需要，在不同层级的组件增加内容就好了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过以上的逻辑，我们把组件划分的更加清晰明确，将 UI 展示和数据逻辑分离，并且方便我们对样式进行迭代升级。</p>\n<p>当然，这个时候你也许还会问，如果我对部分组件样式进行升级改造，怎么样防止对原有的样式无影响呢？暂时还没有好的办法，不过，我们正在做的 UI 自动化测试套件——mangosteen，可以完美解决这个问题，敬请期待。</p>\n"},{"title":"如何让你的精力更多的用于提高技术深度","abbrlink":2418669398,"date":"2021-07-26T15:42:20.000Z","_content":"\n[知乎版本](https://zhuanlan.zhihu.com/p/395177123)\n\n题目所述，就是我最近很久一段时间都在用来思考的问题。\n\n先说下个人的背景，目前已经毕业三年，第一年主要做前端开发，大约在两年前，我的主要精力从前端转向了 Rust，而后又开始在公司参与开发 c++。\n\n在这三年里面，自己持续面临着一个问题，这个问题就是，如何从一个繁忙而重复的工作中，持续提升自己的技术深度。\n\n因为我发现，当在一个公司久了以后，随着参与的业务增多，问题和 OnCall 也随之增多，另外随着你对业务的熟悉，会有越来越多的新同学向你问问题。处理这些问题会占据越来越多的精力。当然，如果你比较“幸运”中途业务黄掉或架构彻底变化了，你去参与新的项目，有可能能获得一次接近重新开始的机会，但大多数时候，你可能都没有这么幸运。\n\n当这些问题处理的久了以后，你会发现甚至连完成工作都需要加班来解决，就更没有时间来进行技术的提升了，长此以往，焦虑感便倍增。\n\n不过，最近我在思考这些问题的过程中，也渐渐总结了一些缓解的办法，接下来便和大家进行分享。\n\n**这里的核心点在于，减少犯错误的机会，提高处理问题的效率，释放出自己的更多时间**\n\n## 1. 提高对代码的要求，写更好的代码\n\n我最近处理的众多问题，粗略估算，有大约 1/3 都是由于开发者代码水平不足带来的技术债务（即代码逻辑错误、边界情况未考虑、性能与稳定性不足等）。\n\n我这里主要针对的是 PC 客户端，还有很多问题和特殊机器、其他模块干扰项、硬件驱动等关系密切，如果是纯前端项目，这个比例只会更高。\n\n因为写代码的时候，并没有采用最合理的方式，导致有出现问题的隐患，如果你的问题出现的概率比较高，大概率会比较幸运地较早发现，但如果出现的概率低，甚至灰度阶段都没有暴露，那么当初几行代码的问题，会让自己之后花加倍的时间来去处理，甚至还可能面临更多后果。\n\n那么，如何让自己写出更好的代码呢，我认为可以做到以下几点：\n\n* **请熟读文档**，比如如果是在开发 Vue 项目，那么请至少把 Vue 的文档看一遍，React 同理，这样你会更加清楚，框架到底提供了那些能力，什么时候使用更合适的 API 来完成一个目标。\n* 注重注释，对于一些特殊处理的情况，注释是很有必要的，最好附上文档，否则可能时间久了，自己都不知道为什么这样去处理，会让修复问题花费更多的时间。\n* 除非迫不得已，不要提交带有已知优化项的代码，例如重复代码并没有完全处理、代码在某些情况还可能造成问题。时间允许的情况下，一步到位，通常比分两次到位能节约更多的时间，至少能节约一次测试的时间，另外大脑的上下文切换还有开销。\n* CI/CD 的建设，保证合并的代码是能够编译的。\n* 对于前端来说，全部采用 Typescript，使用 ESLint 约束代码，**禁止**直接使用 JavaScript。\n* 团队需要建立 Review 机制，并且对 Review 过程负责。对于别人提交 Review 的代码至少需要通读一遍，避免基本的错误。\n\n## 2. 日志是语言的另一面，也很能体现代码水平\n\n这里的日志，指的是在用户使用过程中，实时上传的的或者离线的日志。\n\n这里单独提一点日志，是因为在实际中，我们大约有一半时间在写代码，而另外一半时间在查问题，那么为什么就不能好好写日志呢？\n\n“日志不足/没打日志，需要加日志进一步定位”。\n\n不知道你在 OnCall 的过程中，是否遇到过此类回复，当然并不能说每次这样的问题都是开发者水平不足导致日志不全，但的确有很多情况是我们可以提前规避的。\n\n那么一个好的日志应该是什么样的呢？\n\n1. 前提：废话不要多，能简写就简写，这是因为一般日志都是存在用户本地的，日志量比较大的情况下会影响用户的硬盘占用，当然日志本身的打印也是消耗 CPU 的。\n2. 关键路径的日志要有，可能出问题的地方不要存在侥幸心理，把日志打全，特别是**不同负责模块之间衔接的日志，一定打全**，这样之后甩锅的时候有实锤也会方便一点。\n3. 关键日志需要有关键字，方便后面自动化分析，毕竟，对于一个比较完善的项目而言，机器人分析日志甚至比人分析更为靠谱。\n4. 日志也需要**向前兼容**，最好不要对以前的日志进行改动，这点我们可能通常会忽略，如果没有必要，建议不要对日志进行大的变动，防止自动化工具和其他分析日志的同学不知情。\n\n什么？你说你们团队还没有日志系统？\n\n那么第一件事，就是要有一个完善的离线日志回捞系统或在线日志系统。\n\n## 3. 打破边界有助于开阔视野，但是是否深入需要慎重决定\n\n虽然有的时候，员工打破边界对于公司来书并不是一个好事情，但大多数情况来说，对个人还是会有所帮助的。\n\n> 为什么说不是一个好事情呢，比如一个客户端的同学，去做 c++ 了，这个时候应该鼓励还是反对呢。实际上这个时候，他除了仅存的业务熟悉度和一些通用的编程能力，c++ 的能力也许就只有应届生的水平，如果从新招聘可能连初试都过不了。公司就必须要承担因为他的编程能力不熟练带来的效率损失，甚至因为更容易引发问题造成更大的损失。\n\n为什么说，对于个人来说是一个好事情呢，这个主要体现在以下几个方面：\n\n* 在公司中大多数情况下都是多个语言的开发者相互配合的，而当你同时参与了你上游或者下游的工作，你会发现沟通会更加顺畅了，甚至自己也拥有了简单的处理需求和问题的能力，底气会高很多。\n* 在你学习多个语言的过程中你会发现一些精华的部分，比如通用的框架设计方法、模块组织方法等各个语言都是通用的，甚至有些代码你直接翻译过来就可以直接用了，这也可以让你更深刻地了解到哪些是编程的精髓。\n\n当然，有的时候如果你跨界参与的太多，例如本身是一个资深的前端开发者，当你跨界参与了 c++ 开发，你会发现短时间内你的前端水平是在下降的，而 c++ 水平也没有达到独立承担工作的程度，这短时间内你的市场价值其实是有所下降的，这也是你需要慎重考虑到底要参与多少的原因之一。\n\n\n## 4. 复杂系统的初始架构设计，可以作为一个最后兜底\n\n实际上，复杂的系统大多一开始都不复杂，但是如何正确地预判系统的走向，设计出可以沿用很久的基础骨架、约束性强却扩展型足够的组件系统（即使后来来的人水平差也不至于写出太难维护的代码），以及和外界其他系统进行灵活的配合，是对水平有一定的考验的。\n\n这里我以某视频会议 App 举例，其最开始只有视频+音频的简单能力，在此基础上，团队负责人设计并编写了基于 Typescript 的核心状态机、按照 minor repo 划分了主要模块，设计了 Store 状态存储，设计了一套 API 注入方式可以注入系统外的 API 等等。\n\n这套架构沿用了三年，核心代码基本没有发生变化，功能上却新增了共享屏幕、共享网页、聊天/表情、标注/白板、远程控制、字幕/录制/翻译、日程会议、面试等若干重要的模块。\n\n虽然实际上，随着后面的同学的增多，以及最初核心开发者的离职，开发人员已经几乎换了一批，但是这套代码和架构基本上没发生太多变化，也一直支撑着若干项目。\n\n（p.s. 据说最开始参与设计的同学吐槽后面的维护有点渐渐跑题，但是整体还是可用性比较高的）。\n\n如果没有一定水平，想必业务框架早就随着业务的变更重构过多次了，肯定会带来巨大的人力浪费。\n\n## 5. 持续练习，持续关注行业动态\n\n最后一点，持续学习，大概是程序员的宿命吧。\n\n这里其实不用多说了，但是想提一点，其实有的时候如果你发现主动的持续学习会比较难的情况下，可以选择一种半被动的方式。\n\n比如，每周给自己定日程参与 leetcode 周赛，你把它当作自己工作的无可推脱的一部分，这样持续几次，你就会慢慢习惯这个过程。\n\n---\n\n以上共勉。\n\n\n\n","source":"_posts/如何让你的精力更多的用于提高技术深度.md","raw":"---\ntitle: 如何让你的精力更多的用于提高技术深度\ntags:\n  - 前端综合\nabbrlink: 2418669398\ndate: 2021-07-26 23:42:20\n---\n\n[知乎版本](https://zhuanlan.zhihu.com/p/395177123)\n\n题目所述，就是我最近很久一段时间都在用来思考的问题。\n\n先说下个人的背景，目前已经毕业三年，第一年主要做前端开发，大约在两年前，我的主要精力从前端转向了 Rust，而后又开始在公司参与开发 c++。\n\n在这三年里面，自己持续面临着一个问题，这个问题就是，如何从一个繁忙而重复的工作中，持续提升自己的技术深度。\n\n因为我发现，当在一个公司久了以后，随着参与的业务增多，问题和 OnCall 也随之增多，另外随着你对业务的熟悉，会有越来越多的新同学向你问问题。处理这些问题会占据越来越多的精力。当然，如果你比较“幸运”中途业务黄掉或架构彻底变化了，你去参与新的项目，有可能能获得一次接近重新开始的机会，但大多数时候，你可能都没有这么幸运。\n\n当这些问题处理的久了以后，你会发现甚至连完成工作都需要加班来解决，就更没有时间来进行技术的提升了，长此以往，焦虑感便倍增。\n\n不过，最近我在思考这些问题的过程中，也渐渐总结了一些缓解的办法，接下来便和大家进行分享。\n\n**这里的核心点在于，减少犯错误的机会，提高处理问题的效率，释放出自己的更多时间**\n\n## 1. 提高对代码的要求，写更好的代码\n\n我最近处理的众多问题，粗略估算，有大约 1/3 都是由于开发者代码水平不足带来的技术债务（即代码逻辑错误、边界情况未考虑、性能与稳定性不足等）。\n\n我这里主要针对的是 PC 客户端，还有很多问题和特殊机器、其他模块干扰项、硬件驱动等关系密切，如果是纯前端项目，这个比例只会更高。\n\n因为写代码的时候，并没有采用最合理的方式，导致有出现问题的隐患，如果你的问题出现的概率比较高，大概率会比较幸运地较早发现，但如果出现的概率低，甚至灰度阶段都没有暴露，那么当初几行代码的问题，会让自己之后花加倍的时间来去处理，甚至还可能面临更多后果。\n\n那么，如何让自己写出更好的代码呢，我认为可以做到以下几点：\n\n* **请熟读文档**，比如如果是在开发 Vue 项目，那么请至少把 Vue 的文档看一遍，React 同理，这样你会更加清楚，框架到底提供了那些能力，什么时候使用更合适的 API 来完成一个目标。\n* 注重注释，对于一些特殊处理的情况，注释是很有必要的，最好附上文档，否则可能时间久了，自己都不知道为什么这样去处理，会让修复问题花费更多的时间。\n* 除非迫不得已，不要提交带有已知优化项的代码，例如重复代码并没有完全处理、代码在某些情况还可能造成问题。时间允许的情况下，一步到位，通常比分两次到位能节约更多的时间，至少能节约一次测试的时间，另外大脑的上下文切换还有开销。\n* CI/CD 的建设，保证合并的代码是能够编译的。\n* 对于前端来说，全部采用 Typescript，使用 ESLint 约束代码，**禁止**直接使用 JavaScript。\n* 团队需要建立 Review 机制，并且对 Review 过程负责。对于别人提交 Review 的代码至少需要通读一遍，避免基本的错误。\n\n## 2. 日志是语言的另一面，也很能体现代码水平\n\n这里的日志，指的是在用户使用过程中，实时上传的的或者离线的日志。\n\n这里单独提一点日志，是因为在实际中，我们大约有一半时间在写代码，而另外一半时间在查问题，那么为什么就不能好好写日志呢？\n\n“日志不足/没打日志，需要加日志进一步定位”。\n\n不知道你在 OnCall 的过程中，是否遇到过此类回复，当然并不能说每次这样的问题都是开发者水平不足导致日志不全，但的确有很多情况是我们可以提前规避的。\n\n那么一个好的日志应该是什么样的呢？\n\n1. 前提：废话不要多，能简写就简写，这是因为一般日志都是存在用户本地的，日志量比较大的情况下会影响用户的硬盘占用，当然日志本身的打印也是消耗 CPU 的。\n2. 关键路径的日志要有，可能出问题的地方不要存在侥幸心理，把日志打全，特别是**不同负责模块之间衔接的日志，一定打全**，这样之后甩锅的时候有实锤也会方便一点。\n3. 关键日志需要有关键字，方便后面自动化分析，毕竟，对于一个比较完善的项目而言，机器人分析日志甚至比人分析更为靠谱。\n4. 日志也需要**向前兼容**，最好不要对以前的日志进行改动，这点我们可能通常会忽略，如果没有必要，建议不要对日志进行大的变动，防止自动化工具和其他分析日志的同学不知情。\n\n什么？你说你们团队还没有日志系统？\n\n那么第一件事，就是要有一个完善的离线日志回捞系统或在线日志系统。\n\n## 3. 打破边界有助于开阔视野，但是是否深入需要慎重决定\n\n虽然有的时候，员工打破边界对于公司来书并不是一个好事情，但大多数情况来说，对个人还是会有所帮助的。\n\n> 为什么说不是一个好事情呢，比如一个客户端的同学，去做 c++ 了，这个时候应该鼓励还是反对呢。实际上这个时候，他除了仅存的业务熟悉度和一些通用的编程能力，c++ 的能力也许就只有应届生的水平，如果从新招聘可能连初试都过不了。公司就必须要承担因为他的编程能力不熟练带来的效率损失，甚至因为更容易引发问题造成更大的损失。\n\n为什么说，对于个人来说是一个好事情呢，这个主要体现在以下几个方面：\n\n* 在公司中大多数情况下都是多个语言的开发者相互配合的，而当你同时参与了你上游或者下游的工作，你会发现沟通会更加顺畅了，甚至自己也拥有了简单的处理需求和问题的能力，底气会高很多。\n* 在你学习多个语言的过程中你会发现一些精华的部分，比如通用的框架设计方法、模块组织方法等各个语言都是通用的，甚至有些代码你直接翻译过来就可以直接用了，这也可以让你更深刻地了解到哪些是编程的精髓。\n\n当然，有的时候如果你跨界参与的太多，例如本身是一个资深的前端开发者，当你跨界参与了 c++ 开发，你会发现短时间内你的前端水平是在下降的，而 c++ 水平也没有达到独立承担工作的程度，这短时间内你的市场价值其实是有所下降的，这也是你需要慎重考虑到底要参与多少的原因之一。\n\n\n## 4. 复杂系统的初始架构设计，可以作为一个最后兜底\n\n实际上，复杂的系统大多一开始都不复杂，但是如何正确地预判系统的走向，设计出可以沿用很久的基础骨架、约束性强却扩展型足够的组件系统（即使后来来的人水平差也不至于写出太难维护的代码），以及和外界其他系统进行灵活的配合，是对水平有一定的考验的。\n\n这里我以某视频会议 App 举例，其最开始只有视频+音频的简单能力，在此基础上，团队负责人设计并编写了基于 Typescript 的核心状态机、按照 minor repo 划分了主要模块，设计了 Store 状态存储，设计了一套 API 注入方式可以注入系统外的 API 等等。\n\n这套架构沿用了三年，核心代码基本没有发生变化，功能上却新增了共享屏幕、共享网页、聊天/表情、标注/白板、远程控制、字幕/录制/翻译、日程会议、面试等若干重要的模块。\n\n虽然实际上，随着后面的同学的增多，以及最初核心开发者的离职，开发人员已经几乎换了一批，但是这套代码和架构基本上没发生太多变化，也一直支撑着若干项目。\n\n（p.s. 据说最开始参与设计的同学吐槽后面的维护有点渐渐跑题，但是整体还是可用性比较高的）。\n\n如果没有一定水平，想必业务框架早就随着业务的变更重构过多次了，肯定会带来巨大的人力浪费。\n\n## 5. 持续练习，持续关注行业动态\n\n最后一点，持续学习，大概是程序员的宿命吧。\n\n这里其实不用多说了，但是想提一点，其实有的时候如果你发现主动的持续学习会比较难的情况下，可以选择一种半被动的方式。\n\n比如，每周给自己定日程参与 leetcode 周赛，你把它当作自己工作的无可推脱的一部分，这样持续几次，你就会慢慢习惯这个过程。\n\n---\n\n以上共勉。\n\n\n\n","slug":"如何让你的精力更多的用于提高技术深度","published":1,"updated":"2021-12-23T05:50:07.548Z","_id":"ckxijpqt10014d3mr1zaj12qf","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://zhuanlan.zhihu.com/p/395177123\">知乎版本</a></p>\n<p>题目所述，就是我最近很久一段时间都在用来思考的问题。</p>\n<p>先说下个人的背景，目前已经毕业三年，第一年主要做前端开发，大约在两年前，我的主要精力从前端转向了 Rust，而后又开始在公司参与开发 c++。</p>\n<p>在这三年里面，自己持续面临着一个问题，这个问题就是，如何从一个繁忙而重复的工作中，持续提升自己的技术深度。</p>\n<p>因为我发现，当在一个公司久了以后，随着参与的业务增多，问题和 OnCall 也随之增多，另外随着你对业务的熟悉，会有越来越多的新同学向你问问题。处理这些问题会占据越来越多的精力。当然，如果你比较“幸运”中途业务黄掉或架构彻底变化了，你去参与新的项目，有可能能获得一次接近重新开始的机会，但大多数时候，你可能都没有这么幸运。</p>\n<p>当这些问题处理的久了以后，你会发现甚至连完成工作都需要加班来解决，就更没有时间来进行技术的提升了，长此以往，焦虑感便倍增。</p>\n<p>不过，最近我在思考这些问题的过程中，也渐渐总结了一些缓解的办法，接下来便和大家进行分享。</p>\n<p><strong>这里的核心点在于，减少犯错误的机会，提高处理问题的效率，释放出自己的更多时间</strong></p>\n<h2 id=\"1-提高对代码的要求，写更好的代码\"><a href=\"#1-提高对代码的要求，写更好的代码\" class=\"headerlink\" title=\"1. 提高对代码的要求，写更好的代码\"></a>1. 提高对代码的要求，写更好的代码</h2><p>我最近处理的众多问题，粗略估算，有大约 1/3 都是由于开发者代码水平不足带来的技术债务（即代码逻辑错误、边界情况未考虑、性能与稳定性不足等）。</p>\n<p>我这里主要针对的是 PC 客户端，还有很多问题和特殊机器、其他模块干扰项、硬件驱动等关系密切，如果是纯前端项目，这个比例只会更高。</p>\n<p>因为写代码的时候，并没有采用最合理的方式，导致有出现问题的隐患，如果你的问题出现的概率比较高，大概率会比较幸运地较早发现，但如果出现的概率低，甚至灰度阶段都没有暴露，那么当初几行代码的问题，会让自己之后花加倍的时间来去处理，甚至还可能面临更多后果。</p>\n<p>那么，如何让自己写出更好的代码呢，我认为可以做到以下几点：</p>\n<ul>\n<li><strong>请熟读文档</strong>，比如如果是在开发 Vue 项目，那么请至少把 Vue 的文档看一遍，React 同理，这样你会更加清楚，框架到底提供了那些能力，什么时候使用更合适的 API 来完成一个目标。</li>\n<li>注重注释，对于一些特殊处理的情况，注释是很有必要的，最好附上文档，否则可能时间久了，自己都不知道为什么这样去处理，会让修复问题花费更多的时间。</li>\n<li>除非迫不得已，不要提交带有已知优化项的代码，例如重复代码并没有完全处理、代码在某些情况还可能造成问题。时间允许的情况下，一步到位，通常比分两次到位能节约更多的时间，至少能节约一次测试的时间，另外大脑的上下文切换还有开销。</li>\n<li>CI/CD 的建设，保证合并的代码是能够编译的。</li>\n<li>对于前端来说，全部采用 Typescript，使用 ESLint 约束代码，<strong>禁止</strong>直接使用 JavaScript。</li>\n<li>团队需要建立 Review 机制，并且对 Review 过程负责。对于别人提交 Review 的代码至少需要通读一遍，避免基本的错误。</li>\n</ul>\n<h2 id=\"2-日志是语言的另一面，也很能体现代码水平\"><a href=\"#2-日志是语言的另一面，也很能体现代码水平\" class=\"headerlink\" title=\"2. 日志是语言的另一面，也很能体现代码水平\"></a>2. 日志是语言的另一面，也很能体现代码水平</h2><p>这里的日志，指的是在用户使用过程中，实时上传的的或者离线的日志。</p>\n<p>这里单独提一点日志，是因为在实际中，我们大约有一半时间在写代码，而另外一半时间在查问题，那么为什么就不能好好写日志呢？</p>\n<p>“日志不足/没打日志，需要加日志进一步定位”。</p>\n<p>不知道你在 OnCall 的过程中，是否遇到过此类回复，当然并不能说每次这样的问题都是开发者水平不足导致日志不全，但的确有很多情况是我们可以提前规避的。</p>\n<p>那么一个好的日志应该是什么样的呢？</p>\n<ol>\n<li>前提：废话不要多，能简写就简写，这是因为一般日志都是存在用户本地的，日志量比较大的情况下会影响用户的硬盘占用，当然日志本身的打印也是消耗 CPU 的。</li>\n<li>关键路径的日志要有，可能出问题的地方不要存在侥幸心理，把日志打全，特别是<strong>不同负责模块之间衔接的日志，一定打全</strong>，这样之后甩锅的时候有实锤也会方便一点。</li>\n<li>关键日志需要有关键字，方便后面自动化分析，毕竟，对于一个比较完善的项目而言，机器人分析日志甚至比人分析更为靠谱。</li>\n<li>日志也需要<strong>向前兼容</strong>，最好不要对以前的日志进行改动，这点我们可能通常会忽略，如果没有必要，建议不要对日志进行大的变动，防止自动化工具和其他分析日志的同学不知情。</li>\n</ol>\n<p>什么？你说你们团队还没有日志系统？</p>\n<p>那么第一件事，就是要有一个完善的离线日志回捞系统或在线日志系统。</p>\n<h2 id=\"3-打破边界有助于开阔视野，但是是否深入需要慎重决定\"><a href=\"#3-打破边界有助于开阔视野，但是是否深入需要慎重决定\" class=\"headerlink\" title=\"3. 打破边界有助于开阔视野，但是是否深入需要慎重决定\"></a>3. 打破边界有助于开阔视野，但是是否深入需要慎重决定</h2><p>虽然有的时候，员工打破边界对于公司来书并不是一个好事情，但大多数情况来说，对个人还是会有所帮助的。</p>\n<blockquote>\n<p>为什么说不是一个好事情呢，比如一个客户端的同学，去做 c++ 了，这个时候应该鼓励还是反对呢。实际上这个时候，他除了仅存的业务熟悉度和一些通用的编程能力，c++ 的能力也许就只有应届生的水平，如果从新招聘可能连初试都过不了。公司就必须要承担因为他的编程能力不熟练带来的效率损失，甚至因为更容易引发问题造成更大的损失。</p>\n</blockquote>\n<p>为什么说，对于个人来说是一个好事情呢，这个主要体现在以下几个方面：</p>\n<ul>\n<li>在公司中大多数情况下都是多个语言的开发者相互配合的，而当你同时参与了你上游或者下游的工作，你会发现沟通会更加顺畅了，甚至自己也拥有了简单的处理需求和问题的能力，底气会高很多。</li>\n<li>在你学习多个语言的过程中你会发现一些精华的部分，比如通用的框架设计方法、模块组织方法等各个语言都是通用的，甚至有些代码你直接翻译过来就可以直接用了，这也可以让你更深刻地了解到哪些是编程的精髓。</li>\n</ul>\n<p>当然，有的时候如果你跨界参与的太多，例如本身是一个资深的前端开发者，当你跨界参与了 c++ 开发，你会发现短时间内你的前端水平是在下降的，而 c++ 水平也没有达到独立承担工作的程度，这短时间内你的市场价值其实是有所下降的，这也是你需要慎重考虑到底要参与多少的原因之一。</p>\n<h2 id=\"4-复杂系统的初始架构设计，可以作为一个最后兜底\"><a href=\"#4-复杂系统的初始架构设计，可以作为一个最后兜底\" class=\"headerlink\" title=\"4. 复杂系统的初始架构设计，可以作为一个最后兜底\"></a>4. 复杂系统的初始架构设计，可以作为一个最后兜底</h2><p>实际上，复杂的系统大多一开始都不复杂，但是如何正确地预判系统的走向，设计出可以沿用很久的基础骨架、约束性强却扩展型足够的组件系统（即使后来来的人水平差也不至于写出太难维护的代码），以及和外界其他系统进行灵活的配合，是对水平有一定的考验的。</p>\n<p>这里我以某视频会议 App 举例，其最开始只有视频+音频的简单能力，在此基础上，团队负责人设计并编写了基于 Typescript 的核心状态机、按照 minor repo 划分了主要模块，设计了 Store 状态存储，设计了一套 API 注入方式可以注入系统外的 API 等等。</p>\n<p>这套架构沿用了三年，核心代码基本没有发生变化，功能上却新增了共享屏幕、共享网页、聊天/表情、标注/白板、远程控制、字幕/录制/翻译、日程会议、面试等若干重要的模块。</p>\n<p>虽然实际上，随着后面的同学的增多，以及最初核心开发者的离职，开发人员已经几乎换了一批，但是这套代码和架构基本上没发生太多变化，也一直支撑着若干项目。</p>\n<p>（p.s. 据说最开始参与设计的同学吐槽后面的维护有点渐渐跑题，但是整体还是可用性比较高的）。</p>\n<p>如果没有一定水平，想必业务框架早就随着业务的变更重构过多次了，肯定会带来巨大的人力浪费。</p>\n<h2 id=\"5-持续练习，持续关注行业动态\"><a href=\"#5-持续练习，持续关注行业动态\" class=\"headerlink\" title=\"5. 持续练习，持续关注行业动态\"></a>5. 持续练习，持续关注行业动态</h2><p>最后一点，持续学习，大概是程序员的宿命吧。</p>\n<p>这里其实不用多说了，但是想提一点，其实有的时候如果你发现主动的持续学习会比较难的情况下，可以选择一种半被动的方式。</p>\n<p>比如，每周给自己定日程参与 leetcode 周赛，你把它当作自己工作的无可推脱的一部分，这样持续几次，你就会慢慢习惯这个过程。</p>\n<hr>\n<p>以上共勉。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://zhuanlan.zhihu.com/p/395177123\">知乎版本</a></p>\n<p>题目所述，就是我最近很久一段时间都在用来思考的问题。</p>\n<p>先说下个人的背景，目前已经毕业三年，第一年主要做前端开发，大约在两年前，我的主要精力从前端转向了 Rust，而后又开始在公司参与开发 c++。</p>\n<p>在这三年里面，自己持续面临着一个问题，这个问题就是，如何从一个繁忙而重复的工作中，持续提升自己的技术深度。</p>\n<p>因为我发现，当在一个公司久了以后，随着参与的业务增多，问题和 OnCall 也随之增多，另外随着你对业务的熟悉，会有越来越多的新同学向你问问题。处理这些问题会占据越来越多的精力。当然，如果你比较“幸运”中途业务黄掉或架构彻底变化了，你去参与新的项目，有可能能获得一次接近重新开始的机会，但大多数时候，你可能都没有这么幸运。</p>\n<p>当这些问题处理的久了以后，你会发现甚至连完成工作都需要加班来解决，就更没有时间来进行技术的提升了，长此以往，焦虑感便倍增。</p>\n<p>不过，最近我在思考这些问题的过程中，也渐渐总结了一些缓解的办法，接下来便和大家进行分享。</p>\n<p><strong>这里的核心点在于，减少犯错误的机会，提高处理问题的效率，释放出自己的更多时间</strong></p>\n<h2 id=\"1-提高对代码的要求，写更好的代码\"><a href=\"#1-提高对代码的要求，写更好的代码\" class=\"headerlink\" title=\"1. 提高对代码的要求，写更好的代码\"></a>1. 提高对代码的要求，写更好的代码</h2><p>我最近处理的众多问题，粗略估算，有大约 1/3 都是由于开发者代码水平不足带来的技术债务（即代码逻辑错误、边界情况未考虑、性能与稳定性不足等）。</p>\n<p>我这里主要针对的是 PC 客户端，还有很多问题和特殊机器、其他模块干扰项、硬件驱动等关系密切，如果是纯前端项目，这个比例只会更高。</p>\n<p>因为写代码的时候，并没有采用最合理的方式，导致有出现问题的隐患，如果你的问题出现的概率比较高，大概率会比较幸运地较早发现，但如果出现的概率低，甚至灰度阶段都没有暴露，那么当初几行代码的问题，会让自己之后花加倍的时间来去处理，甚至还可能面临更多后果。</p>\n<p>那么，如何让自己写出更好的代码呢，我认为可以做到以下几点：</p>\n<ul>\n<li><strong>请熟读文档</strong>，比如如果是在开发 Vue 项目，那么请至少把 Vue 的文档看一遍，React 同理，这样你会更加清楚，框架到底提供了那些能力，什么时候使用更合适的 API 来完成一个目标。</li>\n<li>注重注释，对于一些特殊处理的情况，注释是很有必要的，最好附上文档，否则可能时间久了，自己都不知道为什么这样去处理，会让修复问题花费更多的时间。</li>\n<li>除非迫不得已，不要提交带有已知优化项的代码，例如重复代码并没有完全处理、代码在某些情况还可能造成问题。时间允许的情况下，一步到位，通常比分两次到位能节约更多的时间，至少能节约一次测试的时间，另外大脑的上下文切换还有开销。</li>\n<li>CI/CD 的建设，保证合并的代码是能够编译的。</li>\n<li>对于前端来说，全部采用 Typescript，使用 ESLint 约束代码，<strong>禁止</strong>直接使用 JavaScript。</li>\n<li>团队需要建立 Review 机制，并且对 Review 过程负责。对于别人提交 Review 的代码至少需要通读一遍，避免基本的错误。</li>\n</ul>\n<h2 id=\"2-日志是语言的另一面，也很能体现代码水平\"><a href=\"#2-日志是语言的另一面，也很能体现代码水平\" class=\"headerlink\" title=\"2. 日志是语言的另一面，也很能体现代码水平\"></a>2. 日志是语言的另一面，也很能体现代码水平</h2><p>这里的日志，指的是在用户使用过程中，实时上传的的或者离线的日志。</p>\n<p>这里单独提一点日志，是因为在实际中，我们大约有一半时间在写代码，而另外一半时间在查问题，那么为什么就不能好好写日志呢？</p>\n<p>“日志不足/没打日志，需要加日志进一步定位”。</p>\n<p>不知道你在 OnCall 的过程中，是否遇到过此类回复，当然并不能说每次这样的问题都是开发者水平不足导致日志不全，但的确有很多情况是我们可以提前规避的。</p>\n<p>那么一个好的日志应该是什么样的呢？</p>\n<ol>\n<li>前提：废话不要多，能简写就简写，这是因为一般日志都是存在用户本地的，日志量比较大的情况下会影响用户的硬盘占用，当然日志本身的打印也是消耗 CPU 的。</li>\n<li>关键路径的日志要有，可能出问题的地方不要存在侥幸心理，把日志打全，特别是<strong>不同负责模块之间衔接的日志，一定打全</strong>，这样之后甩锅的时候有实锤也会方便一点。</li>\n<li>关键日志需要有关键字，方便后面自动化分析，毕竟，对于一个比较完善的项目而言，机器人分析日志甚至比人分析更为靠谱。</li>\n<li>日志也需要<strong>向前兼容</strong>，最好不要对以前的日志进行改动，这点我们可能通常会忽略，如果没有必要，建议不要对日志进行大的变动，防止自动化工具和其他分析日志的同学不知情。</li>\n</ol>\n<p>什么？你说你们团队还没有日志系统？</p>\n<p>那么第一件事，就是要有一个完善的离线日志回捞系统或在线日志系统。</p>\n<h2 id=\"3-打破边界有助于开阔视野，但是是否深入需要慎重决定\"><a href=\"#3-打破边界有助于开阔视野，但是是否深入需要慎重决定\" class=\"headerlink\" title=\"3. 打破边界有助于开阔视野，但是是否深入需要慎重决定\"></a>3. 打破边界有助于开阔视野，但是是否深入需要慎重决定</h2><p>虽然有的时候，员工打破边界对于公司来书并不是一个好事情，但大多数情况来说，对个人还是会有所帮助的。</p>\n<blockquote>\n<p>为什么说不是一个好事情呢，比如一个客户端的同学，去做 c++ 了，这个时候应该鼓励还是反对呢。实际上这个时候，他除了仅存的业务熟悉度和一些通用的编程能力，c++ 的能力也许就只有应届生的水平，如果从新招聘可能连初试都过不了。公司就必须要承担因为他的编程能力不熟练带来的效率损失，甚至因为更容易引发问题造成更大的损失。</p>\n</blockquote>\n<p>为什么说，对于个人来说是一个好事情呢，这个主要体现在以下几个方面：</p>\n<ul>\n<li>在公司中大多数情况下都是多个语言的开发者相互配合的，而当你同时参与了你上游或者下游的工作，你会发现沟通会更加顺畅了，甚至自己也拥有了简单的处理需求和问题的能力，底气会高很多。</li>\n<li>在你学习多个语言的过程中你会发现一些精华的部分，比如通用的框架设计方法、模块组织方法等各个语言都是通用的，甚至有些代码你直接翻译过来就可以直接用了，这也可以让你更深刻地了解到哪些是编程的精髓。</li>\n</ul>\n<p>当然，有的时候如果你跨界参与的太多，例如本身是一个资深的前端开发者，当你跨界参与了 c++ 开发，你会发现短时间内你的前端水平是在下降的，而 c++ 水平也没有达到独立承担工作的程度，这短时间内你的市场价值其实是有所下降的，这也是你需要慎重考虑到底要参与多少的原因之一。</p>\n<h2 id=\"4-复杂系统的初始架构设计，可以作为一个最后兜底\"><a href=\"#4-复杂系统的初始架构设计，可以作为一个最后兜底\" class=\"headerlink\" title=\"4. 复杂系统的初始架构设计，可以作为一个最后兜底\"></a>4. 复杂系统的初始架构设计，可以作为一个最后兜底</h2><p>实际上，复杂的系统大多一开始都不复杂，但是如何正确地预判系统的走向，设计出可以沿用很久的基础骨架、约束性强却扩展型足够的组件系统（即使后来来的人水平差也不至于写出太难维护的代码），以及和外界其他系统进行灵活的配合，是对水平有一定的考验的。</p>\n<p>这里我以某视频会议 App 举例，其最开始只有视频+音频的简单能力，在此基础上，团队负责人设计并编写了基于 Typescript 的核心状态机、按照 minor repo 划分了主要模块，设计了 Store 状态存储，设计了一套 API 注入方式可以注入系统外的 API 等等。</p>\n<p>这套架构沿用了三年，核心代码基本没有发生变化，功能上却新增了共享屏幕、共享网页、聊天/表情、标注/白板、远程控制、字幕/录制/翻译、日程会议、面试等若干重要的模块。</p>\n<p>虽然实际上，随着后面的同学的增多，以及最初核心开发者的离职，开发人员已经几乎换了一批，但是这套代码和架构基本上没发生太多变化，也一直支撑着若干项目。</p>\n<p>（p.s. 据说最开始参与设计的同学吐槽后面的维护有点渐渐跑题，但是整体还是可用性比较高的）。</p>\n<p>如果没有一定水平，想必业务框架早就随着业务的变更重构过多次了，肯定会带来巨大的人力浪费。</p>\n<h2 id=\"5-持续练习，持续关注行业动态\"><a href=\"#5-持续练习，持续关注行业动态\" class=\"headerlink\" title=\"5. 持续练习，持续关注行业动态\"></a>5. 持续练习，持续关注行业动态</h2><p>最后一点，持续学习，大概是程序员的宿命吧。</p>\n<p>这里其实不用多说了，但是想提一点，其实有的时候如果你发现主动的持续学习会比较难的情况下，可以选择一种半被动的方式。</p>\n<p>比如，每周给自己定日程参与 leetcode 周赛，你把它当作自己工作的无可推脱的一部分，这样持续几次，你就会慢慢习惯这个过程。</p>\n<hr>\n<p>以上共勉。</p>\n"},{"title":"构建利用Proxy和Reflect实现双向数据绑定的微框架","abbrlink":21881498,"date":"2018-04-09T06:40:44.000Z","_content":">写在前面：这篇文章讲述了如何利用Proxy和Reflect实现双向数据绑定，个人系Vue早期玩家，写这个小框架的时候也没有参考Vue等源代码，之前了解过其他实现，但没有直接参考其他代码，如有雷同，纯属巧合。\n\n代码下载地址：[这里下载](https://github.com/aircloud/Polar.js)\n\n### 综述\n\n*关于Proxy和Reflect的资料推荐阮老师的教程:http://es6.ruanyifeng.com/ 这里不做过多介绍。*\n\n实现双向数据绑定的方法有很多，也可以参考本专栏之前的其他实现，我之所以选择用Proxy和Reflect，一方面是因为可以大量节约代码，并且简化逻辑，可以让我把更多的经历放在其他内容的构建上面，另外一方面本项目直接基于ES6，用这些内容也符合面向未来的JS编程规范，第三点最后说。\n\n由于这个小框架是自己在PolarBear这个咖啡馆在一个安静的午后开始写成，暂且起名Polar，日后希望我能继续完善这个小框架，给添加上更多有趣的功能。\n\n首先我们可以看整体功能演示：  \n[一个gif动图，如果不能看，请点击[这里的链接](https://www.10000h.top/images/data_img/gif1.gif)]\n\n![](https://www.10000h.top/images/data_img/gif1.gif)\n\n### 代码分析\n\n我们要做这样一个小框架，核心是要监听数据的改变，并且在数据的改变的时候进行一些操作，从而维持数据的一致。\n\n我的思路是这样的：\n\n* 将所有的数据信息放在一个属性对象中(this._data),之后给这个属性对象用Proxy包装set,在代理函数中我们更新属性对象的具体内容，同时通知所有监听者，之后返回新的代理对象(this.data)，我们之后操作的都是新的代理对象。\n* 对于input等表单，我们需要监听input事件，在回调函数中直接设置我们代理好的数据对象，从而触发我们的代理函数。\n* 我们同时也应该支持事件机制，这里我们以最常用的click方法作为例子实现。\n\n下面开始第一部分，我们希望我们之后使用这个库的时候可以这样调用:\n\n```\n<div id=\"app\">\n    <form>\n        <label>name:</label>\n        <input p-model = \"name\" />\n    </form>\n    <div>name:{{name}} age:{{age}}</div>\n    <i>note:{{note}}</i><br/>\n    <button p-click=\"test(2)\">button1</button>\n</div>\n<script>\n var myPolar = new Polar({\n        el:\"#app\",\n        data: {\n            name: \"niexiaotao\",\n            age:16,\n            note:\"Student of Zhejiang University\"\n        },\n        methods:{\n            test:function(e,addNumber){\n                console.log(\"e:\",e);\n                this.data.age+=Number(addNumber);\n            }\n        }\n});\n</script>\n```\n\n没错，和Vue神似吧，所以这种调用方式应当为我们所熟悉。\n\n我们需要建立一个Polar类，这个类的构造函数应该进行一些初始化操作:\n\n```\n constructor(configs){\n        this.root = this.el = document.querySelector(configs.el);\n        this._data = configs.data;\n        this._data.__bindings = {};\n        //创建代理对象\n        this.data = new Proxy(this._data, {set});\n        this.methods = configs.methods;\n\n        this._compile(this.root);\n}\n```\n\n这里面的一部份内容是直接将我们传入的configs按照属性分别赋值，另外就是我们创建代理对象的过程，最后的`_compile`方法可以理解为一个私有的初始化方法。\n\n实际上我把剩下的内容几乎都放在`_compile`方法里面了，这样理解起来方便，但是之后可能要改动。\n\n我们还是先不能看我们代理的set该怎么写，因为这个时候我们还要先继续梳理思路：\n\n假设我们这样`<div>name:{{name}}</div>`将数据绑定到dom节点，这个时候我们需要做什么呢，或者说，我们通过什么方式让dom节点和数据对应起来，随着数据改变而改变。\n\n看上文的`__bindings`。这个对象用来存储所有绑定的dom节点信息，`__bindings`本身是一个对象，每一个有对应dom节点绑定的数据名称都是它的属性，对应一个数组，数组中的每一个内容都是一个绑定信息，这样，我们在自己写的set代理函数中，我们一个个调用过去，就可以更新内容了：\n\n```\ndataSet.__bindings[key].forEach(function(item){\n       //do something to update...\n});\n```\n\n我这里创建了一个用于构造调用的函数，这个函数用于创建存储绑定信息的对象：\n\n```\nfunction Directive(el,polar,attr,elementValue){\n    this.el=el;//元素本身dom节点\n    this.polar = polar;//对应的polar实例\n    this.attr = attr;//元素的被绑定的属性值，比如如果是文本节点就可以是nodeValue\n    this.el[this.attr] = this.elementValue = elementValue;//初始化\n}\n```\n\n这样，我们的set可以这样写:\n\n```\nfunction set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver);\n    var dataSet = receiver || target;\n    dataSet.__bindings[key].forEach(function(item){\n        item.el[item.attr] = item.elementValue = value;\n    });\n    return result;\n}\n```\n\n接下来可能还有一个问题：我们的`{{name}}`实际上只是节点的一部分，这并不是节点啊，另外我们是不是还可以这么写：`<div>name:{{name}} age:{{age}}</div>`？\n\n关于这两个问题，前者的答案是我们将`{{name}}`替换成一个文本节点，而为了应对后者的情况，我们需要将两个被绑定数据中间和前后的内容，都变成新的文本节点，然后这些文本节点组成文本节点串。(这里多说一句，html5的normalize方法可以将多个文本节点合并成一个，如果不小心调用了它，那我们的程序就要GG了)\n\n所以我们在`_compile`函数首先：\n\n```\nvar _this = this;\n\n        var nodes = root.children;\n\n        var bindDataTester = new RegExp(\"{{(.*?)}}\",\"ig\");\n\n        for(let i=0;i<nodes.length;i++){\n            var node=nodes[i];\n\n            //如果还有html字节点，则递归\n            if(node.children.length){\n                this._compile(node);\n            }\n\n            var matches = node.innerHTML.match(bindDataTester);\n            if(matches){\n                var newMatches = matches.map(function (item) {\n                    return  item.replace(/{{(.*?)}}/,\"$1\")\n                });\n                var splitTextNodes  = node.innerHTML.split(/{{.*?}}/);\n                node.innerHTML=null;\n                //更新DOM，处理同一个textnode里面多次绑定情况\n                if(splitTextNodes[0]){\n                    node.append(document.createTextNode(splitTextNodes[0]));\n                }\n                for(let ii=0;ii<newMatches.length;ii++){\n                    var el = document.createTextNode('');\n                    node.appendChild(el);\n                    if(splitTextNodes[ii+1]){\n                        node.append(document.createTextNode(splitTextNodes[ii+1]));\n                    }\n                //对数据和dom进行绑定\n                let returnCode = !this._data.__bindings[newMatches[ii]]?\n                    this._data.__bindings[newMatches[ii]] = [new Directive(el,this,\"nodeValue\",this.data[newMatches[ii]])]\n                    :this._data.__bindings[newMatches[ii]].push(new Directive(el,this,\"nodeValue\",this.data[newMatches[ii]]))\n                }\n            }\n\n```\n\n这样，我们的数据绑定阶段就写好了，接下来，我们处理`<input p-model = \"name\" />`这样的情况。\n\n这实际上是一个指令，我们只需要当识别到这一个指令的时候，做一些处理，即可：\n\n```\nif(node.hasAttribute((\"p-model\"))\n                && node.tagName.toLocaleUpperCase()==\"INPUT\" || node.tagName.toLocaleUpperCase()==\"TEXTAREA\"){\n                node.addEventListener(\"input\", (function () {\n\n                    var attributeValue = node.getAttribute(\"p-model\");\n\n                    if(_this._data.__bindings[attributeValue]) _this._data.__bindings[attributeValue].push(new Directive(node,_this,\"value\",_this.data[attributeValue])) ;\n                    else _this._data.__bindings[attributeValue] = [new Directive(node,_this,\"value\",_this.data[attributeValue])];\n\n                    return function (event) {\n                        _this.data[attributeValue]=event.target.value\n                    }\n                })());\n}\n```\n\n请注意，上面调用了一个`IIFE`，实际绑定的函数只有返回的函数那一小部分。\n\n最后我们处理事件的情况：`<button p-click=\"test(2)\">button1</button>`\n\n实际上这比处理`p-model`还简单，但是我们为了支持函数参数的情况，处理了一下传入参数，另外我实际上将`event`始终作为一个参数传递，这也许并不是好的实践，因为使用的时候还要多注意。\n\n```\nif(node.hasAttribute(\"p-click\")) {\n                node.addEventListener(\"click\",function(){\n                    var attributeValue=node.getAttribute(\"p-click\");\n                    var args=/\\(.*\\)/.exec(attributeValue);\n                    //允许参数\n                    if(args) {\n                        args=args[0];\n                        attributeValue=attributeValue.replace(args,\"\");\n                        args=args.replace(/[\\(\\)\\'\\\"]/g,'').split(\",\");\n                    }\n                    else args=[];\n                    return function (event) {\n                        _this.methods[attributeValue].apply(_this,[event,...args]);\n                    }\n                }());\n}\n```\n\n现在我们已经将所有的代码分析完了，是不是很清爽？代码除去注释约100行，所有源代码可以在[这里下载](https://github.com/aircloud/Polar.js)。这当然不能算作一个框架了，不过可以学习学习，这学期有时间的话，还要继续完善，也欢迎大家一起探讨。\n\n一起学习，一起提高，做技术应当是直接的，有问题欢迎指出～\n\n---\n\n\n最后说的第三点：是自己还是一个学生，做这些内容也仅仅是出于兴趣，因为找暑期实习比较艰难，在等待鹅厂面试间隙写的这个程序，压压惊(然而并没有消息)。","source":"_posts/构建利用Proxy和Reflect实现双向数据绑定的微框架.md","raw":"---\ntitle: 构建利用Proxy和Reflect实现双向数据绑定的微框架\ntags:\n  - MVVM\nabbrlink: 21881498\ndate: 2018-04-09 14:40:44\n---\n>写在前面：这篇文章讲述了如何利用Proxy和Reflect实现双向数据绑定，个人系Vue早期玩家，写这个小框架的时候也没有参考Vue等源代码，之前了解过其他实现，但没有直接参考其他代码，如有雷同，纯属巧合。\n\n代码下载地址：[这里下载](https://github.com/aircloud/Polar.js)\n\n### 综述\n\n*关于Proxy和Reflect的资料推荐阮老师的教程:http://es6.ruanyifeng.com/ 这里不做过多介绍。*\n\n实现双向数据绑定的方法有很多，也可以参考本专栏之前的其他实现，我之所以选择用Proxy和Reflect，一方面是因为可以大量节约代码，并且简化逻辑，可以让我把更多的经历放在其他内容的构建上面，另外一方面本项目直接基于ES6，用这些内容也符合面向未来的JS编程规范，第三点最后说。\n\n由于这个小框架是自己在PolarBear这个咖啡馆在一个安静的午后开始写成，暂且起名Polar，日后希望我能继续完善这个小框架，给添加上更多有趣的功能。\n\n首先我们可以看整体功能演示：  \n[一个gif动图，如果不能看，请点击[这里的链接](https://www.10000h.top/images/data_img/gif1.gif)]\n\n![](https://www.10000h.top/images/data_img/gif1.gif)\n\n### 代码分析\n\n我们要做这样一个小框架，核心是要监听数据的改变，并且在数据的改变的时候进行一些操作，从而维持数据的一致。\n\n我的思路是这样的：\n\n* 将所有的数据信息放在一个属性对象中(this._data),之后给这个属性对象用Proxy包装set,在代理函数中我们更新属性对象的具体内容，同时通知所有监听者，之后返回新的代理对象(this.data)，我们之后操作的都是新的代理对象。\n* 对于input等表单，我们需要监听input事件，在回调函数中直接设置我们代理好的数据对象，从而触发我们的代理函数。\n* 我们同时也应该支持事件机制，这里我们以最常用的click方法作为例子实现。\n\n下面开始第一部分，我们希望我们之后使用这个库的时候可以这样调用:\n\n```\n<div id=\"app\">\n    <form>\n        <label>name:</label>\n        <input p-model = \"name\" />\n    </form>\n    <div>name:{{name}} age:{{age}}</div>\n    <i>note:{{note}}</i><br/>\n    <button p-click=\"test(2)\">button1</button>\n</div>\n<script>\n var myPolar = new Polar({\n        el:\"#app\",\n        data: {\n            name: \"niexiaotao\",\n            age:16,\n            note:\"Student of Zhejiang University\"\n        },\n        methods:{\n            test:function(e,addNumber){\n                console.log(\"e:\",e);\n                this.data.age+=Number(addNumber);\n            }\n        }\n});\n</script>\n```\n\n没错，和Vue神似吧，所以这种调用方式应当为我们所熟悉。\n\n我们需要建立一个Polar类，这个类的构造函数应该进行一些初始化操作:\n\n```\n constructor(configs){\n        this.root = this.el = document.querySelector(configs.el);\n        this._data = configs.data;\n        this._data.__bindings = {};\n        //创建代理对象\n        this.data = new Proxy(this._data, {set});\n        this.methods = configs.methods;\n\n        this._compile(this.root);\n}\n```\n\n这里面的一部份内容是直接将我们传入的configs按照属性分别赋值，另外就是我们创建代理对象的过程，最后的`_compile`方法可以理解为一个私有的初始化方法。\n\n实际上我把剩下的内容几乎都放在`_compile`方法里面了，这样理解起来方便，但是之后可能要改动。\n\n我们还是先不能看我们代理的set该怎么写，因为这个时候我们还要先继续梳理思路：\n\n假设我们这样`<div>name:{{name}}</div>`将数据绑定到dom节点，这个时候我们需要做什么呢，或者说，我们通过什么方式让dom节点和数据对应起来，随着数据改变而改变。\n\n看上文的`__bindings`。这个对象用来存储所有绑定的dom节点信息，`__bindings`本身是一个对象，每一个有对应dom节点绑定的数据名称都是它的属性，对应一个数组，数组中的每一个内容都是一个绑定信息，这样，我们在自己写的set代理函数中，我们一个个调用过去，就可以更新内容了：\n\n```\ndataSet.__bindings[key].forEach(function(item){\n       //do something to update...\n});\n```\n\n我这里创建了一个用于构造调用的函数，这个函数用于创建存储绑定信息的对象：\n\n```\nfunction Directive(el,polar,attr,elementValue){\n    this.el=el;//元素本身dom节点\n    this.polar = polar;//对应的polar实例\n    this.attr = attr;//元素的被绑定的属性值，比如如果是文本节点就可以是nodeValue\n    this.el[this.attr] = this.elementValue = elementValue;//初始化\n}\n```\n\n这样，我们的set可以这样写:\n\n```\nfunction set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver);\n    var dataSet = receiver || target;\n    dataSet.__bindings[key].forEach(function(item){\n        item.el[item.attr] = item.elementValue = value;\n    });\n    return result;\n}\n```\n\n接下来可能还有一个问题：我们的`{{name}}`实际上只是节点的一部分，这并不是节点啊，另外我们是不是还可以这么写：`<div>name:{{name}} age:{{age}}</div>`？\n\n关于这两个问题，前者的答案是我们将`{{name}}`替换成一个文本节点，而为了应对后者的情况，我们需要将两个被绑定数据中间和前后的内容，都变成新的文本节点，然后这些文本节点组成文本节点串。(这里多说一句，html5的normalize方法可以将多个文本节点合并成一个，如果不小心调用了它，那我们的程序就要GG了)\n\n所以我们在`_compile`函数首先：\n\n```\nvar _this = this;\n\n        var nodes = root.children;\n\n        var bindDataTester = new RegExp(\"{{(.*?)}}\",\"ig\");\n\n        for(let i=0;i<nodes.length;i++){\n            var node=nodes[i];\n\n            //如果还有html字节点，则递归\n            if(node.children.length){\n                this._compile(node);\n            }\n\n            var matches = node.innerHTML.match(bindDataTester);\n            if(matches){\n                var newMatches = matches.map(function (item) {\n                    return  item.replace(/{{(.*?)}}/,\"$1\")\n                });\n                var splitTextNodes  = node.innerHTML.split(/{{.*?}}/);\n                node.innerHTML=null;\n                //更新DOM，处理同一个textnode里面多次绑定情况\n                if(splitTextNodes[0]){\n                    node.append(document.createTextNode(splitTextNodes[0]));\n                }\n                for(let ii=0;ii<newMatches.length;ii++){\n                    var el = document.createTextNode('');\n                    node.appendChild(el);\n                    if(splitTextNodes[ii+1]){\n                        node.append(document.createTextNode(splitTextNodes[ii+1]));\n                    }\n                //对数据和dom进行绑定\n                let returnCode = !this._data.__bindings[newMatches[ii]]?\n                    this._data.__bindings[newMatches[ii]] = [new Directive(el,this,\"nodeValue\",this.data[newMatches[ii]])]\n                    :this._data.__bindings[newMatches[ii]].push(new Directive(el,this,\"nodeValue\",this.data[newMatches[ii]]))\n                }\n            }\n\n```\n\n这样，我们的数据绑定阶段就写好了，接下来，我们处理`<input p-model = \"name\" />`这样的情况。\n\n这实际上是一个指令，我们只需要当识别到这一个指令的时候，做一些处理，即可：\n\n```\nif(node.hasAttribute((\"p-model\"))\n                && node.tagName.toLocaleUpperCase()==\"INPUT\" || node.tagName.toLocaleUpperCase()==\"TEXTAREA\"){\n                node.addEventListener(\"input\", (function () {\n\n                    var attributeValue = node.getAttribute(\"p-model\");\n\n                    if(_this._data.__bindings[attributeValue]) _this._data.__bindings[attributeValue].push(new Directive(node,_this,\"value\",_this.data[attributeValue])) ;\n                    else _this._data.__bindings[attributeValue] = [new Directive(node,_this,\"value\",_this.data[attributeValue])];\n\n                    return function (event) {\n                        _this.data[attributeValue]=event.target.value\n                    }\n                })());\n}\n```\n\n请注意，上面调用了一个`IIFE`，实际绑定的函数只有返回的函数那一小部分。\n\n最后我们处理事件的情况：`<button p-click=\"test(2)\">button1</button>`\n\n实际上这比处理`p-model`还简单，但是我们为了支持函数参数的情况，处理了一下传入参数，另外我实际上将`event`始终作为一个参数传递，这也许并不是好的实践，因为使用的时候还要多注意。\n\n```\nif(node.hasAttribute(\"p-click\")) {\n                node.addEventListener(\"click\",function(){\n                    var attributeValue=node.getAttribute(\"p-click\");\n                    var args=/\\(.*\\)/.exec(attributeValue);\n                    //允许参数\n                    if(args) {\n                        args=args[0];\n                        attributeValue=attributeValue.replace(args,\"\");\n                        args=args.replace(/[\\(\\)\\'\\\"]/g,'').split(\",\");\n                    }\n                    else args=[];\n                    return function (event) {\n                        _this.methods[attributeValue].apply(_this,[event,...args]);\n                    }\n                }());\n}\n```\n\n现在我们已经将所有的代码分析完了，是不是很清爽？代码除去注释约100行，所有源代码可以在[这里下载](https://github.com/aircloud/Polar.js)。这当然不能算作一个框架了，不过可以学习学习，这学期有时间的话，还要继续完善，也欢迎大家一起探讨。\n\n一起学习，一起提高，做技术应当是直接的，有问题欢迎指出～\n\n---\n\n\n最后说的第三点：是自己还是一个学生，做这些内容也仅仅是出于兴趣，因为找暑期实习比较艰难，在等待鹅厂面试间隙写的这个程序，压压惊(然而并没有消息)。","slug":"构建利用Proxy和Reflect实现双向数据绑定的微框架","published":1,"updated":"2021-12-23T05:50:07.549Z","_id":"ckxijpqt20017d3mr274bheky","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>写在前面：这篇文章讲述了如何利用Proxy和Reflect实现双向数据绑定，个人系Vue早期玩家，写这个小框架的时候也没有参考Vue等源代码，之前了解过其他实现，但没有直接参考其他代码，如有雷同，纯属巧合。</p>\n</blockquote>\n<p>代码下载地址：<a href=\"https://github.com/aircloud/Polar.js\">这里下载</a></p>\n<h3 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h3><p><em>关于Proxy和Reflect的资料推荐阮老师的教程:<a href=\"http://es6.ruanyifeng.com/\">http://es6.ruanyifeng.com/</a> 这里不做过多介绍。</em></p>\n<p>实现双向数据绑定的方法有很多，也可以参考本专栏之前的其他实现，我之所以选择用Proxy和Reflect，一方面是因为可以大量节约代码，并且简化逻辑，可以让我把更多的经历放在其他内容的构建上面，另外一方面本项目直接基于ES6，用这些内容也符合面向未来的JS编程规范，第三点最后说。</p>\n<p>由于这个小框架是自己在PolarBear这个咖啡馆在一个安静的午后开始写成，暂且起名Polar，日后希望我能继续完善这个小框架，给添加上更多有趣的功能。</p>\n<p>首先我们可以看整体功能演示：<br>[一个gif动图，如果不能看，请点击<a href=\"https://www.10000h.top/images/data_img/gif1.gif\">这里的链接</a>]</p>\n<p><img src=\"https://www.10000h.top/images/data_img/gif1.gif\"></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>我们要做这样一个小框架，核心是要监听数据的改变，并且在数据的改变的时候进行一些操作，从而维持数据的一致。</p>\n<p>我的思路是这样的：</p>\n<ul>\n<li>将所有的数据信息放在一个属性对象中(this._data),之后给这个属性对象用Proxy包装set,在代理函数中我们更新属性对象的具体内容，同时通知所有监听者，之后返回新的代理对象(this.data)，我们之后操作的都是新的代理对象。</li>\n<li>对于input等表单，我们需要监听input事件，在回调函数中直接设置我们代理好的数据对象，从而触发我们的代理函数。</li>\n<li>我们同时也应该支持事件机制，这里我们以最常用的click方法作为例子实现。</li>\n</ul>\n<p>下面开始第一部分，我们希望我们之后使用这个库的时候可以这样调用:</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>name:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">p-model</span> = <span class=\"string\">&quot;name&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>name:</span><span class=\"template-variable\">&#123;&#123;<span class=\"name\">name</span>&#125;&#125;</span><span class=\"xml\"> age:</span><span class=\"template-variable\">&#123;&#123;<span class=\"name\">age</span>&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">i</span>&gt;</span>note:</span><span class=\"template-variable\">&#123;&#123;<span class=\"name\">note</span>&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">p-click</span>=<span class=\"string\">&quot;test(2)&quot;</span>&gt;</span>button1<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"> <span class=\"keyword\">var</span> myPolar = <span class=\"keyword\">new</span> Polar(&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        <span class=\"attr\">el</span>:<span class=\"string\">&quot;#app&quot;</span>,</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        <span class=\"attr\">data</span>: &#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            <span class=\"attr\">name</span>: <span class=\"string\">&quot;niexiaotao&quot;</span>,</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            <span class=\"attr\">age</span>:<span class=\"number\">16</span>,</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            <span class=\"attr\">note</span>:<span class=\"string\">&quot;Student of Zhejiang University&quot;</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        &#125;,</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        <span class=\"attr\">methods</span>:&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            <span class=\"attr\">test</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e,addNumber</span>)</span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;e:&quot;</span>,e);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">                <span class=\"built_in\">this</span>.data.age+=<span class=\"built_in\">Number</span>(addNumber);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">&#125;);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>没错，和Vue神似吧，所以这种调用方式应当为我们所熟悉。</p>\n<p>我们需要建立一个Polar类，这个类的构造函数应该进行一些初始化操作:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">constructor</span>(configs)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.root = <span class=\"keyword\">this</span>.el = document.querySelector(configs.el);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._data = configs.<span class=\"keyword\">data</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._data.__bindings = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//创建代理对象</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"keyword\">data</span> = new Proxy(<span class=\"keyword\">this</span>._data, &#123;<span class=\"keyword\">set</span>&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.methods = configs.methods;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._compile(<span class=\"keyword\">this</span>.root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面的一部份内容是直接将我们传入的configs按照属性分别赋值，另外就是我们创建代理对象的过程，最后的<code>_compile</code>方法可以理解为一个私有的初始化方法。</p>\n<p>实际上我把剩下的内容几乎都放在<code>_compile</code>方法里面了，这样理解起来方便，但是之后可能要改动。</p>\n<p>我们还是先不能看我们代理的set该怎么写，因为这个时候我们还要先继续梳理思路：</p>\n<p>假设我们这样<code>&lt;div&gt;name:&#123;&#123;name&#125;&#125;&lt;/div&gt;</code>将数据绑定到dom节点，这个时候我们需要做什么呢，或者说，我们通过什么方式让dom节点和数据对应起来，随着数据改变而改变。</p>\n<p>看上文的<code>__bindings</code>。这个对象用来存储所有绑定的dom节点信息，<code>__bindings</code>本身是一个对象，每一个有对应dom节点绑定的数据名称都是它的属性，对应一个数组，数组中的每一个内容都是一个绑定信息，这样，我们在自己写的set代理函数中，我们一个个调用过去，就可以更新内容了：</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataSet.__bindings<span class=\"built_in\">[key</span>].forEach(<span class=\"keyword\">function</span>(<span class=\"type\">item</span>)&#123;</span><br><span class=\"line\">       //do something <span class=\"keyword\">to</span> <span class=\"keyword\">update</span>...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我这里创建了一个用于构造调用的函数，这个函数用于创建存储绑定信息的对象：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Directive(el,polar,attr,elementValue)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.el=el;<span class=\"comment\">//元素本身dom节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.polar = polar;<span class=\"comment\">//对应的polar实例</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.attr = attr;<span class=\"comment\">//元素的被绑定的属性值，比如如果是文本节点就可以是nodeValue</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.el[<span class=\"keyword\">this</span>.attr] = <span class=\"keyword\">this</span>.elementValue = elementValue;<span class=\"comment\">//初始化</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们的set可以这样写:</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> set(target,<span class=\"built_in\"> key</span>, <span class=\"keyword\">value</span>, receiver) &#123;</span><br><span class=\"line\">    const result = Reflect.set(target,<span class=\"built_in\"> key</span>, <span class=\"keyword\">value</span>, receiver);</span><br><span class=\"line\">    var dataSet = receiver || target;</span><br><span class=\"line\">    dataSet.__bindings<span class=\"built_in\">[key</span>].forEach(<span class=\"keyword\">function</span>(<span class=\"type\">item</span>)&#123;</span><br><span class=\"line\">        <span class=\"type\">item</span>.el[<span class=\"type\">item</span>.attr] = <span class=\"type\">item</span>.elementValue = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来可能还有一个问题：我们的<code>&#123;&#123;name&#125;&#125;</code>实际上只是节点的一部分，这并不是节点啊，另外我们是不是还可以这么写：<code>&lt;div&gt;name:&#123;&#123;name&#125;&#125; age:&#123;&#123;age&#125;&#125;&lt;/div&gt;</code>？</p>\n<p>关于这两个问题，前者的答案是我们将<code>&#123;&#123;name&#125;&#125;</code>替换成一个文本节点，而为了应对后者的情况，我们需要将两个被绑定数据中间和前后的内容，都变成新的文本节点，然后这些文本节点组成文本节点串。(这里多说一句，html5的normalize方法可以将多个文本节点合并成一个，如果不小心调用了它，那我们的程序就要GG了)</p>\n<p>所以我们在<code>_compile</code>函数首先：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _this = <span class=\"built_in\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> nodes = root.children;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> bindDataTester = <span class=\"keyword\">new</span> <span class=\"type\">RegExp</span>(<span class=\"string\">&quot;&#123;&#123;(.*?)&#125;&#125;&quot;</span>,<span class=\"string\">&quot;ig&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(let i=<span class=\"number\">0</span>;i&lt;nodes.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> node=nodes[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//如果还有html字节点，则递归</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.children.length)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>._compile(node);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> matches = node.innerHTML.match(bindDataTester);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matches)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Matches</span> = matches.map(<span class=\"function\"><span class=\"keyword\">function</span> </span>(item) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>  item.replace(/&#123;&#123;(.*?)&#125;&#125;/,<span class=\"string\">&quot;$1&quot;</span>)</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> splitTextNodes  = node.innerHTML.split(/&#123;&#123;.*?&#125;&#125;/);</span><br><span class=\"line\">                node.innerHTML=<span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">//更新DOM，处理同一个textnode里面多次绑定情况</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(splitTextNodes[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                    node.append(document.createTextNode(splitTextNodes[<span class=\"number\">0</span>]));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(let ii=<span class=\"number\">0</span>;ii&lt;<span class=\"keyword\">new</span><span class=\"type\">Matches</span>.length;ii++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> el = document.createTextNode(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">                    node.appendChild(el);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(splitTextNodes[ii+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                        node.append(document.createTextNode(splitTextNodes[ii+<span class=\"number\">1</span>]));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                <span class=\"comment\">//对数据和dom进行绑定</span></span><br><span class=\"line\">                let returnCode = !<span class=\"built_in\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]]?</span><br><span class=\"line\">                    <span class=\"built_in\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]] = [<span class=\"keyword\">new</span> <span class=\"type\">Directive</span>(el,<span class=\"built_in\">this</span>,<span class=\"string\">&quot;nodeValue&quot;</span>,<span class=\"built_in\">this</span>.data[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]])]</span><br><span class=\"line\">                    :<span class=\"type\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]].push(<span class=\"keyword\">new</span> <span class=\"type\">Directive</span>(el,<span class=\"built_in\">this</span>,<span class=\"string\">&quot;nodeValue&quot;</span>,<span class=\"built_in\">this</span>.data[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]]))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样，我们的数据绑定阶段就写好了，接下来，我们处理<code>&lt;input p-model = &quot;name&quot; /&gt;</code>这样的情况。</p>\n<p>这实际上是一个指令，我们只需要当识别到这一个指令的时候，做一些处理，即可：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(node.has<span class=\"constructor\">Attribute((<span class=\"string\">&quot;p-model&quot;</span>)</span>)<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">                &amp;&amp; </span>node.tagName.<span class=\"keyword\">to</span><span class=\"constructor\">LocaleUpperCase()</span>==<span class=\"string\">&quot;INPUT&quot;</span><span class=\"operator\"> || </span>node.tagName.<span class=\"keyword\">to</span><span class=\"constructor\">LocaleUpperCase()</span>==<span class=\"string\">&quot;TEXTAREA&quot;</span>)&#123;</span><br><span class=\"line\">                node.add<span class=\"constructor\">EventListener(<span class=\"string\">&quot;input&quot;</span>, (<span class=\"params\">function</span> ()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    var attributeValue = node.get<span class=\"constructor\">Attribute(<span class=\"string\">&quot;p-model&quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_this</span>.</span><span class=\"module\"><span class=\"identifier\">_data</span>.</span><span class=\"module\"><span class=\"identifier\">__bindings</span>[</span></span>attributeValue]) <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_this</span>.</span><span class=\"module\"><span class=\"identifier\">_data</span>.</span><span class=\"module\"><span class=\"identifier\">__bindings</span>[</span></span>attributeValue].push(<span class=\"keyword\">new</span> <span class=\"constructor\">Directive(<span class=\"params\">node</span>,<span class=\"params\">_this</span>,<span class=\"string\">&quot;value&quot;</span>,<span class=\"params\">_this</span>.<span class=\"params\">data</span>[<span class=\"params\">attributeValue</span>])</span>) ;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_this</span>.</span><span class=\"module\"><span class=\"identifier\">_data</span>.</span><span class=\"module\"><span class=\"identifier\">__bindings</span>[</span></span>attributeValue] = <span class=\"literal\">[<span class=\"identifier\">new</span> D<span class=\"identifier\">irective</span>(<span class=\"identifier\">node</span>,<span class=\"identifier\">_this</span>,&quot;<span class=\"identifier\">value</span>&quot;,<span class=\"identifier\">_this</span>.<span class=\"identifier\">data</span>[<span class=\"identifier\">attributeValue</span>]</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">                    return <span class=\"keyword\">function</span> (event) &#123;</span><br><span class=\"line\">                        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_this</span>.</span></span>data<span class=\"literal\">[<span class=\"identifier\">attributeValue</span>]</span>=event.target.value</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)<span class=\"literal\">()</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，上面调用了一个<code>IIFE</code>，实际绑定的函数只有返回的函数那一小部分。</p>\n<p>最后我们处理事件的情况：<code>&lt;button p-click=&quot;test(2)&quot;&gt;button1&lt;/button&gt;</code></p>\n<p>实际上这比处理<code>p-model</code>还简单，但是我们为了支持函数参数的情况，处理了一下传入参数，另外我实际上将<code>event</code>始终作为一个参数传递，这也许并不是好的实践，因为使用的时候还要多注意。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(node.hasAttribute(<span class=\"string\">&quot;p-click&quot;</span>)) &#123;</span><br><span class=\"line\">                node.addEventListener(<span class=\"string\">&quot;click&quot;</span>,function()&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> attributeValue=node.getAttribute(<span class=\"string\">&quot;p-click&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> <span class=\"keyword\">args</span>=/\\(.*\\)/.exec(attributeValue);</span><br><span class=\"line\">                    <span class=\"comment\">//允许参数</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"keyword\">args</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">args</span>=<span class=\"keyword\">args</span>[0];</span><br><span class=\"line\">                        attributeValue=attributeValue.<span class=\"keyword\">replace</span>(<span class=\"keyword\">args</span>,<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">args</span>=<span class=\"keyword\">args</span>.<span class=\"keyword\">replace</span>(/[\\(\\)\\&#x27;\\<span class=\"string\">&quot;]/g,&#x27;&#x27;).split(&quot;</span>,&quot;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">args</span>=[];</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> function (event) &#123;</span><br><span class=\"line\">                        _this.methods[attributeValue].apply(_this,[event,...<span class=\"keyword\">args</span>]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在我们已经将所有的代码分析完了，是不是很清爽？代码除去注释约100行，所有源代码可以在<a href=\"https://github.com/aircloud/Polar.js\">这里下载</a>。这当然不能算作一个框架了，不过可以学习学习，这学期有时间的话，还要继续完善，也欢迎大家一起探讨。</p>\n<p>一起学习，一起提高，做技术应当是直接的，有问题欢迎指出～</p>\n<hr>\n<p>最后说的第三点：是自己还是一个学生，做这些内容也仅仅是出于兴趣，因为找暑期实习比较艰难，在等待鹅厂面试间隙写的这个程序，压压惊(然而并没有消息)。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>写在前面：这篇文章讲述了如何利用Proxy和Reflect实现双向数据绑定，个人系Vue早期玩家，写这个小框架的时候也没有参考Vue等源代码，之前了解过其他实现，但没有直接参考其他代码，如有雷同，纯属巧合。</p>\n</blockquote>\n<p>代码下载地址：<a href=\"https://github.com/aircloud/Polar.js\">这里下载</a></p>\n<h3 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h3><p><em>关于Proxy和Reflect的资料推荐阮老师的教程:<a href=\"http://es6.ruanyifeng.com/\">http://es6.ruanyifeng.com/</a> 这里不做过多介绍。</em></p>\n<p>实现双向数据绑定的方法有很多，也可以参考本专栏之前的其他实现，我之所以选择用Proxy和Reflect，一方面是因为可以大量节约代码，并且简化逻辑，可以让我把更多的经历放在其他内容的构建上面，另外一方面本项目直接基于ES6，用这些内容也符合面向未来的JS编程规范，第三点最后说。</p>\n<p>由于这个小框架是自己在PolarBear这个咖啡馆在一个安静的午后开始写成，暂且起名Polar，日后希望我能继续完善这个小框架，给添加上更多有趣的功能。</p>\n<p>首先我们可以看整体功能演示：<br>[一个gif动图，如果不能看，请点击<a href=\"https://www.10000h.top/images/data_img/gif1.gif\">这里的链接</a>]</p>\n<p><img src=\"https://www.10000h.top/images/data_img/gif1.gif\"></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>我们要做这样一个小框架，核心是要监听数据的改变，并且在数据的改变的时候进行一些操作，从而维持数据的一致。</p>\n<p>我的思路是这样的：</p>\n<ul>\n<li>将所有的数据信息放在一个属性对象中(this._data),之后给这个属性对象用Proxy包装set,在代理函数中我们更新属性对象的具体内容，同时通知所有监听者，之后返回新的代理对象(this.data)，我们之后操作的都是新的代理对象。</li>\n<li>对于input等表单，我们需要监听input事件，在回调函数中直接设置我们代理好的数据对象，从而触发我们的代理函数。</li>\n<li>我们同时也应该支持事件机制，这里我们以最常用的click方法作为例子实现。</li>\n</ul>\n<p>下面开始第一部分，我们希望我们之后使用这个库的时候可以这样调用:</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>name:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">p-model</span> = <span class=\"string\">&quot;name&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>name:</span><span class=\"template-variable\">&#123;&#123;<span class=\"name\">name</span>&#125;&#125;</span><span class=\"xml\"> age:</span><span class=\"template-variable\">&#123;&#123;<span class=\"name\">age</span>&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">i</span>&gt;</span>note:</span><span class=\"template-variable\">&#123;&#123;<span class=\"name\">note</span>&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">p-click</span>=<span class=\"string\">&quot;test(2)&quot;</span>&gt;</span>button1<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"> <span class=\"keyword\">var</span> myPolar = <span class=\"keyword\">new</span> Polar(&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        <span class=\"attr\">el</span>:<span class=\"string\">&quot;#app&quot;</span>,</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        <span class=\"attr\">data</span>: &#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            <span class=\"attr\">name</span>: <span class=\"string\">&quot;niexiaotao&quot;</span>,</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            <span class=\"attr\">age</span>:<span class=\"number\">16</span>,</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            <span class=\"attr\">note</span>:<span class=\"string\">&quot;Student of Zhejiang University&quot;</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        &#125;,</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        <span class=\"attr\">methods</span>:&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            <span class=\"attr\">test</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e,addNumber</span>)</span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;e:&quot;</span>,e);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">                <span class=\"built_in\">this</span>.data.age+=<span class=\"built_in\">Number</span>(addNumber);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">&#125;);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>没错，和Vue神似吧，所以这种调用方式应当为我们所熟悉。</p>\n<p>我们需要建立一个Polar类，这个类的构造函数应该进行一些初始化操作:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">constructor</span>(configs)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.root = <span class=\"keyword\">this</span>.el = document.querySelector(configs.el);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._data = configs.<span class=\"keyword\">data</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._data.__bindings = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//创建代理对象</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"keyword\">data</span> = new Proxy(<span class=\"keyword\">this</span>._data, &#123;<span class=\"keyword\">set</span>&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.methods = configs.methods;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._compile(<span class=\"keyword\">this</span>.root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面的一部份内容是直接将我们传入的configs按照属性分别赋值，另外就是我们创建代理对象的过程，最后的<code>_compile</code>方法可以理解为一个私有的初始化方法。</p>\n<p>实际上我把剩下的内容几乎都放在<code>_compile</code>方法里面了，这样理解起来方便，但是之后可能要改动。</p>\n<p>我们还是先不能看我们代理的set该怎么写，因为这个时候我们还要先继续梳理思路：</p>\n<p>假设我们这样<code>&lt;div&gt;name:&#123;&#123;name&#125;&#125;&lt;/div&gt;</code>将数据绑定到dom节点，这个时候我们需要做什么呢，或者说，我们通过什么方式让dom节点和数据对应起来，随着数据改变而改变。</p>\n<p>看上文的<code>__bindings</code>。这个对象用来存储所有绑定的dom节点信息，<code>__bindings</code>本身是一个对象，每一个有对应dom节点绑定的数据名称都是它的属性，对应一个数组，数组中的每一个内容都是一个绑定信息，这样，我们在自己写的set代理函数中，我们一个个调用过去，就可以更新内容了：</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataSet.__bindings<span class=\"built_in\">[key</span>].forEach(<span class=\"keyword\">function</span>(<span class=\"type\">item</span>)&#123;</span><br><span class=\"line\">       //do something <span class=\"keyword\">to</span> <span class=\"keyword\">update</span>...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我这里创建了一个用于构造调用的函数，这个函数用于创建存储绑定信息的对象：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Directive(el,polar,attr,elementValue)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.el=el;<span class=\"comment\">//元素本身dom节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.polar = polar;<span class=\"comment\">//对应的polar实例</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.attr = attr;<span class=\"comment\">//元素的被绑定的属性值，比如如果是文本节点就可以是nodeValue</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.el[<span class=\"keyword\">this</span>.attr] = <span class=\"keyword\">this</span>.elementValue = elementValue;<span class=\"comment\">//初始化</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们的set可以这样写:</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> set(target,<span class=\"built_in\"> key</span>, <span class=\"keyword\">value</span>, receiver) &#123;</span><br><span class=\"line\">    const result = Reflect.set(target,<span class=\"built_in\"> key</span>, <span class=\"keyword\">value</span>, receiver);</span><br><span class=\"line\">    var dataSet = receiver || target;</span><br><span class=\"line\">    dataSet.__bindings<span class=\"built_in\">[key</span>].forEach(<span class=\"keyword\">function</span>(<span class=\"type\">item</span>)&#123;</span><br><span class=\"line\">        <span class=\"type\">item</span>.el[<span class=\"type\">item</span>.attr] = <span class=\"type\">item</span>.elementValue = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来可能还有一个问题：我们的<code>&#123;&#123;name&#125;&#125;</code>实际上只是节点的一部分，这并不是节点啊，另外我们是不是还可以这么写：<code>&lt;div&gt;name:&#123;&#123;name&#125;&#125; age:&#123;&#123;age&#125;&#125;&lt;/div&gt;</code>？</p>\n<p>关于这两个问题，前者的答案是我们将<code>&#123;&#123;name&#125;&#125;</code>替换成一个文本节点，而为了应对后者的情况，我们需要将两个被绑定数据中间和前后的内容，都变成新的文本节点，然后这些文本节点组成文本节点串。(这里多说一句，html5的normalize方法可以将多个文本节点合并成一个，如果不小心调用了它，那我们的程序就要GG了)</p>\n<p>所以我们在<code>_compile</code>函数首先：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _this = <span class=\"built_in\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> nodes = root.children;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> bindDataTester = <span class=\"keyword\">new</span> <span class=\"type\">RegExp</span>(<span class=\"string\">&quot;&#123;&#123;(.*?)&#125;&#125;&quot;</span>,<span class=\"string\">&quot;ig&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(let i=<span class=\"number\">0</span>;i&lt;nodes.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> node=nodes[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//如果还有html字节点，则递归</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.children.length)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>._compile(node);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> matches = node.innerHTML.match(bindDataTester);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matches)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Matches</span> = matches.map(<span class=\"function\"><span class=\"keyword\">function</span> </span>(item) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>  item.replace(/&#123;&#123;(.*?)&#125;&#125;/,<span class=\"string\">&quot;$1&quot;</span>)</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> splitTextNodes  = node.innerHTML.split(/&#123;&#123;.*?&#125;&#125;/);</span><br><span class=\"line\">                node.innerHTML=<span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">//更新DOM，处理同一个textnode里面多次绑定情况</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(splitTextNodes[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                    node.append(document.createTextNode(splitTextNodes[<span class=\"number\">0</span>]));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(let ii=<span class=\"number\">0</span>;ii&lt;<span class=\"keyword\">new</span><span class=\"type\">Matches</span>.length;ii++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> el = document.createTextNode(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">                    node.appendChild(el);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(splitTextNodes[ii+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                        node.append(document.createTextNode(splitTextNodes[ii+<span class=\"number\">1</span>]));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                <span class=\"comment\">//对数据和dom进行绑定</span></span><br><span class=\"line\">                let returnCode = !<span class=\"built_in\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]]?</span><br><span class=\"line\">                    <span class=\"built_in\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]] = [<span class=\"keyword\">new</span> <span class=\"type\">Directive</span>(el,<span class=\"built_in\">this</span>,<span class=\"string\">&quot;nodeValue&quot;</span>,<span class=\"built_in\">this</span>.data[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]])]</span><br><span class=\"line\">                    :<span class=\"type\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]].push(<span class=\"keyword\">new</span> <span class=\"type\">Directive</span>(el,<span class=\"built_in\">this</span>,<span class=\"string\">&quot;nodeValue&quot;</span>,<span class=\"built_in\">this</span>.data[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]]))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样，我们的数据绑定阶段就写好了，接下来，我们处理<code>&lt;input p-model = &quot;name&quot; /&gt;</code>这样的情况。</p>\n<p>这实际上是一个指令，我们只需要当识别到这一个指令的时候，做一些处理，即可：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(node.has<span class=\"constructor\">Attribute((<span class=\"string\">&quot;p-model&quot;</span>)</span>)<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">                &amp;&amp; </span>node.tagName.<span class=\"keyword\">to</span><span class=\"constructor\">LocaleUpperCase()</span>==<span class=\"string\">&quot;INPUT&quot;</span><span class=\"operator\"> || </span>node.tagName.<span class=\"keyword\">to</span><span class=\"constructor\">LocaleUpperCase()</span>==<span class=\"string\">&quot;TEXTAREA&quot;</span>)&#123;</span><br><span class=\"line\">                node.add<span class=\"constructor\">EventListener(<span class=\"string\">&quot;input&quot;</span>, (<span class=\"params\">function</span> ()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    var attributeValue = node.get<span class=\"constructor\">Attribute(<span class=\"string\">&quot;p-model&quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_this</span>.</span><span class=\"module\"><span class=\"identifier\">_data</span>.</span><span class=\"module\"><span class=\"identifier\">__bindings</span>[</span></span>attributeValue]) <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_this</span>.</span><span class=\"module\"><span class=\"identifier\">_data</span>.</span><span class=\"module\"><span class=\"identifier\">__bindings</span>[</span></span>attributeValue].push(<span class=\"keyword\">new</span> <span class=\"constructor\">Directive(<span class=\"params\">node</span>,<span class=\"params\">_this</span>,<span class=\"string\">&quot;value&quot;</span>,<span class=\"params\">_this</span>.<span class=\"params\">data</span>[<span class=\"params\">attributeValue</span>])</span>) ;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_this</span>.</span><span class=\"module\"><span class=\"identifier\">_data</span>.</span><span class=\"module\"><span class=\"identifier\">__bindings</span>[</span></span>attributeValue] = <span class=\"literal\">[<span class=\"identifier\">new</span> D<span class=\"identifier\">irective</span>(<span class=\"identifier\">node</span>,<span class=\"identifier\">_this</span>,&quot;<span class=\"identifier\">value</span>&quot;,<span class=\"identifier\">_this</span>.<span class=\"identifier\">data</span>[<span class=\"identifier\">attributeValue</span>]</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">                    return <span class=\"keyword\">function</span> (event) &#123;</span><br><span class=\"line\">                        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_this</span>.</span></span>data<span class=\"literal\">[<span class=\"identifier\">attributeValue</span>]</span>=event.target.value</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)<span class=\"literal\">()</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，上面调用了一个<code>IIFE</code>，实际绑定的函数只有返回的函数那一小部分。</p>\n<p>最后我们处理事件的情况：<code>&lt;button p-click=&quot;test(2)&quot;&gt;button1&lt;/button&gt;</code></p>\n<p>实际上这比处理<code>p-model</code>还简单，但是我们为了支持函数参数的情况，处理了一下传入参数，另外我实际上将<code>event</code>始终作为一个参数传递，这也许并不是好的实践，因为使用的时候还要多注意。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(node.hasAttribute(<span class=\"string\">&quot;p-click&quot;</span>)) &#123;</span><br><span class=\"line\">                node.addEventListener(<span class=\"string\">&quot;click&quot;</span>,function()&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> attributeValue=node.getAttribute(<span class=\"string\">&quot;p-click&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> <span class=\"keyword\">args</span>=/\\(.*\\)/.exec(attributeValue);</span><br><span class=\"line\">                    <span class=\"comment\">//允许参数</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"keyword\">args</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">args</span>=<span class=\"keyword\">args</span>[0];</span><br><span class=\"line\">                        attributeValue=attributeValue.<span class=\"keyword\">replace</span>(<span class=\"keyword\">args</span>,<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">args</span>=<span class=\"keyword\">args</span>.<span class=\"keyword\">replace</span>(/[\\(\\)\\&#x27;\\<span class=\"string\">&quot;]/g,&#x27;&#x27;).split(&quot;</span>,&quot;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">args</span>=[];</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> function (event) &#123;</span><br><span class=\"line\">                        _this.methods[attributeValue].apply(_this,[event,...<span class=\"keyword\">args</span>]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在我们已经将所有的代码分析完了，是不是很清爽？代码除去注释约100行，所有源代码可以在<a href=\"https://github.com/aircloud/Polar.js\">这里下载</a>。这当然不能算作一个框架了，不过可以学习学习，这学期有时间的话，还要继续完善，也欢迎大家一起探讨。</p>\n<p>一起学习，一起提高，做技术应当是直接的，有问题欢迎指出～</p>\n<hr>\n<p>最后说的第三点：是自己还是一个学生，做这些内容也仅仅是出于兴趣，因为找暑期实习比较艰难，在等待鹅厂面试间隙写的这个程序，压压惊(然而并没有消息)。</p>\n"},{"title":"深入浏览器web渲染与优化-续","abbrlink":3602038393,"date":"2017-08-31T11:04:03.000Z","_content":">本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析\n\n上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。\n\n首先，一个网页的加载，需要什么工作呢？\n\n![](https://www.10000h.top/images/data_img/webRender2/P1.png)\n\n这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。\n\n数据到端之后，又经过以下过程，才最终显示出来：\n\n![](https://www.10000h.top/images/data_img/webRender2/P2.png)\n\n在这个过程中，我们怎么衡量性能呢？\n\n固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：\n\n![](https://www.10000h.top/images/data_img/webRender2/P3.png)\n\n但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。\n\n所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。\n\n目前这个标准是**首屏时间**(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，*另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要--from dorsywang*)\n\n那么**首屏时间**怎么测量呢？\n\n**拿摄像机快速拍照测量的**。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。  \n因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。\n当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。\n\n知道了怎么测算，那么接下来分析影响这个指标的一些原因：\n\n* 资源阻塞内核线程\n\n我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。\n\n对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。\n\n当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)\n\n* 中文Layout的时间过长\n\n这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。\n\n为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。\n\n* 首次渲染太慢\n\n为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制\n\n* 一次解析内容过多\n\n采用首屏探测机制，优先解析首屏内容。\n\n另外，这里可以前端配合去做首屏优化：\n\n\n在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏\n\n```\n<meta name=‘x5-pagetype’ content=‘optpage'>\n```\n然后在首屏分界的地方：\n\n```\n<first-screen/>\n```\n\n有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。\n\n另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。  \n*TIP:主资源中关联的子资源预拉取不用主动调用*\n\n* 预先操作\n\n另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：\n\n* 在\"黏贴并转到\"之前就开始进行网络请求和预渲染\n* 经常访问的站点可以预解析DNS\n* 点击地址栏时进行搜索预连接\n* 点击链接时，先预链接，再做跳转。\n* ......\n\n### 其他方式优化\n\n实际上上文主要讲了客户端方面的优化工作，实际上对于\"云\"、\"管\"两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考\n\n##### 后台提速\n\n* 直接使用IP，节省dns的查询时间\n* 维持长连接\n* HTTP1.1启用包头节省\n* 服务器缓存\n* 文本资源压缩传输GZIP(6)\n* 图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。\n\n##### 降低网络时延\n\n* 就快接入和就近接入\n\n在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。\n\n相比较而言，选择就快接入，是一个能够提效的方式。\n\n##### 内容防劫持\n\n运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。\n\n#### QUIC和http2\n\nQUIC 基于UDP的协议通讯方式，有这些优势：\n\n* 延迟少\n* 前向纠错\n* 没有**线头阻塞[注1]**的多路复用\n* 通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能\n\n——————\n\n注1：线头阻塞：\n\n![](https://www.10000h.top/images/data_img/webRender2/P4.png)\n\n——————\n\n附1: 带宽和延迟对网页加载的影响：\n\n![](https://www.10000h.top/images/data_img/webRender2/X1.png)\n","source":"_posts/深入浏览器web渲染与优化-续.md","raw":"---\ntitle: 深入浏览器web渲染与优化-续\ntags:\n  - 性能优化\nabbrlink: 3602038393\ndate: 2017-08-31 19:04:03\n---\n>本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析\n\n上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。\n\n首先，一个网页的加载，需要什么工作呢？\n\n![](https://www.10000h.top/images/data_img/webRender2/P1.png)\n\n这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。\n\n数据到端之后，又经过以下过程，才最终显示出来：\n\n![](https://www.10000h.top/images/data_img/webRender2/P2.png)\n\n在这个过程中，我们怎么衡量性能呢？\n\n固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：\n\n![](https://www.10000h.top/images/data_img/webRender2/P3.png)\n\n但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。\n\n所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。\n\n目前这个标准是**首屏时间**(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，*另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要--from dorsywang*)\n\n那么**首屏时间**怎么测量呢？\n\n**拿摄像机快速拍照测量的**。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。  \n因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。\n当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。\n\n知道了怎么测算，那么接下来分析影响这个指标的一些原因：\n\n* 资源阻塞内核线程\n\n我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。\n\n对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。\n\n当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)\n\n* 中文Layout的时间过长\n\n这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。\n\n为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。\n\n* 首次渲染太慢\n\n为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制\n\n* 一次解析内容过多\n\n采用首屏探测机制，优先解析首屏内容。\n\n另外，这里可以前端配合去做首屏优化：\n\n\n在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏\n\n```\n<meta name=‘x5-pagetype’ content=‘optpage'>\n```\n然后在首屏分界的地方：\n\n```\n<first-screen/>\n```\n\n有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。\n\n另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。  \n*TIP:主资源中关联的子资源预拉取不用主动调用*\n\n* 预先操作\n\n另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：\n\n* 在\"黏贴并转到\"之前就开始进行网络请求和预渲染\n* 经常访问的站点可以预解析DNS\n* 点击地址栏时进行搜索预连接\n* 点击链接时，先预链接，再做跳转。\n* ......\n\n### 其他方式优化\n\n实际上上文主要讲了客户端方面的优化工作，实际上对于\"云\"、\"管\"两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考\n\n##### 后台提速\n\n* 直接使用IP，节省dns的查询时间\n* 维持长连接\n* HTTP1.1启用包头节省\n* 服务器缓存\n* 文本资源压缩传输GZIP(6)\n* 图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。\n\n##### 降低网络时延\n\n* 就快接入和就近接入\n\n在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。\n\n相比较而言，选择就快接入，是一个能够提效的方式。\n\n##### 内容防劫持\n\n运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。\n\n#### QUIC和http2\n\nQUIC 基于UDP的协议通讯方式，有这些优势：\n\n* 延迟少\n* 前向纠错\n* 没有**线头阻塞[注1]**的多路复用\n* 通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能\n\n——————\n\n注1：线头阻塞：\n\n![](https://www.10000h.top/images/data_img/webRender2/P4.png)\n\n——————\n\n附1: 带宽和延迟对网页加载的影响：\n\n![](https://www.10000h.top/images/data_img/webRender2/X1.png)\n","slug":"深入浏览器web渲染与优化-续","published":1,"updated":"2021-12-23T05:50:07.550Z","_id":"ckxijpqt30019d3mr67z23f5t","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析</p>\n</blockquote>\n<p>上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。</p>\n<p>首先，一个网页的加载，需要什么工作呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P1.png\"></p>\n<p>这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。</p>\n<p>数据到端之后，又经过以下过程，才最终显示出来：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P2.png\"></p>\n<p>在这个过程中，我们怎么衡量性能呢？</p>\n<p>固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P3.png\"></p>\n<p>但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。</p>\n<p>所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。</p>\n<p>目前这个标准是<strong>首屏时间</strong>(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，<em>另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要–from dorsywang</em>)</p>\n<p>那么<strong>首屏时间</strong>怎么测量呢？</p>\n<p><strong>拿摄像机快速拍照测量的</strong>。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。<br>因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。<br>当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。</p>\n<p>知道了怎么测算，那么接下来分析影响这个指标的一些原因：</p>\n<ul>\n<li>资源阻塞内核线程</li>\n</ul>\n<p>我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。</p>\n<p>对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。</p>\n<p>当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)</p>\n<ul>\n<li>中文Layout的时间过长</li>\n</ul>\n<p>这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。</p>\n<p>为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。</p>\n<ul>\n<li>首次渲染太慢</li>\n</ul>\n<p>为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制</p>\n<ul>\n<li>一次解析内容过多</li>\n</ul>\n<p>采用首屏探测机制，优先解析首屏内容。</p>\n<p>另外，这里可以前端配合去做首屏优化：</p>\n<p>在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta <span class=\"attribute\">name</span>=‘x5-pagetype’ <span class=\"attribute\">content</span>=‘optpage&#x27;&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在首屏分界的地方：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;first-screen/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。</p>\n<p>另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。<br><em>TIP:主资源中关联的子资源预拉取不用主动调用</em></p>\n<ul>\n<li>预先操作</li>\n</ul>\n<p>另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：</p>\n<ul>\n<li>在”黏贴并转到”之前就开始进行网络请求和预渲染</li>\n<li>经常访问的站点可以预解析DNS</li>\n<li>点击地址栏时进行搜索预连接</li>\n<li>点击链接时，先预链接，再做跳转。</li>\n<li>……</li>\n</ul>\n<h3 id=\"其他方式优化\"><a href=\"#其他方式优化\" class=\"headerlink\" title=\"其他方式优化\"></a>其他方式优化</h3><p>实际上上文主要讲了客户端方面的优化工作，实际上对于”云”、”管”两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考</p>\n<h5 id=\"后台提速\"><a href=\"#后台提速\" class=\"headerlink\" title=\"后台提速\"></a>后台提速</h5><ul>\n<li>直接使用IP，节省dns的查询时间</li>\n<li>维持长连接</li>\n<li>HTTP1.1启用包头节省</li>\n<li>服务器缓存</li>\n<li>文本资源压缩传输GZIP(6)</li>\n<li>图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。</li>\n</ul>\n<h5 id=\"降低网络时延\"><a href=\"#降低网络时延\" class=\"headerlink\" title=\"降低网络时延\"></a>降低网络时延</h5><ul>\n<li>就快接入和就近接入</li>\n</ul>\n<p>在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。</p>\n<p>相比较而言，选择就快接入，是一个能够提效的方式。</p>\n<h5 id=\"内容防劫持\"><a href=\"#内容防劫持\" class=\"headerlink\" title=\"内容防劫持\"></a>内容防劫持</h5><p>运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。</p>\n<h4 id=\"QUIC和http2\"><a href=\"#QUIC和http2\" class=\"headerlink\" title=\"QUIC和http2\"></a>QUIC和http2</h4><p>QUIC 基于UDP的协议通讯方式，有这些优势：</p>\n<ul>\n<li>延迟少</li>\n<li>前向纠错</li>\n<li>没有**线头阻塞[注1]**的多路复用</li>\n<li>通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能</li>\n</ul>\n<p>——————</p>\n<p>注1：线头阻塞：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P4.png\"></p>\n<p>——————</p>\n<p>附1: 带宽和延迟对网页加载的影响：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/X1.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析</p>\n</blockquote>\n<p>上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。</p>\n<p>首先，一个网页的加载，需要什么工作呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P1.png\"></p>\n<p>这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。</p>\n<p>数据到端之后，又经过以下过程，才最终显示出来：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P2.png\"></p>\n<p>在这个过程中，我们怎么衡量性能呢？</p>\n<p>固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P3.png\"></p>\n<p>但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。</p>\n<p>所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。</p>\n<p>目前这个标准是<strong>首屏时间</strong>(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，<em>另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要–from dorsywang</em>)</p>\n<p>那么<strong>首屏时间</strong>怎么测量呢？</p>\n<p><strong>拿摄像机快速拍照测量的</strong>。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。<br>因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。<br>当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。</p>\n<p>知道了怎么测算，那么接下来分析影响这个指标的一些原因：</p>\n<ul>\n<li>资源阻塞内核线程</li>\n</ul>\n<p>我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。</p>\n<p>对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。</p>\n<p>当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)</p>\n<ul>\n<li>中文Layout的时间过长</li>\n</ul>\n<p>这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。</p>\n<p>为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。</p>\n<ul>\n<li>首次渲染太慢</li>\n</ul>\n<p>为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制</p>\n<ul>\n<li>一次解析内容过多</li>\n</ul>\n<p>采用首屏探测机制，优先解析首屏内容。</p>\n<p>另外，这里可以前端配合去做首屏优化：</p>\n<p>在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta <span class=\"attribute\">name</span>=‘x5-pagetype’ <span class=\"attribute\">content</span>=‘optpage&#x27;&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在首屏分界的地方：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;first-screen/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。</p>\n<p>另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。<br><em>TIP:主资源中关联的子资源预拉取不用主动调用</em></p>\n<ul>\n<li>预先操作</li>\n</ul>\n<p>另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：</p>\n<ul>\n<li>在”黏贴并转到”之前就开始进行网络请求和预渲染</li>\n<li>经常访问的站点可以预解析DNS</li>\n<li>点击地址栏时进行搜索预连接</li>\n<li>点击链接时，先预链接，再做跳转。</li>\n<li>……</li>\n</ul>\n<h3 id=\"其他方式优化\"><a href=\"#其他方式优化\" class=\"headerlink\" title=\"其他方式优化\"></a>其他方式优化</h3><p>实际上上文主要讲了客户端方面的优化工作，实际上对于”云”、”管”两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考</p>\n<h5 id=\"后台提速\"><a href=\"#后台提速\" class=\"headerlink\" title=\"后台提速\"></a>后台提速</h5><ul>\n<li>直接使用IP，节省dns的查询时间</li>\n<li>维持长连接</li>\n<li>HTTP1.1启用包头节省</li>\n<li>服务器缓存</li>\n<li>文本资源压缩传输GZIP(6)</li>\n<li>图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。</li>\n</ul>\n<h5 id=\"降低网络时延\"><a href=\"#降低网络时延\" class=\"headerlink\" title=\"降低网络时延\"></a>降低网络时延</h5><ul>\n<li>就快接入和就近接入</li>\n</ul>\n<p>在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。</p>\n<p>相比较而言，选择就快接入，是一个能够提效的方式。</p>\n<h5 id=\"内容防劫持\"><a href=\"#内容防劫持\" class=\"headerlink\" title=\"内容防劫持\"></a>内容防劫持</h5><p>运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。</p>\n<h4 id=\"QUIC和http2\"><a href=\"#QUIC和http2\" class=\"headerlink\" title=\"QUIC和http2\"></a>QUIC和http2</h4><p>QUIC 基于UDP的协议通讯方式，有这些优势：</p>\n<ul>\n<li>延迟少</li>\n<li>前向纠错</li>\n<li>没有**线头阻塞[注1]**的多路复用</li>\n<li>通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能</li>\n</ul>\n<p>——————</p>\n<p>注1：线头阻塞：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P4.png\"></p>\n<p>——————</p>\n<p>附1: 带宽和延迟对网页加载的影响：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/X1.png\"></p>\n"},{"title":"深入Vue源代码解决时序问题一","abbrlink":3993001440,"date":"2019-07-06T07:21:51.000Z","_content":"\n>viola 是一个支持 Vue 的动态化框架，其 Vue 版本在 Vue 官方版本 2.5.7 上进行了少量改写，本文针对其进行具体分析。\n\n最初，有使用者报告一个错误：在 iOS 系统，退出页面的时候，框架报错：\n\n```\nTypeError: undefined is not an object(evaluating 'e.isDestroyed\"\n```\n\n接到这个错误之后，我首先进入 Vue 的 debug 版本，尝试获取更详细的信息：\n\n```\nTypeError: undefined is not an object(evaluating 'componentInstance.isDestroyed\"\n```\n\n我们顺利地拿到了报错的变量名称，去 Vue 源代码中搜索，我们可以发现报错之处：\n\n```javascript\ndestroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) { // 这里报错\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n```\n\n这里是 `componentInstance` 为 undefined，这个实际上是 vnode 的实例，其为 undefined，说明该 vue 组件在之前的阶段就已经出错不正常了，这里并不是错误的根源所在，我们需要再次进行寻找报错原因。\n\n于是我们查看业务代码的所有日志，又发现了这样一条报错：\n\n```\n[Vue warn]: Error in nextTick: \"TypeError: undefined is not an object (evaluating 'vm.$options')\" \n```\n\n初始化阶段出现这样一个错误，我们怀疑 `vm` 就是上文的 `componentInstance`，于是，我们打印报错堆栈：\n\n```javascript\n 调用栈:\nfunction updateChildComponent(\n    vm,\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n        //...\n        var hasChildren = !!(\n              renderChildren ||\n              vm.$options._renderChildren || // 这里报错\n              parentVnode.data.scopedSlots ||\n              vm.$scopedSlots !== emptyObject\n            );\n    }\n\nfunction prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(\n        child,\n        options.propsData,\n        options.listeners,\n        vnode,\n        options.children\n      );\n    }\n\nfunction patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {}\nfunction patch(oldVnode, vnode, hydrating, removeOnly) {}\nfunction (vnode, hydrating) {}\nfunction () {\n        vm._update(vm._render(), hydrating);\n      }\nfunction get() {}\nfunction getAndInvoke(cb) {}\nfunction run() {}\nfunction flushSchedulerQueue() {}\nfunction flushCallbacks() {}\n```\n\n调用栈实际上有点冗长，不过我们还是能发现两个有用的信息：\n\n* 初始化阶段为 `undefined` 的 `vm`，就是 `componentInstance`，也就是和 destroy 阶段的报错属于同一个原因。\n* 根据调用栈发现，这是一个更新阶段的报错。\n\n这引发了我们的思考：更新阶段找不到 `componentInstance` 报错。\n\n这里实际上有点阻塞了，因为一般来说，Vue 的源代码经过测试，应该不会出现这种问题的，那是不是我们的问题呢，我们回归到业务代码：\n\n```\ncreated() {\n    this.getFeedsListFromCache();\n},\nmethods: {\n    getFeedsListFromCache() {\n        viola.requireAPI(\"cache\").getItem(this.cacheKey_feeds, data => {\n            this.processData(data.list);\n        });\n    },\n    processData(list = [], opt = {}) {\n        if (this.list.length < cacehFeedsLength) {\n        }\n        this.list = [];\n    },\n}\n```\n\n我们对业务代码进行了抽象简化，上面是我们的最小问题 Demo，实际上我们就做了这样一件事情：\n\n* 在 created 执行方法，调用端的接口，再回调函数里面更新某个 data 中声明的数据。\n\n首先，我们可以梳理下对一般 vue 组件的初始化更新，vue 是如何做的：\n\n* created 时实际上 vnode 已经建立完成，这个时候还没有 mount，但是数据监听已经建立了，这个时候如果改动数据，会把相关 update 函数放在一个名为 flushCallbacks 的函数队列中。\n* 该函数队列会通过默认为 `Promise.then` 的 microtask 方式来调度，当前阶段的 mount 流程会继续，mount 结束后，会执行 flushCallbacks 队列中的更新操作。\n\n从代码层面上来讲，这几个流程应该是这样的：\n\n```\n ├── callHook(vm, 'created'); // 执行created 钩子\n ├── proxySetter(val); // 改变数据，调用 proxy\n ├── Watcher.prototype.update; // 调用 Watcher，将 update 操作入栈\n ├── vm.$mount(vm.$options.el); // 执行 mount 流程\n ├── callHook(vm, 'beforeMount');\n ├──  callHook(vm, 'mounted'); // 依次调用 beforeMount 和 mounted\n └── flushCallbacks // 执行 更新\n```\n\n然后我们分析我们这里的流程，首先值得强调的是这个函数 `viola.requireAPI(\"cache\").getItem`，这个函数是端注入的函数，但我们不能将其当作异步函数来对待，实际上，**这是一个同步函数**，（至于这个同步函数和 js 中的普通函数，是否有区别，还有待商榷，不过应该是有区别的，因为如果我们不用此函数的话，就不会出现该问题。）\n\n接下来，我们打出详细的调用栈，根据顺序来分析实际的执行流程：\n\n```\n ├── callHook(vm, 'created'); // 执行created 钩子\n ├── proxySetter(val); // 改变数据，调用 proxy\n ├── Watcher.prototype.update; // 调用 Watcher，将 update 操作入栈\n ├── flushCallbacks // 执行 更新\n ├── vm.$mount(vm.$options.el); // 执行 mount 流程 \n ├── callHook(vm, 'beforeMount');\n └── callHook(vm, 'mounted'); // 依次调用 beforeMount 和 mounted\n```\n\n我们发现，我们的执行流程出现了很大问题：**在 mount 阶段未完成的时候就执行了 flushCallbacks，先执行更新操作，这里的顺序错乱导致了后续问题**。\n\n我们可看下调用 `flushCallbacks` 的代码：\n\n```javascript\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  microTimerFunc = function () {\n    p.then(flushCallbacks);\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n} \n```\n\n这里 `microTimerFunc` 的 `p.then`，被同步执行了，也就是说，这里的微任务优先于当前事件循环的函数执行了（此时由于 mount 流程是同步的，mount 流程的相关函数**理应**在该事件循环中，优先于微任务执行）。\n\n我们找到了根源，接下来就是分析解决方案和根本原因。\n\n由于我们的问题在于 update 流程执行太快了，所以采用一种方式放慢一点即可：\n\n* 将 vue 的微任务模式（默认）改成宏任务模式：`var useMacroTask = false; => true`。\n* 在 created 阶段的加一个 `setTimeout(0)`。\n\n不过对于根本原因，实际上本次仍然没有完全分析透彻，还留有如下疑问：\n\n* `viola.requireAPI(\"cache\").getItem` 这个函数到底做了什么？其对事件循环有什么影响？\n* 在执行 `microTimerFunc` 的时候，为什么 `p.then` 优先于 `vm.$mount` 执行了？\n* 该错误仅在 iOS 系统出现，iOS 系统是否会在某些情况将微任务的优先级变高？\n\n对于这些疑问，Vue 源代码中也做了一些评论：\n\n```\n// Here we have async deferring wrappers using both microtasks and (macro) tasks.\n// In < 2.4 we used microtasks everywhere, but there are some scenarios where\n// microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\n// event (#6566). However, using (macro) tasks everywhere also has subtle problems\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\n// Here we use microtask by default, but expose a way to force (macro) task when\n// needed (e.g. in event handlers attached by v-on).\n```\n\n不过，这里始终都没有找到最本质的原因，也许这和 iOS JSCore 的微任务/宏任务的处理机制有关，具体原因，待下次探究。\n\n\n\n","source":"_posts/深入Vue源代码解决时序问题一.md","raw":"---\ntitle: 深入Vue源代码解决时序问题一\ntags:\n  - Vue\n  - viola\nabbrlink: 3993001440\ndate: 2019-07-06 15:21:51\n---\n\n>viola 是一个支持 Vue 的动态化框架，其 Vue 版本在 Vue 官方版本 2.5.7 上进行了少量改写，本文针对其进行具体分析。\n\n最初，有使用者报告一个错误：在 iOS 系统，退出页面的时候，框架报错：\n\n```\nTypeError: undefined is not an object(evaluating 'e.isDestroyed\"\n```\n\n接到这个错误之后，我首先进入 Vue 的 debug 版本，尝试获取更详细的信息：\n\n```\nTypeError: undefined is not an object(evaluating 'componentInstance.isDestroyed\"\n```\n\n我们顺利地拿到了报错的变量名称，去 Vue 源代码中搜索，我们可以发现报错之处：\n\n```javascript\ndestroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) { // 这里报错\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n```\n\n这里是 `componentInstance` 为 undefined，这个实际上是 vnode 的实例，其为 undefined，说明该 vue 组件在之前的阶段就已经出错不正常了，这里并不是错误的根源所在，我们需要再次进行寻找报错原因。\n\n于是我们查看业务代码的所有日志，又发现了这样一条报错：\n\n```\n[Vue warn]: Error in nextTick: \"TypeError: undefined is not an object (evaluating 'vm.$options')\" \n```\n\n初始化阶段出现这样一个错误，我们怀疑 `vm` 就是上文的 `componentInstance`，于是，我们打印报错堆栈：\n\n```javascript\n 调用栈:\nfunction updateChildComponent(\n    vm,\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n        //...\n        var hasChildren = !!(\n              renderChildren ||\n              vm.$options._renderChildren || // 这里报错\n              parentVnode.data.scopedSlots ||\n              vm.$scopedSlots !== emptyObject\n            );\n    }\n\nfunction prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(\n        child,\n        options.propsData,\n        options.listeners,\n        vnode,\n        options.children\n      );\n    }\n\nfunction patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {}\nfunction patch(oldVnode, vnode, hydrating, removeOnly) {}\nfunction (vnode, hydrating) {}\nfunction () {\n        vm._update(vm._render(), hydrating);\n      }\nfunction get() {}\nfunction getAndInvoke(cb) {}\nfunction run() {}\nfunction flushSchedulerQueue() {}\nfunction flushCallbacks() {}\n```\n\n调用栈实际上有点冗长，不过我们还是能发现两个有用的信息：\n\n* 初始化阶段为 `undefined` 的 `vm`，就是 `componentInstance`，也就是和 destroy 阶段的报错属于同一个原因。\n* 根据调用栈发现，这是一个更新阶段的报错。\n\n这引发了我们的思考：更新阶段找不到 `componentInstance` 报错。\n\n这里实际上有点阻塞了，因为一般来说，Vue 的源代码经过测试，应该不会出现这种问题的，那是不是我们的问题呢，我们回归到业务代码：\n\n```\ncreated() {\n    this.getFeedsListFromCache();\n},\nmethods: {\n    getFeedsListFromCache() {\n        viola.requireAPI(\"cache\").getItem(this.cacheKey_feeds, data => {\n            this.processData(data.list);\n        });\n    },\n    processData(list = [], opt = {}) {\n        if (this.list.length < cacehFeedsLength) {\n        }\n        this.list = [];\n    },\n}\n```\n\n我们对业务代码进行了抽象简化，上面是我们的最小问题 Demo，实际上我们就做了这样一件事情：\n\n* 在 created 执行方法，调用端的接口，再回调函数里面更新某个 data 中声明的数据。\n\n首先，我们可以梳理下对一般 vue 组件的初始化更新，vue 是如何做的：\n\n* created 时实际上 vnode 已经建立完成，这个时候还没有 mount，但是数据监听已经建立了，这个时候如果改动数据，会把相关 update 函数放在一个名为 flushCallbacks 的函数队列中。\n* 该函数队列会通过默认为 `Promise.then` 的 microtask 方式来调度，当前阶段的 mount 流程会继续，mount 结束后，会执行 flushCallbacks 队列中的更新操作。\n\n从代码层面上来讲，这几个流程应该是这样的：\n\n```\n ├── callHook(vm, 'created'); // 执行created 钩子\n ├── proxySetter(val); // 改变数据，调用 proxy\n ├── Watcher.prototype.update; // 调用 Watcher，将 update 操作入栈\n ├── vm.$mount(vm.$options.el); // 执行 mount 流程\n ├── callHook(vm, 'beforeMount');\n ├──  callHook(vm, 'mounted'); // 依次调用 beforeMount 和 mounted\n └── flushCallbacks // 执行 更新\n```\n\n然后我们分析我们这里的流程，首先值得强调的是这个函数 `viola.requireAPI(\"cache\").getItem`，这个函数是端注入的函数，但我们不能将其当作异步函数来对待，实际上，**这是一个同步函数**，（至于这个同步函数和 js 中的普通函数，是否有区别，还有待商榷，不过应该是有区别的，因为如果我们不用此函数的话，就不会出现该问题。）\n\n接下来，我们打出详细的调用栈，根据顺序来分析实际的执行流程：\n\n```\n ├── callHook(vm, 'created'); // 执行created 钩子\n ├── proxySetter(val); // 改变数据，调用 proxy\n ├── Watcher.prototype.update; // 调用 Watcher，将 update 操作入栈\n ├── flushCallbacks // 执行 更新\n ├── vm.$mount(vm.$options.el); // 执行 mount 流程 \n ├── callHook(vm, 'beforeMount');\n └── callHook(vm, 'mounted'); // 依次调用 beforeMount 和 mounted\n```\n\n我们发现，我们的执行流程出现了很大问题：**在 mount 阶段未完成的时候就执行了 flushCallbacks，先执行更新操作，这里的顺序错乱导致了后续问题**。\n\n我们可看下调用 `flushCallbacks` 的代码：\n\n```javascript\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  microTimerFunc = function () {\n    p.then(flushCallbacks);\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n} \n```\n\n这里 `microTimerFunc` 的 `p.then`，被同步执行了，也就是说，这里的微任务优先于当前事件循环的函数执行了（此时由于 mount 流程是同步的，mount 流程的相关函数**理应**在该事件循环中，优先于微任务执行）。\n\n我们找到了根源，接下来就是分析解决方案和根本原因。\n\n由于我们的问题在于 update 流程执行太快了，所以采用一种方式放慢一点即可：\n\n* 将 vue 的微任务模式（默认）改成宏任务模式：`var useMacroTask = false; => true`。\n* 在 created 阶段的加一个 `setTimeout(0)`。\n\n不过对于根本原因，实际上本次仍然没有完全分析透彻，还留有如下疑问：\n\n* `viola.requireAPI(\"cache\").getItem` 这个函数到底做了什么？其对事件循环有什么影响？\n* 在执行 `microTimerFunc` 的时候，为什么 `p.then` 优先于 `vm.$mount` 执行了？\n* 该错误仅在 iOS 系统出现，iOS 系统是否会在某些情况将微任务的优先级变高？\n\n对于这些疑问，Vue 源代码中也做了一些评论：\n\n```\n// Here we have async deferring wrappers using both microtasks and (macro) tasks.\n// In < 2.4 we used microtasks everywhere, but there are some scenarios where\n// microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\n// event (#6566). However, using (macro) tasks everywhere also has subtle problems\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\n// Here we use microtask by default, but expose a way to force (macro) task when\n// needed (e.g. in event handlers attached by v-on).\n```\n\n不过，这里始终都没有找到最本质的原因，也许这和 iOS JSCore 的微任务/宏任务的处理机制有关，具体原因，待下次探究。\n\n\n\n","slug":"深入Vue源代码解决时序问题一","published":1,"updated":"2021-12-23T05:50:07.550Z","_id":"ckxijpqt4001bd3mr1w23fgri","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>viola 是一个支持 Vue 的动态化框架，其 Vue 版本在 Vue 官方版本 2.5.7 上进行了少量改写，本文针对其进行具体分析。</p>\n</blockquote>\n<p>最初，有使用者报告一个错误：在 iOS 系统，退出页面的时候，框架报错：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">TypeError:</span> undefined <span class=\"built_in\">is</span> <span class=\"built_in\">not</span> an <span class=\"type\">object</span>(evaluating <span class=\"comment\">&#x27;e.isDestroyed&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>接到这个错误之后，我首先进入 Vue 的 debug 版本，尝试获取更详细的信息：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">TypeError:</span> undefined <span class=\"built_in\">is</span> <span class=\"built_in\">not</span> an <span class=\"type\">object</span>(evaluating <span class=\"comment\">&#x27;componentInstance.isDestroyed&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们顺利地拿到了报错的变量名称，去 Vue 源代码中搜索，我们可以发现报错之处：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">destroy: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">destroy</span> (<span class=\"params\">vnode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> componentInstance = vnode.componentInstance;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!componentInstance._isDestroyed) &#123; <span class=\"comment\">// 这里报错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!vnode.data.keepAlive) &#123;</span><br><span class=\"line\">        componentInstance.$destroy();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        deactivateChildComponent(componentInstance, <span class=\"literal\">true</span> <span class=\"comment\">/* direct */</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是 <code>componentInstance</code> 为 undefined，这个实际上是 vnode 的实例，其为 undefined，说明该 vue 组件在之前的阶段就已经出错不正常了，这里并不是错误的根源所在，我们需要再次进行寻找报错原因。</p>\n<p>于是我们查看业务代码的所有日志，又发现了这样一条报错：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Vue warn]: <span class=\"builtin-name\">Error</span> <span class=\"keyword\">in</span> nextTick: <span class=\"string\">&quot;TypeError: undefined is not an object (evaluating &#x27;vm.<span class=\"variable\">$options</span>&#x27;)&quot;</span> </span><br></pre></td></tr></table></figure>\n\n<p>初始化阶段出现这样一个错误，我们怀疑 <code>vm</code> 就是上文的 <code>componentInstance</code>，于是，我们打印报错堆栈：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 调用栈:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateChildComponent</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    vm,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    propsData,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    listeners,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parentVnode,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    renderChildren</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> hasChildren = !!(</span><br><span class=\"line\">              renderChildren ||</span><br><span class=\"line\">              vm.$options._renderChildren || <span class=\"comment\">// 这里报错</span></span><br><span class=\"line\">              parentVnode.data.scopedSlots ||</span><br><span class=\"line\">              vm.$scopedSlots !== emptyObject</span><br><span class=\"line\">            );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prepatch</span>(<span class=\"params\">oldVnode, vnode</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> options = vnode.componentOptions;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> child = vnode.componentInstance = oldVnode.componentInstance;</span><br><span class=\"line\">      updateChildComponent(</span><br><span class=\"line\">        child,</span><br><span class=\"line\">        options.propsData,</span><br><span class=\"line\">        options.listeners,</span><br><span class=\"line\">        vnode,</span><br><span class=\"line\">        options.children</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patchVnode</span>(<span class=\"params\">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patch</span>(<span class=\"params\">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">vnode, hydrating</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        vm._update(vm._render(), hydrating);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAndInvoke</span>(<span class=\"params\">cb</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flushSchedulerQueue</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flushCallbacks</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用栈实际上有点冗长，不过我们还是能发现两个有用的信息：</p>\n<ul>\n<li>初始化阶段为 <code>undefined</code> 的 <code>vm</code>，就是 <code>componentInstance</code>，也就是和 destroy 阶段的报错属于同一个原因。</li>\n<li>根据调用栈发现，这是一个更新阶段的报错。</li>\n</ul>\n<p>这引发了我们的思考：更新阶段找不到 <code>componentInstance</code> 报错。</p>\n<p>这里实际上有点阻塞了，因为一般来说，Vue 的源代码经过测试，应该不会出现这种问题的，那是不是我们的问题呢，我们回归到业务代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">created</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.getFeedsListFromCache();</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getFeedsListFromCache</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        viola.requireAPI(<span class=\"string\">&quot;cache&quot;</span>).getItem(<span class=\"built_in\">this</span>.cacheKey_feeds, <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.processData(data.list);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">processData</span>(<span class=\"params\">list = [], opt = &#123;&#125;</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.list.length &lt; cacehFeedsLength) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.list = [];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们对业务代码进行了抽象简化，上面是我们的最小问题 Demo，实际上我们就做了这样一件事情：</p>\n<ul>\n<li>在 created 执行方法，调用端的接口，再回调函数里面更新某个 data 中声明的数据。</li>\n</ul>\n<p>首先，我们可以梳理下对一般 vue 组件的初始化更新，vue 是如何做的：</p>\n<ul>\n<li>created 时实际上 vnode 已经建立完成，这个时候还没有 mount，但是数据监听已经建立了，这个时候如果改动数据，会把相关 update 函数放在一个名为 flushCallbacks 的函数队列中。</li>\n<li>该函数队列会通过默认为 <code>Promise.then</code> 的 microtask 方式来调度，当前阶段的 mount 流程会继续，mount 结束后，会执行 flushCallbacks 队列中的更新操作。</li>\n</ul>\n<p>从代码层面上来讲，这几个流程应该是这样的：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">created</span>&#x27;)</span>; <span class=\"comment\">// 执行created 钩子</span></span><br><span class=\"line\">├── proxy<span class=\"constructor\">Setter(<span class=\"params\">val</span>)</span>; <span class=\"comment\">// 改变数据，调用 proxy</span></span><br><span class=\"line\">├── <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Watcher</span>.</span></span>prototype.update; <span class=\"comment\">// 调用 Watcher，将 update 操作入栈</span></span><br><span class=\"line\">├── vm.<span class=\"constructor\">$mount(<span class=\"params\">vm</span>.$<span class=\"params\">options</span>.<span class=\"params\">el</span>)</span>; <span class=\"comment\">// 执行 mount 流程</span></span><br><span class=\"line\">├── call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">beforeMount</span>&#x27;)</span>;</span><br><span class=\"line\">├──  call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">mounted</span>&#x27;)</span>; <span class=\"comment\">// 依次调用 beforeMount 和 mounted</span></span><br><span class=\"line\">└── flushCallbacks <span class=\"comment\">// 执行 更新</span></span><br></pre></td></tr></table></figure>\n\n<p>然后我们分析我们这里的流程，首先值得强调的是这个函数 <code>viola.requireAPI(&quot;cache&quot;).getItem</code>，这个函数是端注入的函数，但我们不能将其当作异步函数来对待，实际上，<strong>这是一个同步函数</strong>，（至于这个同步函数和 js 中的普通函数，是否有区别，还有待商榷，不过应该是有区别的，因为如果我们不用此函数的话，就不会出现该问题。）</p>\n<p>接下来，我们打出详细的调用栈，根据顺序来分析实际的执行流程：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">created</span>&#x27;)</span>; <span class=\"comment\">// 执行created 钩子</span></span><br><span class=\"line\">├── proxy<span class=\"constructor\">Setter(<span class=\"params\">val</span>)</span>; <span class=\"comment\">// 改变数据，调用 proxy</span></span><br><span class=\"line\">├── <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Watcher</span>.</span></span>prototype.update; <span class=\"comment\">// 调用 Watcher，将 update 操作入栈</span></span><br><span class=\"line\">├── flushCallbacks <span class=\"comment\">// 执行 更新</span></span><br><span class=\"line\">├── vm.<span class=\"constructor\">$mount(<span class=\"params\">vm</span>.$<span class=\"params\">options</span>.<span class=\"params\">el</span>)</span>; <span class=\"comment\">// 执行 mount 流程 </span></span><br><span class=\"line\">├── call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">beforeMount</span>&#x27;)</span>;</span><br><span class=\"line\">└── call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">mounted</span>&#x27;)</span>; <span class=\"comment\">// 依次调用 beforeMount 和 mounted</span></span><br></pre></td></tr></table></figure>\n\n<p>我们发现，我们的执行流程出现了很大问题：<strong>在 mount 阶段未完成的时候就执行了 flushCallbacks，先执行更新操作，这里的顺序错乱导致了后续问题</strong>。</p>\n<p>我们可看下调用 <code>flushCallbacks</code> 的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Promise</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class=\"built_in\">Promise</span>)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">  microTimerFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    p.then(flushCallbacks);</span><br><span class=\"line\">    <span class=\"comment\">// in problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class=\"line\">    <span class=\"comment\">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class=\"line\">    <span class=\"comment\">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class=\"line\">    <span class=\"comment\">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class=\"line\">    <span class=\"comment\">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isIOS) &#123; <span class=\"built_in\">setTimeout</span>(noop); &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>这里 <code>microTimerFunc</code> 的 <code>p.then</code>，被同步执行了，也就是说，这里的微任务优先于当前事件循环的函数执行了（此时由于 mount 流程是同步的，mount 流程的相关函数<strong>理应</strong>在该事件循环中，优先于微任务执行）。</p>\n<p>我们找到了根源，接下来就是分析解决方案和根本原因。</p>\n<p>由于我们的问题在于 update 流程执行太快了，所以采用一种方式放慢一点即可：</p>\n<ul>\n<li>将 vue 的微任务模式（默认）改成宏任务模式：<code>var useMacroTask = false; =&gt; true</code>。</li>\n<li>在 created 阶段的加一个 <code>setTimeout(0)</code>。</li>\n</ul>\n<p>不过对于根本原因，实际上本次仍然没有完全分析透彻，还留有如下疑问：</p>\n<ul>\n<li><code>viola.requireAPI(&quot;cache&quot;).getItem</code> 这个函数到底做了什么？其对事件循环有什么影响？</li>\n<li>在执行 <code>microTimerFunc</code> 的时候，为什么 <code>p.then</code> 优先于 <code>vm.$mount</code> 执行了？</li>\n<li>该错误仅在 iOS 系统出现，iOS 系统是否会在某些情况将微任务的优先级变高？</li>\n</ul>\n<p>对于这些疑问，Vue 源代码中也做了一些评论：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Here we have async deferring wrappers using both microtasks and (macro) tasks.</span><br><span class=\"line\"><span class=\"regexp\">//</span> In &lt; <span class=\"number\">2.4</span> we used microtasks everywhere, but there are some scenarios where</span><br><span class=\"line\"><span class=\"regexp\">//</span> microtasks have too high a priority and fire <span class=\"keyword\">in</span> between supposedly</span><br><span class=\"line\"><span class=\"regexp\">//</span> sequential events (e.g. <span class=\"comment\">#4521, #6690) or even between bubbling of the same</span></span><br><span class=\"line\"><span class=\"regexp\">//</span> event (<span class=\"comment\">#6566). However, using (macro) tasks everywhere also has subtle problems</span></span><br><span class=\"line\"><span class=\"regexp\">//</span> when state is changed right before repaint (e.g. <span class=\"comment\">#6813, out-in transitions).</span></span><br><span class=\"line\"><span class=\"regexp\">//</span> Here we use microtask by default, but expose a way to force (macro) task when</span><br><span class=\"line\"><span class=\"regexp\">//</span> needed (e.g. <span class=\"keyword\">in</span> event handlers attached by v-on).</span><br></pre></td></tr></table></figure>\n\n<p>不过，这里始终都没有找到最本质的原因，也许这和 iOS JSCore 的微任务/宏任务的处理机制有关，具体原因，待下次探究。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>viola 是一个支持 Vue 的动态化框架，其 Vue 版本在 Vue 官方版本 2.5.7 上进行了少量改写，本文针对其进行具体分析。</p>\n</blockquote>\n<p>最初，有使用者报告一个错误：在 iOS 系统，退出页面的时候，框架报错：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">TypeError:</span> undefined <span class=\"built_in\">is</span> <span class=\"built_in\">not</span> an <span class=\"type\">object</span>(evaluating <span class=\"comment\">&#x27;e.isDestroyed&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>接到这个错误之后，我首先进入 Vue 的 debug 版本，尝试获取更详细的信息：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">TypeError:</span> undefined <span class=\"built_in\">is</span> <span class=\"built_in\">not</span> an <span class=\"type\">object</span>(evaluating <span class=\"comment\">&#x27;componentInstance.isDestroyed&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们顺利地拿到了报错的变量名称，去 Vue 源代码中搜索，我们可以发现报错之处：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">destroy: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">destroy</span> (<span class=\"params\">vnode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> componentInstance = vnode.componentInstance;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!componentInstance._isDestroyed) &#123; <span class=\"comment\">// 这里报错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!vnode.data.keepAlive) &#123;</span><br><span class=\"line\">        componentInstance.$destroy();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        deactivateChildComponent(componentInstance, <span class=\"literal\">true</span> <span class=\"comment\">/* direct */</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是 <code>componentInstance</code> 为 undefined，这个实际上是 vnode 的实例，其为 undefined，说明该 vue 组件在之前的阶段就已经出错不正常了，这里并不是错误的根源所在，我们需要再次进行寻找报错原因。</p>\n<p>于是我们查看业务代码的所有日志，又发现了这样一条报错：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Vue warn]: <span class=\"builtin-name\">Error</span> <span class=\"keyword\">in</span> nextTick: <span class=\"string\">&quot;TypeError: undefined is not an object (evaluating &#x27;vm.<span class=\"variable\">$options</span>&#x27;)&quot;</span> </span><br></pre></td></tr></table></figure>\n\n<p>初始化阶段出现这样一个错误，我们怀疑 <code>vm</code> 就是上文的 <code>componentInstance</code>，于是，我们打印报错堆栈：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 调用栈:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateChildComponent</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    vm,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    propsData,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    listeners,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    parentVnode,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    renderChildren</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> hasChildren = !!(</span><br><span class=\"line\">              renderChildren ||</span><br><span class=\"line\">              vm.$options._renderChildren || <span class=\"comment\">// 这里报错</span></span><br><span class=\"line\">              parentVnode.data.scopedSlots ||</span><br><span class=\"line\">              vm.$scopedSlots !== emptyObject</span><br><span class=\"line\">            );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prepatch</span>(<span class=\"params\">oldVnode, vnode</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> options = vnode.componentOptions;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> child = vnode.componentInstance = oldVnode.componentInstance;</span><br><span class=\"line\">      updateChildComponent(</span><br><span class=\"line\">        child,</span><br><span class=\"line\">        options.propsData,</span><br><span class=\"line\">        options.listeners,</span><br><span class=\"line\">        vnode,</span><br><span class=\"line\">        options.children</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patchVnode</span>(<span class=\"params\">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patch</span>(<span class=\"params\">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">vnode, hydrating</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        vm._update(vm._render(), hydrating);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAndInvoke</span>(<span class=\"params\">cb</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flushSchedulerQueue</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flushCallbacks</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用栈实际上有点冗长，不过我们还是能发现两个有用的信息：</p>\n<ul>\n<li>初始化阶段为 <code>undefined</code> 的 <code>vm</code>，就是 <code>componentInstance</code>，也就是和 destroy 阶段的报错属于同一个原因。</li>\n<li>根据调用栈发现，这是一个更新阶段的报错。</li>\n</ul>\n<p>这引发了我们的思考：更新阶段找不到 <code>componentInstance</code> 报错。</p>\n<p>这里实际上有点阻塞了，因为一般来说，Vue 的源代码经过测试，应该不会出现这种问题的，那是不是我们的问题呢，我们回归到业务代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">created</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.getFeedsListFromCache();</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getFeedsListFromCache</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        viola.requireAPI(<span class=\"string\">&quot;cache&quot;</span>).getItem(<span class=\"built_in\">this</span>.cacheKey_feeds, <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.processData(data.list);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">processData</span>(<span class=\"params\">list = [], opt = &#123;&#125;</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.list.length &lt; cacehFeedsLength) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.list = [];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们对业务代码进行了抽象简化，上面是我们的最小问题 Demo，实际上我们就做了这样一件事情：</p>\n<ul>\n<li>在 created 执行方法，调用端的接口，再回调函数里面更新某个 data 中声明的数据。</li>\n</ul>\n<p>首先，我们可以梳理下对一般 vue 组件的初始化更新，vue 是如何做的：</p>\n<ul>\n<li>created 时实际上 vnode 已经建立完成，这个时候还没有 mount，但是数据监听已经建立了，这个时候如果改动数据，会把相关 update 函数放在一个名为 flushCallbacks 的函数队列中。</li>\n<li>该函数队列会通过默认为 <code>Promise.then</code> 的 microtask 方式来调度，当前阶段的 mount 流程会继续，mount 结束后，会执行 flushCallbacks 队列中的更新操作。</li>\n</ul>\n<p>从代码层面上来讲，这几个流程应该是这样的：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">created</span>&#x27;)</span>; <span class=\"comment\">// 执行created 钩子</span></span><br><span class=\"line\">├── proxy<span class=\"constructor\">Setter(<span class=\"params\">val</span>)</span>; <span class=\"comment\">// 改变数据，调用 proxy</span></span><br><span class=\"line\">├── <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Watcher</span>.</span></span>prototype.update; <span class=\"comment\">// 调用 Watcher，将 update 操作入栈</span></span><br><span class=\"line\">├── vm.<span class=\"constructor\">$mount(<span class=\"params\">vm</span>.$<span class=\"params\">options</span>.<span class=\"params\">el</span>)</span>; <span class=\"comment\">// 执行 mount 流程</span></span><br><span class=\"line\">├── call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">beforeMount</span>&#x27;)</span>;</span><br><span class=\"line\">├──  call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">mounted</span>&#x27;)</span>; <span class=\"comment\">// 依次调用 beforeMount 和 mounted</span></span><br><span class=\"line\">└── flushCallbacks <span class=\"comment\">// 执行 更新</span></span><br></pre></td></tr></table></figure>\n\n<p>然后我们分析我们这里的流程，首先值得强调的是这个函数 <code>viola.requireAPI(&quot;cache&quot;).getItem</code>，这个函数是端注入的函数，但我们不能将其当作异步函数来对待，实际上，<strong>这是一个同步函数</strong>，（至于这个同步函数和 js 中的普通函数，是否有区别，还有待商榷，不过应该是有区别的，因为如果我们不用此函数的话，就不会出现该问题。）</p>\n<p>接下来，我们打出详细的调用栈，根据顺序来分析实际的执行流程：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">created</span>&#x27;)</span>; <span class=\"comment\">// 执行created 钩子</span></span><br><span class=\"line\">├── proxy<span class=\"constructor\">Setter(<span class=\"params\">val</span>)</span>; <span class=\"comment\">// 改变数据，调用 proxy</span></span><br><span class=\"line\">├── <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Watcher</span>.</span></span>prototype.update; <span class=\"comment\">// 调用 Watcher，将 update 操作入栈</span></span><br><span class=\"line\">├── flushCallbacks <span class=\"comment\">// 执行 更新</span></span><br><span class=\"line\">├── vm.<span class=\"constructor\">$mount(<span class=\"params\">vm</span>.$<span class=\"params\">options</span>.<span class=\"params\">el</span>)</span>; <span class=\"comment\">// 执行 mount 流程 </span></span><br><span class=\"line\">├── call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">beforeMount</span>&#x27;)</span>;</span><br><span class=\"line\">└── call<span class=\"constructor\">Hook(<span class=\"params\">vm</span>, &#x27;<span class=\"params\">mounted</span>&#x27;)</span>; <span class=\"comment\">// 依次调用 beforeMount 和 mounted</span></span><br></pre></td></tr></table></figure>\n\n<p>我们发现，我们的执行流程出现了很大问题：<strong>在 mount 阶段未完成的时候就执行了 flushCallbacks，先执行更新操作，这里的顺序错乱导致了后续问题</strong>。</p>\n<p>我们可看下调用 <code>flushCallbacks</code> 的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Promise</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class=\"built_in\">Promise</span>)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">  microTimerFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    p.then(flushCallbacks);</span><br><span class=\"line\">    <span class=\"comment\">// in problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class=\"line\">    <span class=\"comment\">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class=\"line\">    <span class=\"comment\">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class=\"line\">    <span class=\"comment\">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class=\"line\">    <span class=\"comment\">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isIOS) &#123; <span class=\"built_in\">setTimeout</span>(noop); &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>这里 <code>microTimerFunc</code> 的 <code>p.then</code>，被同步执行了，也就是说，这里的微任务优先于当前事件循环的函数执行了（此时由于 mount 流程是同步的，mount 流程的相关函数<strong>理应</strong>在该事件循环中，优先于微任务执行）。</p>\n<p>我们找到了根源，接下来就是分析解决方案和根本原因。</p>\n<p>由于我们的问题在于 update 流程执行太快了，所以采用一种方式放慢一点即可：</p>\n<ul>\n<li>将 vue 的微任务模式（默认）改成宏任务模式：<code>var useMacroTask = false; =&gt; true</code>。</li>\n<li>在 created 阶段的加一个 <code>setTimeout(0)</code>。</li>\n</ul>\n<p>不过对于根本原因，实际上本次仍然没有完全分析透彻，还留有如下疑问：</p>\n<ul>\n<li><code>viola.requireAPI(&quot;cache&quot;).getItem</code> 这个函数到底做了什么？其对事件循环有什么影响？</li>\n<li>在执行 <code>microTimerFunc</code> 的时候，为什么 <code>p.then</code> 优先于 <code>vm.$mount</code> 执行了？</li>\n<li>该错误仅在 iOS 系统出现，iOS 系统是否会在某些情况将微任务的优先级变高？</li>\n</ul>\n<p>对于这些疑问，Vue 源代码中也做了一些评论：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Here we have async deferring wrappers using both microtasks and (macro) tasks.</span><br><span class=\"line\"><span class=\"regexp\">//</span> In &lt; <span class=\"number\">2.4</span> we used microtasks everywhere, but there are some scenarios where</span><br><span class=\"line\"><span class=\"regexp\">//</span> microtasks have too high a priority and fire <span class=\"keyword\">in</span> between supposedly</span><br><span class=\"line\"><span class=\"regexp\">//</span> sequential events (e.g. <span class=\"comment\">#4521, #6690) or even between bubbling of the same</span></span><br><span class=\"line\"><span class=\"regexp\">//</span> event (<span class=\"comment\">#6566). However, using (macro) tasks everywhere also has subtle problems</span></span><br><span class=\"line\"><span class=\"regexp\">//</span> when state is changed right before repaint (e.g. <span class=\"comment\">#6813, out-in transitions).</span></span><br><span class=\"line\"><span class=\"regexp\">//</span> Here we use microtask by default, but expose a way to force (macro) task when</span><br><span class=\"line\"><span class=\"regexp\">//</span> needed (e.g. <span class=\"keyword\">in</span> event handlers attached by v-on).</span><br></pre></td></tr></table></figure>\n\n<p>不过，这里始终都没有找到最本质的原因，也许这和 iOS JSCore 的微任务/宏任务的处理机制有关，具体原因，待下次探究。</p>\n"},{"title":"深入浏览器web渲染与优化","abbrlink":878026877,"date":"2017-08-27T09:37:22.000Z","_content":">本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。\n\n文章主要分为以下几个部分：\n\n* blink内核的渲染机制\n* chrome内核架构变迁\n* 分层渲染\n* 动画 & canvas & WebGl\n\n*这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分*\n\n### blink内核的渲染机制\n\nblink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。\n\n一个页面的显示，实际上主要经历了下面的四个流程：\n\n加载 => 解析 => 排版 => 渲染\n\n实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。\n\n![](https://www.10000h.top/images/data_img/webRender/P6.PNG)\n\n目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：\n\n* 浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。\n* 处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。\n* 之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。\n\n以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。\n\n另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。\n\n绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：\n\n* 硬件加速合成上屏\n* 2D Canvas、Video的硬件加速\n* GPU光栅化\n\t* GPU光栅化速度更快，内存和CPU的消耗更少\n\t* 目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化\n\t* GPU光栅化是未来趋势\n\n\n### chrome内核架构变迁\n\n在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P1.PNG)\n\n早期的chrome的架构实际上有以下缺点：\n\n* Renderer线程任务繁重\n* 无法实时响应缩放滑动操作\n* 脏区域与滑动重绘区域有冲突\n\t* 这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突\n\n当然，经过一系列的发展，Chrome现在是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P2.PNG)\n\n在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)\n\n![](https://www.10000h.top/images/data_img/webRender/P3.PNG)\n\n当然，这种架构也有如下缺点：\n\n* UI线程过于繁忙\n* 无法支持Canvas的硬件加速以及WebGL\n\n所以，后期发展成了这样：\n\n![](https://www.10000h.top/images/data_img/webRender/P4.PNG)\n\n总结看来，内核发展的趋势是：\n\n* 多线程化(可以充分利用多核心CPU)\n* 硬件加速(可以利用GPU)\n\n### 分层渲染\n\n在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：\n\n>打开Chrome浏览器，打开控制台，找到\"Layers\"，如果没有，那么在控制台右上角更多的图标->More tools 找到\"Layers\"，然后随便找个网页打开即可\n\n网页的分层渲染流程主要是下面这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P7.PNG)\n\n(*注意：多个RenderObject可能又会对应一个或多个RenderLayer*)\n\n既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：\n\n* 减少不必要的重新绘制\n* 可以实现较为复杂的动画\n* 能够方便实现复杂的CSS样式\n\n当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：\n\n* 如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。\n* 如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。\n* 如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。\n\n那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。\n\n```\n//注:Chrome中符合创建新层的情况：\nLayer has 3D or perspective transform CSS properties(有3D元素的属性)\nLayer is used by <video> element using accelerated video decoding(video标签并使用加速视频解码)\nLayer is used by a <canvas> element with a 3D context or accelerated 2D context(canvas元素并启用3D)\nLayer is used for a composited plugin(插件，比如flash)\nLayer uses a CSS animation for its opacity or uses an animated webkit transform(CSS动画)\nLayer uses accelerated CSS filters(CSS滤镜)\nLayer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection(有一个后代元素是独立的layer)\nLayer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)(元素的相邻元素是独立layer)\n```\n\n最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：\n\n* 相对位置会发生变化的元素需要分层(比如banner图、滚动条)\n* 元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)\n* 较长较大的页面注意总的分层个数\n* 避免某一块区域分层过多，面积过大\n\n(*如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)*)\n\n另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。\n\n最后再提出一个小问题：\n\n以下哪种渲染方式是最优的呢？\n\n![](https://www.10000h.top/images/data_img/webRender/P8.PNG)\n\n这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。\n\n### 动画 & canvas & WebGl\n\n讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?\n\n对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P9.PNG)\n\n所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)\n\n另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿\n以下是一些不会触发重绘或者排版的CSS动画属性：\n\n* cursor\n* font-variant\n* opacity\n* orphans\n* perspective\n* perspecti-origin\n* pointer-events\n* transform\n* transform-style\n* widows\n\n想要了解更多内容，可以参考[这里](https://csstriggers.com/)\n\n这方面最终的建议参考如下：\n\n* 尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等\n* 动画一定要避免触发大量元素重新排版或者大面积重绘\n* 在有动画执行时，避免其他动画不相关因素引起排版和重绘\n\n\n#### requestAnimationFrame\n\n另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：\n\n![](https://www.10000h.top/images/data_img/webRender/P11.PNG)\n\n### 3D canvas\n\n还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、\n\n这个时候该怎么办呢？\n\n2D canvas上场。 \n\n和CSS动画相比，2D canvas的优点是这样的：\n\n* 硬件加速渲染\n* 渲染流程更优\n\n其渲染流程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P10.PNG)\n\n实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。\n\nHTML 2D canvas 主要绘制如下三种元素：\n\n* 图片\n* 文字\n* 矢量\n\n这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P12.PNG)\n\n硬件加速文字绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P13.PNG)\n\n但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。\n\n对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(**所以建议是，我们如果能使用贴图就尽量使用贴图了**)\n\n还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。\n\n### 3D canvas(WebGL)\n\n目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:\n\n\n* 通用引擎：threeJS、Pixi\n* VR视频的专业引擎：krpano、UtoVR\n* H5游戏引擎：Egret、Layabox、Cocos\n\nWebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。\n\nX5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。\n\n___\n\n本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。\n\n其他优质好文：\n\n[Javascript高性能动画与页面渲染](http://qingbob.com/javascript-high-performance-animation-and-page-rendering/)\n\n\n","source":"_posts/深入浏览器web渲染与优化.md","raw":"---\ntitle: 深入浏览器web渲染与优化\ntags:\n  - 性能优化\nabbrlink: 878026877\ndate: 2017-08-27 17:37:22\n---\n>本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。\n\n文章主要分为以下几个部分：\n\n* blink内核的渲染机制\n* chrome内核架构变迁\n* 分层渲染\n* 动画 & canvas & WebGl\n\n*这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分*\n\n### blink内核的渲染机制\n\nblink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。\n\n一个页面的显示，实际上主要经历了下面的四个流程：\n\n加载 => 解析 => 排版 => 渲染\n\n实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。\n\n![](https://www.10000h.top/images/data_img/webRender/P6.PNG)\n\n目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：\n\n* 浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。\n* 处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。\n* 之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。\n\n以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。\n\n另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。\n\n绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：\n\n* 硬件加速合成上屏\n* 2D Canvas、Video的硬件加速\n* GPU光栅化\n\t* GPU光栅化速度更快，内存和CPU的消耗更少\n\t* 目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化\n\t* GPU光栅化是未来趋势\n\n\n### chrome内核架构变迁\n\n在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P1.PNG)\n\n早期的chrome的架构实际上有以下缺点：\n\n* Renderer线程任务繁重\n* 无法实时响应缩放滑动操作\n* 脏区域与滑动重绘区域有冲突\n\t* 这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突\n\n当然，经过一系列的发展，Chrome现在是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P2.PNG)\n\n在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)\n\n![](https://www.10000h.top/images/data_img/webRender/P3.PNG)\n\n当然，这种架构也有如下缺点：\n\n* UI线程过于繁忙\n* 无法支持Canvas的硬件加速以及WebGL\n\n所以，后期发展成了这样：\n\n![](https://www.10000h.top/images/data_img/webRender/P4.PNG)\n\n总结看来，内核发展的趋势是：\n\n* 多线程化(可以充分利用多核心CPU)\n* 硬件加速(可以利用GPU)\n\n### 分层渲染\n\n在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：\n\n>打开Chrome浏览器，打开控制台，找到\"Layers\"，如果没有，那么在控制台右上角更多的图标->More tools 找到\"Layers\"，然后随便找个网页打开即可\n\n网页的分层渲染流程主要是下面这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P7.PNG)\n\n(*注意：多个RenderObject可能又会对应一个或多个RenderLayer*)\n\n既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：\n\n* 减少不必要的重新绘制\n* 可以实现较为复杂的动画\n* 能够方便实现复杂的CSS样式\n\n当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：\n\n* 如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。\n* 如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。\n* 如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。\n\n那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。\n\n```\n//注:Chrome中符合创建新层的情况：\nLayer has 3D or perspective transform CSS properties(有3D元素的属性)\nLayer is used by <video> element using accelerated video decoding(video标签并使用加速视频解码)\nLayer is used by a <canvas> element with a 3D context or accelerated 2D context(canvas元素并启用3D)\nLayer is used for a composited plugin(插件，比如flash)\nLayer uses a CSS animation for its opacity or uses an animated webkit transform(CSS动画)\nLayer uses accelerated CSS filters(CSS滤镜)\nLayer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection(有一个后代元素是独立的layer)\nLayer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)(元素的相邻元素是独立layer)\n```\n\n最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：\n\n* 相对位置会发生变化的元素需要分层(比如banner图、滚动条)\n* 元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)\n* 较长较大的页面注意总的分层个数\n* 避免某一块区域分层过多，面积过大\n\n(*如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)*)\n\n另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。\n\n最后再提出一个小问题：\n\n以下哪种渲染方式是最优的呢？\n\n![](https://www.10000h.top/images/data_img/webRender/P8.PNG)\n\n这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。\n\n### 动画 & canvas & WebGl\n\n讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?\n\n对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P9.PNG)\n\n所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)\n\n另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿\n以下是一些不会触发重绘或者排版的CSS动画属性：\n\n* cursor\n* font-variant\n* opacity\n* orphans\n* perspective\n* perspecti-origin\n* pointer-events\n* transform\n* transform-style\n* widows\n\n想要了解更多内容，可以参考[这里](https://csstriggers.com/)\n\n这方面最终的建议参考如下：\n\n* 尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等\n* 动画一定要避免触发大量元素重新排版或者大面积重绘\n* 在有动画执行时，避免其他动画不相关因素引起排版和重绘\n\n\n#### requestAnimationFrame\n\n另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：\n\n![](https://www.10000h.top/images/data_img/webRender/P11.PNG)\n\n### 3D canvas\n\n还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、\n\n这个时候该怎么办呢？\n\n2D canvas上场。 \n\n和CSS动画相比，2D canvas的优点是这样的：\n\n* 硬件加速渲染\n* 渲染流程更优\n\n其渲染流程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P10.PNG)\n\n实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。\n\nHTML 2D canvas 主要绘制如下三种元素：\n\n* 图片\n* 文字\n* 矢量\n\n这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P12.PNG)\n\n硬件加速文字绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P13.PNG)\n\n但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。\n\n对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(**所以建议是，我们如果能使用贴图就尽量使用贴图了**)\n\n还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。\n\n### 3D canvas(WebGL)\n\n目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:\n\n\n* 通用引擎：threeJS、Pixi\n* VR视频的专业引擎：krpano、UtoVR\n* H5游戏引擎：Egret、Layabox、Cocos\n\nWebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。\n\nX5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。\n\n___\n\n本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。\n\n其他优质好文：\n\n[Javascript高性能动画与页面渲染](http://qingbob.com/javascript-high-performance-animation-and-page-rendering/)\n\n\n","slug":"深入浏览器web渲染与优化","published":1,"updated":"2021-12-23T05:50:07.551Z","_id":"ckxijpqt5001dd3mrbmrndyrj","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。</p>\n</blockquote>\n<p>文章主要分为以下几个部分：</p>\n<ul>\n<li>blink内核的渲染机制</li>\n<li>chrome内核架构变迁</li>\n<li>分层渲染</li>\n<li>动画 &amp; canvas &amp; WebGl</li>\n</ul>\n<p><em>这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分</em></p>\n<h3 id=\"blink内核的渲染机制\"><a href=\"#blink内核的渲染机制\" class=\"headerlink\" title=\"blink内核的渲染机制\"></a>blink内核的渲染机制</h3><p>blink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。</p>\n<p>一个页面的显示，实际上主要经历了下面的四个流程：</p>\n<p>加载 =&gt; 解析 =&gt; 排版 =&gt; 渲染</p>\n<p>实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P6.PNG\"></p>\n<p>目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：</p>\n<ul>\n<li>浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。</li>\n<li>处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。</li>\n<li>之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。</li>\n</ul>\n<p>以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。</p>\n<p>另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。</p>\n<p>绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：</p>\n<ul>\n<li>硬件加速合成上屏</li>\n<li>2D Canvas、Video的硬件加速</li>\n<li>GPU光栅化<ul>\n<li>GPU光栅化速度更快，内存和CPU的消耗更少</li>\n<li>目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化</li>\n<li>GPU光栅化是未来趋势</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"chrome内核架构变迁\"><a href=\"#chrome内核架构变迁\" class=\"headerlink\" title=\"chrome内核架构变迁\"></a>chrome内核架构变迁</h3><p>在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P1.PNG\"></p>\n<p>早期的chrome的架构实际上有以下缺点：</p>\n<ul>\n<li>Renderer线程任务繁重</li>\n<li>无法实时响应缩放滑动操作</li>\n<li>脏区域与滑动重绘区域有冲突<ul>\n<li>这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突</li>\n</ul>\n</li>\n</ul>\n<p>当然，经过一系列的发展，Chrome现在是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P2.PNG\"></p>\n<p>在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P3.PNG\"></p>\n<p>当然，这种架构也有如下缺点：</p>\n<ul>\n<li>UI线程过于繁忙</li>\n<li>无法支持Canvas的硬件加速以及WebGL</li>\n</ul>\n<p>所以，后期发展成了这样：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P4.PNG\"></p>\n<p>总结看来，内核发展的趋势是：</p>\n<ul>\n<li>多线程化(可以充分利用多核心CPU)</li>\n<li>硬件加速(可以利用GPU)</li>\n</ul>\n<h3 id=\"分层渲染\"><a href=\"#分层渲染\" class=\"headerlink\" title=\"分层渲染\"></a>分层渲染</h3><p>在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：</p>\n<blockquote>\n<p>打开Chrome浏览器，打开控制台，找到”Layers”，如果没有，那么在控制台右上角更多的图标-&gt;More tools 找到”Layers”，然后随便找个网页打开即可</p>\n</blockquote>\n<p>网页的分层渲染流程主要是下面这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P7.PNG\"></p>\n<p>(<em>注意：多个RenderObject可能又会对应一个或多个RenderLayer</em>)</p>\n<p>既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：</p>\n<ul>\n<li>减少不必要的重新绘制</li>\n<li>可以实现较为复杂的动画</li>\n<li>能够方便实现复杂的CSS样式</li>\n</ul>\n<p>当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：</p>\n<ul>\n<li>如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。</li>\n<li>如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。</li>\n<li>如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。</li>\n</ul>\n<p>那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注:Chrome中符合创建新层的情况：</span><br><span class=\"line\">Layer has <span class=\"number\">3</span>D <span class=\"keyword\">or</span> perspective transform CSS properties(有<span class=\"number\">3</span>D元素的属性)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> &lt;video&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">using</span> accelerated video decoding(video标签并使用加速视频解码)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> <span class=\"keyword\">a</span> &lt;canvas&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"number\">3</span>D context <span class=\"keyword\">or</span> accelerated <span class=\"number\">2</span>D context(canvas元素并启用<span class=\"number\">3</span>D)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">for</span> <span class=\"keyword\">a</span> composited plugin(插件，比如flash)</span><br><span class=\"line\">Layer uses <span class=\"keyword\">a</span> CSS animation <span class=\"keyword\">for</span> its opacity <span class=\"keyword\">or</span> uses <span class=\"keyword\">an</span> animated webkit transform(CSS动画)</span><br><span class=\"line\">Layer uses accelerated CSS filters(CSS滤镜)</span><br><span class=\"line\">Layer <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> composited descendant has information that needs <span class=\"built_in\">to</span> be <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> composited layer tree, such <span class=\"keyword\">as</span> <span class=\"keyword\">a</span> clip <span class=\"keyword\">or</span> reflection(有一个后代元素是独立的layer)</span><br><span class=\"line\">Layer has <span class=\"keyword\">a</span> sibling <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"built_in\">lower</span> z-index which has <span class=\"keyword\">a</span> compositing layer (<span class=\"keyword\">in</span> other <span class=\"keyword\">words</span> <span class=\"keyword\">the</span> layer is rendered <span class=\"keyword\">on</span> <span class=\"title\">top</span> <span class=\"title\">of</span> <span class=\"title\">a</span> <span class=\"title\">composited</span> <span class=\"title\">layer</span>)(元素的相邻元素是独立<span class=\"title\">layer</span>)</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：</p>\n<ul>\n<li>相对位置会发生变化的元素需要分层(比如banner图、滚动条)</li>\n<li>元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)</li>\n<li>较长较大的页面注意总的分层个数</li>\n<li>避免某一块区域分层过多，面积过大</li>\n</ul>\n<p>(<em>如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)</em>)</p>\n<p>另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。</p>\n<p>最后再提出一个小问题：</p>\n<p>以下哪种渲染方式是最优的呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P8.PNG\"></p>\n<p>这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。</p>\n<h3 id=\"动画-amp-canvas-amp-WebGl\"><a href=\"#动画-amp-canvas-amp-WebGl\" class=\"headerlink\" title=\"动画 &amp; canvas &amp; WebGl\"></a>动画 &amp; canvas &amp; WebGl</h3><p>讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?</p>\n<p>对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P9.PNG\"></p>\n<p>所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)</p>\n<p>另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿<br>以下是一些不会触发重绘或者排版的CSS动画属性：</p>\n<ul>\n<li>cursor</li>\n<li>font-variant</li>\n<li>opacity</li>\n<li>orphans</li>\n<li>perspective</li>\n<li>perspecti-origin</li>\n<li>pointer-events</li>\n<li>transform</li>\n<li>transform-style</li>\n<li>widows</li>\n</ul>\n<p>想要了解更多内容，可以参考<a href=\"https://csstriggers.com/\">这里</a></p>\n<p>这方面最终的建议参考如下：</p>\n<ul>\n<li>尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等</li>\n<li>动画一定要避免触发大量元素重新排版或者大面积重绘</li>\n<li>在有动画执行时，避免其他动画不相关因素引起排版和重绘</li>\n</ul>\n<h4 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h4><p>另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P11.PNG\"></p>\n<h3 id=\"3D-canvas\"><a href=\"#3D-canvas\" class=\"headerlink\" title=\"3D canvas\"></a>3D canvas</h3><p>还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、</p>\n<p>这个时候该怎么办呢？</p>\n<p>2D canvas上场。 </p>\n<p>和CSS动画相比，2D canvas的优点是这样的：</p>\n<ul>\n<li>硬件加速渲染</li>\n<li>渲染流程更优</li>\n</ul>\n<p>其渲染流程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P10.PNG\"></p>\n<p>实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。</p>\n<p>HTML 2D canvas 主要绘制如下三种元素：</p>\n<ul>\n<li>图片</li>\n<li>文字</li>\n<li>矢量</li>\n</ul>\n<p>这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P12.PNG\"></p>\n<p>硬件加速文字绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P13.PNG\"></p>\n<p>但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。</p>\n<p>对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(<strong>所以建议是，我们如果能使用贴图就尽量使用贴图了</strong>)</p>\n<p>还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。</p>\n<h3 id=\"3D-canvas-WebGL\"><a href=\"#3D-canvas-WebGL\" class=\"headerlink\" title=\"3D canvas(WebGL)\"></a>3D canvas(WebGL)</h3><p>目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:</p>\n<ul>\n<li>通用引擎：threeJS、Pixi</li>\n<li>VR视频的专业引擎：krpano、UtoVR</li>\n<li>H5游戏引擎：Egret、Layabox、Cocos</li>\n</ul>\n<p>WebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。</p>\n<p>X5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。</p>\n<hr>\n<p>本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。</p>\n<p>其他优质好文：</p>\n<p><a href=\"http://qingbob.com/javascript-high-performance-animation-and-page-rendering/\">Javascript高性能动画与页面渲染</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。</p>\n</blockquote>\n<p>文章主要分为以下几个部分：</p>\n<ul>\n<li>blink内核的渲染机制</li>\n<li>chrome内核架构变迁</li>\n<li>分层渲染</li>\n<li>动画 &amp; canvas &amp; WebGl</li>\n</ul>\n<p><em>这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分</em></p>\n<h3 id=\"blink内核的渲染机制\"><a href=\"#blink内核的渲染机制\" class=\"headerlink\" title=\"blink内核的渲染机制\"></a>blink内核的渲染机制</h3><p>blink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。</p>\n<p>一个页面的显示，实际上主要经历了下面的四个流程：</p>\n<p>加载 =&gt; 解析 =&gt; 排版 =&gt; 渲染</p>\n<p>实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P6.PNG\"></p>\n<p>目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：</p>\n<ul>\n<li>浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。</li>\n<li>处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。</li>\n<li>之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。</li>\n</ul>\n<p>以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。</p>\n<p>另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。</p>\n<p>绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：</p>\n<ul>\n<li>硬件加速合成上屏</li>\n<li>2D Canvas、Video的硬件加速</li>\n<li>GPU光栅化<ul>\n<li>GPU光栅化速度更快，内存和CPU的消耗更少</li>\n<li>目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化</li>\n<li>GPU光栅化是未来趋势</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"chrome内核架构变迁\"><a href=\"#chrome内核架构变迁\" class=\"headerlink\" title=\"chrome内核架构变迁\"></a>chrome内核架构变迁</h3><p>在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P1.PNG\"></p>\n<p>早期的chrome的架构实际上有以下缺点：</p>\n<ul>\n<li>Renderer线程任务繁重</li>\n<li>无法实时响应缩放滑动操作</li>\n<li>脏区域与滑动重绘区域有冲突<ul>\n<li>这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突</li>\n</ul>\n</li>\n</ul>\n<p>当然，经过一系列的发展，Chrome现在是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P2.PNG\"></p>\n<p>在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P3.PNG\"></p>\n<p>当然，这种架构也有如下缺点：</p>\n<ul>\n<li>UI线程过于繁忙</li>\n<li>无法支持Canvas的硬件加速以及WebGL</li>\n</ul>\n<p>所以，后期发展成了这样：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P4.PNG\"></p>\n<p>总结看来，内核发展的趋势是：</p>\n<ul>\n<li>多线程化(可以充分利用多核心CPU)</li>\n<li>硬件加速(可以利用GPU)</li>\n</ul>\n<h3 id=\"分层渲染\"><a href=\"#分层渲染\" class=\"headerlink\" title=\"分层渲染\"></a>分层渲染</h3><p>在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：</p>\n<blockquote>\n<p>打开Chrome浏览器，打开控制台，找到”Layers”，如果没有，那么在控制台右上角更多的图标-&gt;More tools 找到”Layers”，然后随便找个网页打开即可</p>\n</blockquote>\n<p>网页的分层渲染流程主要是下面这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P7.PNG\"></p>\n<p>(<em>注意：多个RenderObject可能又会对应一个或多个RenderLayer</em>)</p>\n<p>既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：</p>\n<ul>\n<li>减少不必要的重新绘制</li>\n<li>可以实现较为复杂的动画</li>\n<li>能够方便实现复杂的CSS样式</li>\n</ul>\n<p>当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：</p>\n<ul>\n<li>如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。</li>\n<li>如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。</li>\n<li>如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。</li>\n</ul>\n<p>那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注:Chrome中符合创建新层的情况：</span><br><span class=\"line\">Layer has <span class=\"number\">3</span>D <span class=\"keyword\">or</span> perspective transform CSS properties(有<span class=\"number\">3</span>D元素的属性)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> &lt;video&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">using</span> accelerated video decoding(video标签并使用加速视频解码)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> <span class=\"keyword\">a</span> &lt;canvas&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"number\">3</span>D context <span class=\"keyword\">or</span> accelerated <span class=\"number\">2</span>D context(canvas元素并启用<span class=\"number\">3</span>D)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">for</span> <span class=\"keyword\">a</span> composited plugin(插件，比如flash)</span><br><span class=\"line\">Layer uses <span class=\"keyword\">a</span> CSS animation <span class=\"keyword\">for</span> its opacity <span class=\"keyword\">or</span> uses <span class=\"keyword\">an</span> animated webkit transform(CSS动画)</span><br><span class=\"line\">Layer uses accelerated CSS filters(CSS滤镜)</span><br><span class=\"line\">Layer <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> composited descendant has information that needs <span class=\"built_in\">to</span> be <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> composited layer tree, such <span class=\"keyword\">as</span> <span class=\"keyword\">a</span> clip <span class=\"keyword\">or</span> reflection(有一个后代元素是独立的layer)</span><br><span class=\"line\">Layer has <span class=\"keyword\">a</span> sibling <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"built_in\">lower</span> z-index which has <span class=\"keyword\">a</span> compositing layer (<span class=\"keyword\">in</span> other <span class=\"keyword\">words</span> <span class=\"keyword\">the</span> layer is rendered <span class=\"keyword\">on</span> <span class=\"title\">top</span> <span class=\"title\">of</span> <span class=\"title\">a</span> <span class=\"title\">composited</span> <span class=\"title\">layer</span>)(元素的相邻元素是独立<span class=\"title\">layer</span>)</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：</p>\n<ul>\n<li>相对位置会发生变化的元素需要分层(比如banner图、滚动条)</li>\n<li>元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)</li>\n<li>较长较大的页面注意总的分层个数</li>\n<li>避免某一块区域分层过多，面积过大</li>\n</ul>\n<p>(<em>如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)</em>)</p>\n<p>另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。</p>\n<p>最后再提出一个小问题：</p>\n<p>以下哪种渲染方式是最优的呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P8.PNG\"></p>\n<p>这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。</p>\n<h3 id=\"动画-amp-canvas-amp-WebGl\"><a href=\"#动画-amp-canvas-amp-WebGl\" class=\"headerlink\" title=\"动画 &amp; canvas &amp; WebGl\"></a>动画 &amp; canvas &amp; WebGl</h3><p>讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?</p>\n<p>对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P9.PNG\"></p>\n<p>所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)</p>\n<p>另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿<br>以下是一些不会触发重绘或者排版的CSS动画属性：</p>\n<ul>\n<li>cursor</li>\n<li>font-variant</li>\n<li>opacity</li>\n<li>orphans</li>\n<li>perspective</li>\n<li>perspecti-origin</li>\n<li>pointer-events</li>\n<li>transform</li>\n<li>transform-style</li>\n<li>widows</li>\n</ul>\n<p>想要了解更多内容，可以参考<a href=\"https://csstriggers.com/\">这里</a></p>\n<p>这方面最终的建议参考如下：</p>\n<ul>\n<li>尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等</li>\n<li>动画一定要避免触发大量元素重新排版或者大面积重绘</li>\n<li>在有动画执行时，避免其他动画不相关因素引起排版和重绘</li>\n</ul>\n<h4 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h4><p>另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P11.PNG\"></p>\n<h3 id=\"3D-canvas\"><a href=\"#3D-canvas\" class=\"headerlink\" title=\"3D canvas\"></a>3D canvas</h3><p>还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、</p>\n<p>这个时候该怎么办呢？</p>\n<p>2D canvas上场。 </p>\n<p>和CSS动画相比，2D canvas的优点是这样的：</p>\n<ul>\n<li>硬件加速渲染</li>\n<li>渲染流程更优</li>\n</ul>\n<p>其渲染流程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P10.PNG\"></p>\n<p>实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。</p>\n<p>HTML 2D canvas 主要绘制如下三种元素：</p>\n<ul>\n<li>图片</li>\n<li>文字</li>\n<li>矢量</li>\n</ul>\n<p>这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P12.PNG\"></p>\n<p>硬件加速文字绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P13.PNG\"></p>\n<p>但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。</p>\n<p>对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(<strong>所以建议是，我们如果能使用贴图就尽量使用贴图了</strong>)</p>\n<p>还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。</p>\n<h3 id=\"3D-canvas-WebGL\"><a href=\"#3D-canvas-WebGL\" class=\"headerlink\" title=\"3D canvas(WebGL)\"></a>3D canvas(WebGL)</h3><p>目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:</p>\n<ul>\n<li>通用引擎：threeJS、Pixi</li>\n<li>VR视频的专业引擎：krpano、UtoVR</li>\n<li>H5游戏引擎：Egret、Layabox、Cocos</li>\n</ul>\n<p>WebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。</p>\n<p>X5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。</p>\n<hr>\n<p>本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。</p>\n<p>其他优质好文：</p>\n<p><a href=\"http://qingbob.com/javascript-high-performance-animation-and-page-rendering/\">Javascript高性能动画与页面渲染</a></p>\n"},{"title":"腾讯云北美服务器搭建ShadowSocks代理","abbrlink":1888761498,"date":"2016-08-08T11:15:01.000Z","_content":"\n注：本教程适合centos系列和red hat系列\n\n登陆SSH \n新的VPS可以先升级\n\n```\nyum -y update\n```\n\n有些VPS 没有wget \n这种要先装\n\n```\nyum -y install wget\n```\n\n输入以下命令：（可以复制）\n\n```\nwget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n\n第一行是下载命令，下载东西，第二行是修改权限，第三行是安装命令\n\n下面是按照配置图\n\n```\n配置：\n密码：（默认是teddysun.com）\n端口：默认是8989\n然后按任意键安装，退出按 Ctrl+c\n```\n\n安装完成会有一个配置\n\n```\nCongratulations, shadowsocks install completed!Your Server IP:  ***** VPS的IP地址Your Server Port:  *****  你刚才设置的端口Your Password:  ****  你刚才设置的密码Your Local IP:  127.0.0.1 Your Local Port:  1080 Your Encryption Method:  aes-256-cfb Welcome to visit:https://teddysun.com/342.htmlEnjoy it!\n```\n\n然后即可以使用\n\n卸载方法：\n\n使用 root 用户登录，运行以下命令：\n\n```\n./shadowsocksR.sh uninstall\n```\n\n安装完成后即已后台启动 ShadowsocksR ，运行：\n\n```\n/etc/init.d/shadowsocks status\n```\n","source":"_posts/腾讯云北美服务器搭建ShadowSocks代理.md","raw":"---\ntitle: 腾讯云北美服务器搭建ShadowSocks代理\ntags:\n  - ShadowSocks\nabbrlink: 1888761498\ndate: 2016-08-08 19:15:01\n---\n\n注：本教程适合centos系列和red hat系列\n\n登陆SSH \n新的VPS可以先升级\n\n```\nyum -y update\n```\n\n有些VPS 没有wget \n这种要先装\n\n```\nyum -y install wget\n```\n\n输入以下命令：（可以复制）\n\n```\nwget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n\n第一行是下载命令，下载东西，第二行是修改权限，第三行是安装命令\n\n下面是按照配置图\n\n```\n配置：\n密码：（默认是teddysun.com）\n端口：默认是8989\n然后按任意键安装，退出按 Ctrl+c\n```\n\n安装完成会有一个配置\n\n```\nCongratulations, shadowsocks install completed!Your Server IP:  ***** VPS的IP地址Your Server Port:  *****  你刚才设置的端口Your Password:  ****  你刚才设置的密码Your Local IP:  127.0.0.1 Your Local Port:  1080 Your Encryption Method:  aes-256-cfb Welcome to visit:https://teddysun.com/342.htmlEnjoy it!\n```\n\n然后即可以使用\n\n卸载方法：\n\n使用 root 用户登录，运行以下命令：\n\n```\n./shadowsocksR.sh uninstall\n```\n\n安装完成后即已后台启动 ShadowsocksR ，运行：\n\n```\n/etc/init.d/shadowsocks status\n```\n","slug":"腾讯云北美服务器搭建ShadowSocks代理","published":1,"updated":"2021-12-23T05:50:07.552Z","_id":"ckxijpqt5001fd3mr2m8e7y03","comments":1,"layout":"post","photos":[],"link":"","content":"<p>注：本教程适合centos系列和red hat系列</p>\n<p>登陆SSH<br>新的VPS可以先升级</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">yum -y update</span></span><br></pre></td></tr></table></figure>\n\n<p>有些VPS 没有wget<br>这种要先装</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y <span class=\"keyword\">install</span> wget</span><br></pre></td></tr></table></figure>\n\n<p>输入以下命令：（可以复制）</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --<span class=\"keyword\">no</span>-check-certificate http<span class=\"variable\">s:</span>//raw.githubusercontent.<span class=\"keyword\">com</span>/teddysun/shadowsocks_install/master/shadowsocks.<span class=\"keyword\">sh</span></span><br><span class=\"line\">chmod +<span class=\"keyword\">x</span> shadowsocks.<span class=\"keyword\">sh</span></span><br><span class=\"line\">./shadowsocks.<span class=\"keyword\">sh</span> <span class=\"number\">2</span>&gt;&amp;<span class=\"number\">1</span> | tee shadowsocks.<span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n\n<p>第一行是下载命令，下载东西，第二行是修改权限，第三行是安装命令</p>\n<p>下面是按照配置图</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">配置：</span><br><span class=\"line\">密码：（默认是teddysun.com）</span><br><span class=\"line\">端口：默认是<span class=\"number\">8989</span></span><br><span class=\"line\">然后按任意键安装，退出按 Ctrl+<span class=\"keyword\">c</span></span><br></pre></td></tr></table></figure>\n\n<p>安装完成会有一个配置</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Congratulations, shadowsocks install completed!Your Server IP:  ***** VPS的IP地址Your Server Port:  *****  你刚才设置的端口Your Password:  ****  你刚才设置的密码Your Local IP:  <span class=\"number\">127.0</span>.<span class=\"number\">0.1</span> Your Local Port:  <span class=\"number\">1080</span> Your Encryption <span class=\"function\"><span class=\"keyword\">Method</span>:</span>  aes-<span class=\"number\">256</span>-cfb Welcome <span class=\"keyword\">to</span> visit:https:<span class=\"comment\">//teddysun.com/342.htmlEnjoy it!</span></span><br></pre></td></tr></table></figure>\n\n<p>然后即可以使用</p>\n<p>卸载方法：</p>\n<p>使用 root 用户登录，运行以下命令：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">./shadowsocksR.sh</span> uninstall</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后即已后台启动 ShadowsocksR ，运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/etc/i</span>nit.d/shadowsocks status</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>注：本教程适合centos系列和red hat系列</p>\n<p>登陆SSH<br>新的VPS可以先升级</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">yum -y update</span></span><br></pre></td></tr></table></figure>\n\n<p>有些VPS 没有wget<br>这种要先装</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y <span class=\"keyword\">install</span> wget</span><br></pre></td></tr></table></figure>\n\n<p>输入以下命令：（可以复制）</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --<span class=\"keyword\">no</span>-check-certificate http<span class=\"variable\">s:</span>//raw.githubusercontent.<span class=\"keyword\">com</span>/teddysun/shadowsocks_install/master/shadowsocks.<span class=\"keyword\">sh</span></span><br><span class=\"line\">chmod +<span class=\"keyword\">x</span> shadowsocks.<span class=\"keyword\">sh</span></span><br><span class=\"line\">./shadowsocks.<span class=\"keyword\">sh</span> <span class=\"number\">2</span>&gt;&amp;<span class=\"number\">1</span> | tee shadowsocks.<span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n\n<p>第一行是下载命令，下载东西，第二行是修改权限，第三行是安装命令</p>\n<p>下面是按照配置图</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">配置：</span><br><span class=\"line\">密码：（默认是teddysun.com）</span><br><span class=\"line\">端口：默认是<span class=\"number\">8989</span></span><br><span class=\"line\">然后按任意键安装，退出按 Ctrl+<span class=\"keyword\">c</span></span><br></pre></td></tr></table></figure>\n\n<p>安装完成会有一个配置</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Congratulations, shadowsocks install completed!Your Server IP:  ***** VPS的IP地址Your Server Port:  *****  你刚才设置的端口Your Password:  ****  你刚才设置的密码Your Local IP:  <span class=\"number\">127.0</span>.<span class=\"number\">0.1</span> Your Local Port:  <span class=\"number\">1080</span> Your Encryption <span class=\"function\"><span class=\"keyword\">Method</span>:</span>  aes-<span class=\"number\">256</span>-cfb Welcome <span class=\"keyword\">to</span> visit:https:<span class=\"comment\">//teddysun.com/342.htmlEnjoy it!</span></span><br></pre></td></tr></table></figure>\n\n<p>然后即可以使用</p>\n<p>卸载方法：</p>\n<p>使用 root 用户登录，运行以下命令：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">./shadowsocksR.sh</span> uninstall</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后即已后台启动 ShadowsocksR ，运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/etc/i</span>nit.d/shadowsocks status</span><br></pre></td></tr></table></figure>\n"},{"title":"dva源码解读","abbrlink":1779834361,"date":"2018-04-11T07:07:20.000Z","_content":"\n### 声明\n\n本文章用于个人学习研究，并不代表 dva 团队的任何观点。\n\n原文以及包含一定注释的代码见[这里](https://github.com/aircloud/dva-analysis)，若有问题也可以在[这里](https://github.com/aircloud/dva-analysis/issues)进行讨论\n\n### 起步\n\n#### 为什么是dva?\n\n笔者对 dva 的源代码进行解读，主要考虑到 dva 并不是一个和我们熟知的主流技术无关的从0到1的框架，相反，它是对主流技术进行整合，提炼，从而形成一种最佳实践，分析 dva，意味着我们可以对自己掌握的很多相关技术进行回顾，另外，dva 的代码量并不多，也不至于晦涩难懂，可以给我们平时的业务开发以启发。\n\n本文章作为 dva 的源码解读文章，并不面向新手用户，读者应当有一定的 react 使用经验和 ECMAscript 2015+ 的使用经验，并且应当了解 redux 和 redux-saga，以及对 dva 的使用有所了解(可以从[这里](https://github.com/dvajs/dva/blob/master/README_zh-CN.md#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-dva-)了解为什么需要使用 dva)\n\n重点推荐:\n\n* 通过[这里](https://github.com/dvajs/dva-knowledgemap)的内容了解使用dva的最小知识集\n* 通过[这里](https://redux-saga-in-chinese.js.org/docs/introduction/index.html)学习 redux-saga\n\n其他推荐：\n\n* [dva的概念](https://github.com/dvajs/dva/blob/master/docs/Concepts_zh-CN.md)\n* [dva的全部API](https://github.com/dvajs/dva/blob/master/docs/API_zh-CN.md)\n* [React+Redux 最佳实践](https://github.com/sorrycc/blog/issues/1)\n* [React在蚂蚁金服的实践](http://slides.com/sorrycc/dva#/)\n* [dva 2.0的改进](https://github.com/sorrycc/blog/issues/48)\n* [ReSelect介绍](http://cn.redux.js.org/docs/recipes/ComputingDerivedData.html)\n* [浅析Redux 的 store enhancer](https://www.jianshu.com/p/04d3fefea8d7)\n\n\n几个 dva 版本之间的关系:\n\n* dva@2.0：基于 react 和 react-router@4\n* dva-react-router-3@1.0：基于 react 和 react-router@3\n* dva-no-router@1.0：无路由版本，适用于多页面场景，可以和 next.js 组合使用\n* dva-core@1.0：仅封装了 redux 和 redux-saga\n\n我们本次主要分析目标为 dva@2.0 和 dva-core@1.0\n\n\n### 我们为什么需要 redux-saga\n\n目前，在大多数项目开发中，我们现在依然采用的是redux-thunk + async/await (或 Promise)。\n\n实际上这个十几行的插件已经完全可以解决大多是场景下的问题了，如果你在目前的工作中正在使用这一套方案并且能够完全将当下的需求应付自如并且没有什么凌乱的地方，其实也是没有必要换成redux-saga的。\n\n接下来我们讲 redux-saga，先看名字：saga，这个术语常用于CQRS架构，代表查询与责任分离。\n\n相比于 redux-thunk，前者通常是把数据查询等请求放在 actions 中(不纯净的 actions)，并且这些 actions 可以继续回调调用其他 actions(纯净的 actions)，从而完成数据的更新；而 redux-saga，则保持了 actions 的纯粹性，单独抽出一层专门来处理数据请求等操作(saga函数)。\n\n这样做还有另外一些好处：\n\n* 由于我们已经将数据处理数据请求等异步操作抽离出来了，并且通过 generator 来处理，我们便可以方便地进行多种异步管理：比如同时按顺序执行多个任务、在多个异步任务中启动race等。\n* 这样做可以延长任务的生命周期，我们的一次调用可以不再是一个\"调完即走\"的过程，还可以是一个LLT（Long Lived Transaction)的事物处理过程，比如我们可以将用户的登入、登出的管理放在一个saga函数中处理。\n\n当然，redux-saga还有比如拥有有诸多常用并且声明式易测的 Effects、可以无阻塞的fork等一些更复杂的异步操作和管理方法，如果应用中有较多复杂的异步操作流程，使用redux-saga无疑会让条理更加清楚。\n\n当然，本文的目的不是介绍或者安利redux-saga，只是因为redux-saga是 dva 的一个基础，相关概念点到为止，如需了解更多请自行参考资料。\n\n### dva 源码解读\n\n我们的源码分析流程是这样的：通过一个使用 dva 开发的例子，随着其对 dva 函数的逐步调用，来分析内部 dva 相关函数的实现原理。\n\n我们分析采用的例子是 dva 官方提供的一个增删改查的应用，可以在[这里](https://github.com/dvajs/dva/tree/rewrite-dynamic)找到它的源代码。\n\n我们先看该例子的入口文件：\n\n```\nimport dva from 'dva';\nimport createHistory from 'history/createBrowserHistory';\nimport createLoading from 'dva-loading';\nimport { message } from 'antd';\nimport './index.css';\n\nconst ERROR_MSG_DURATION = 3; // 3 秒\n\n// 1. Initialize\nconst app = dva({\n  history: createHistory(),\n  onError(e) {\n    message.error(e.message, ERROR_MSG_DURATION);\n  },\n});\n\n// 2. Plugins\napp.use(createLoading());\n\n// 3. Model\n// Moved to router.js\n// 这里的 Model 被转移到了动态加载的 router 里面，我们也可以如下写：\n// app.model(require('./models/users'));\n\n// 4. Router\napp.router(require('./router'));\n\n// 5. Start\napp.start('#root');\n```\n\n我们发现dva从初始化配置到最后的start(现在的dva start函数在不传入container的情况下可以返回React Component，便于服务端渲染等，但这里我们还是按照例子的写法来)。\n\n这里我们先有必要解释一下，dva 在当前依据能力和依赖版本的不同，有多个可引入的版本，我们的例子和所要分析的源代码都是基于 react-router V4 的 dva 版本。\n\n在源代码中，相关目录主要为 dva 目录(packages/dva) 和 dva-core(packages/dva-core)目录，前者主要拥有history管理、router、动态加载等功能，而后者是不依赖这些内容的基础模块部分，为前者所引用\n\n#### 第一步\n\n第一步这里传入了两个内容：(dva构造函数总共可以传入那些 opts，会在下文中进行说明)\n\n```\nconst app = dva({\n  history: createHistory(),\n  onError(e) {\n    message.error(e.message, ERROR_MSG_DURATION);\n  },\n});\n```\n\n这一步的相关核心代码如下:\n\n```\nexport default function (opts = {}) {\n  const history = opts.history || createHashHistory(); // 默认为 HashHistory\n  const createOpts = {\n    initialReducer: {\n      routing, // 来自 react-router-redux 的 routerReducer\n    },\n    setupMiddlewares(middlewares) {\n      return [\n        routerMiddleware(history), // 来自 react-router-redux 的 routerMiddleware\n        ...middlewares,\n      ];\n    },\n    setupApp(app) {\n      app._history = patchHistory(history); \n    },\n  };\n\n  const app = core.create(opts, createOpts);\n  const oldAppStart = app.start;\n  app.router = router;\n  app.start = start;\n  return app;\n  \n  // 一些用到的函数的定义...\n  \n}  \n```\n\n这里面大多数内容都比较简单，这里面提两个地方：\n\n1. patchHistory：\n\n```\nfunction patchHistory(history) {\n  const oldListen = history.listen;\n  history.listen = (callback) => {\n    callback(history.location);\n    return oldListen.call(history, callback);\n  };\n  return history;\n}\n```\n\n显然，这里的意思是让第一次被绑定 listener 的时候执行一遍 callback，可以用于初始化相关操作。\n\n我们可以在`router.js`中添加如下代码来验证：\n\n```\n  history.listen((location, action)=>{\n    console.log('history listen:', location, action)\n  })\n```\n\n2. 在完成可选项的构造之后，调用了 dva-core 中暴露的 create 函数。\n\ncreate 函数本身也并不复杂，核心代码如下：\n\n```javascript\nexport function create(hooksAndOpts = {}, createOpts = {}) {\n  const {\n    initialReducer,\n    setupApp = noop,\n  } = createOpts;\n\n  const plugin = new Plugin(); // 实例化钩子函数管理类\n  plugin.use(filterHooks(hooksAndOpts)); // 这个时候先对 obj 进行清理，清理出在我们定义的类型之外的 hooks，之后进行统一绑定\n\n  const app = {\n    _models: [\n      prefixNamespace({ ...dvaModel }), // 前缀处理\n    ],\n    _store: null,\n    _plugin: plugin,\n    use: plugin.use.bind(plugin),\n    model, // 下文定义\n    start, // 下文定义\n  };\n  return app;\n \n  //一些函数的定义\n  \n}  \n```\n\n这里面我们可以看到，这里的 `hooksAndOpts` 实际上就是一开始我们构造 dva 的时候传入的 opts 对象经过处理之后的结果。\n\n我们可以传入的可选项，实际上都在 `Plugin.js` 中写明了:\n\n```\nconst hooks = [\n  'onError',\n  'onStateChange',\n  'onAction',\n  'onHmr',\n  'onReducer',\n  'onEffect',\n  'extraReducers',\n  'extraEnhancers',\n];\n```\n\n具体 [hooks的作用可以在这里进行查阅](https://github.com/dvajs/dva/blob/master/docs/API_zh-CN.md#appusehooks)。\n\nPlugin 插件管理类(实际上我认为称其为钩子函数管理类比较合适)除了定义了上文的使用到的use方法(挂载插件)、还有apply方法(执行某一个钩子下挂载的所有回调)、get方法(获取某一个钩子下的所有回调，返回数组)\n\n\n#### 第二步\n\n\n这里的第二步比较简洁：我们知道实际上这里就是使用了`plugin.use`方法挂载了一个插件\n\n```javascript\napp.use(createLoading()); // 需要注意，插件挂载需要在 app.start 之前\n```\n\ncreateLoading 这个插件实际上是官方提供的 Loading 插件，通过这个插件我们可以非常方便地进行 Loading 的管理，无需进行手动管理，我们可以先[看一篇文章](https://www.jianshu.com/p/61fe7a57fad4)来简单了解一下。\n\n这个插件看似神奇，实际上原理也比较简单，主要用了`onEffect`钩子函数(装饰器)：\n\n```javascript\nfunction onEffect(effect, { put }, model, actionType) {\n    const { namespace } = model;\n    if (\n        (only.length === 0 && except.length === 0)\n        || (only.length > 0 && only.indexOf(actionType) !== -1)\n        || (except.length > 0 && except.indexOf(actionType) === -1)\n    ) {\n        return function*(...args) {\n            yield put({ type: SHOW, payload: { namespace, actionType } });\n            yield effect(...args);\n            yield put({ type: HIDE, payload: { namespace, actionType } });\n        };\n    } else {\n        return effect;\n    }\n  }\n```\n\n结合基于的redux-saga，在目标异步调用开始的时候`yield put({ type: SHOW, payload: { namespace, actionType } });`，在异步调用结束的时候`yield put({ type: HIDE, payload: { namespace, actionType } });`，这样就可以管理异步调用开始和结束的Loading状态了。\n\n\n#### 第三步\n\n第三步这里其实省略了，因为使用了动态加载，将 Models 定义的内容和 React Component 进行了动态加载，实际上也可以按照注释的方法来写。\n\n但是没有关系，我们还是可以分析 models 引入的文件中做了哪些事情(下面列出的代码在原基础上进行了一些简化):\n\n```javascript\nimport queryString from 'query-string';\nimport * as usersService from '../services/users';\n\nexport default {\n  namespace: 'users',\n  state: {\n    list: [],\n    total: null,\n    page: null,\n  },\n  reducers: {\n    save(state, { payload: { data: list, total, page } }) {\n      return { ...state, list, total, page };\n    },\n  },\n  effects: {\n    *fetch({ payload: { page = 1 } }, { call, put }) {\n      const { data, headers } = yield call(usersService.fetch, { page });\n      yield put({\n        type: 'save',\n        payload: {\n          data,\n          total: parseInt(headers['x-total-count'], 10),\n          page: parseInt(page, 10),\n        },\n      });\n    },\n    //...\n    *reload(action, { put, select }) {\n      const page = yield select(state => state.users.page);\n      yield put({ type: 'fetch', payload: { page } });\n    },\n  },\n  subscriptions: {\n    setup({ dispatch, history }) {\n      return history.listen(({ pathname, search }) => {\n        const query = queryString.parse(search);\n        if (pathname === '/users') {\n          dispatch({ type: 'fetch', payload: query });\n        }\n      });\n    },\n  },\n};\n```\n\n这些内容，我们通过`app.model(require('./models/users'));`就可以引入。\n\n实际上，model 函数本身还是比较简单的，但由于 dva 拥有 model 动态加载的能力，实际上调用 app.start 前和 app.start 后model函数是不一样的。\n\n调用 start 函数前，我们直接挂载即可(因为start函数中会对所有model进行遍历性统一处理，所以无需过多处理)：\n\n```javascript\nfunction model(m) {\n    if (process.env.NODE_ENV !== 'production') {\n      checkModel(m, app._models);\n    }\n    app._models.push(prefixNamespace(m));\n    // 把 model 注册到 app 的 _models 里面，但是当 app start 之后，就不能仅仅用这种方法了，需要 injectModel\n  }\n```\n\n调用了 start 函数之后，model函数被替换成如下:\n\n```javascript\nfunction injectModel(createReducer, onError, unlisteners, m) {\n    model(m);\n\n    const store = app._store;\n    if (m.reducers) {\n      store.asyncReducers[m.namespace] = getReducer(m.reducers, m.state);\n      store.replaceReducer(createReducer(store.asyncReducers));\n    }\n    if (m.effects) {\n      store.runSaga(app._getSaga(m.effects, m, onError, plugin.get('onEffect')));\n    }\n    if (m.subscriptions) {\n      unlisteners[m.namespace] = runSubscription(m.subscriptions, m, app, onError);\n    }\n  }\n```\n\n**我们首先分析第一个 if 中的内容**：首先通过getReducer函数将转换好的 reducers 挂载(或替换)到 store.asyncReducers[m.namespace] 中，然后通过 redux 本身提供的能力 replaceReducer 完成 reducer 的替换。\n\n这里我们需要注意 getReducer 函数，实际上，dva 里面 reducers 写法和我们之前直接使用 redux 的写法略有不同：\n\n我们这里的 reducers，实际上要和 action 中的 actionType 同名的 reducer，所以这里我们没有必要去写 switch case 了，对于某一个 reducer 来说其行为应该是确定的，这给 reducers 的写法带来了一定的简化，当然，我们可以使用 extraReducers 定义我们之前习惯的那种比较复杂的 reducers。\n\n**接下来我们分析第二个 if 中的内容**：第二个函数首先获取到了我们定义的 effects 并通过 _getSaga 进行处理，然后使用 `runSaga`(实际上就是createSagaMiddleware().run，来自于redux-saga) 进行执行。\n\n实际上，这里的 `_getSaga` 函数比较复杂，我们接下来重点介绍这个函数。\n\n`_getSaga` 函数由 `getSaga.js` 暴露，其定义如下：\n\n```javascript\nexport default function getSaga(resolve, reject, effects, model, onError, onEffect) {\n  return function *() {  // 返回一个函数\n    for (const key in effects) {  // 这个函数对 effects 里面的所有键\n      if (Object.prototype.hasOwnProperty.call(effects, key)) { // 先判断一下键是属于自己的\n        const watcher = getWatcher(resolve, reject, key, effects[key], model, onError, onEffect);\n        // 然后调用getWatch获取watcher\n        const task = yield sagaEffects.fork(watcher); // 利用 fork 开启一个 task\n        yield sagaEffects.fork(function *() { // 这样写的目的是，如果我们移除了这个 model 要及时结束掉\n          yield sagaEffects.take(`${model.namespace}/@@CANCEL_EFFECTS`);\n          yield sagaEffects.cancel(task);\n        });\n      }\n    }\n  };\n}\n```\n\ngetWatcher 的一些核心代码如下:\n\n```javascript\n\nfunction getWatcher(resolve, reject, key, _effect, model, onError, onEffect) {\n  let effect = _effect;\n  let type = 'takeEvery';\n  let ms;\n\n  if (Array.isArray(_effect)) {\n    effect = _effect[0];\n    const opts = _effect[1];\n    // 对 opts 进行一定的校验\n    //...\n  }\n\n  function *sagaWithCatch(...args) { // 都会调用这个过程\n    try {\n      yield sagaEffects.put({ type: `${key}${NAMESPACE_SEP}@@start` });\n      const ret = yield effect(...args.concat(createEffects(model)));\n      yield sagaEffects.put({ type: `${key}${NAMESPACE_SEP}@@end` });\n      resolve(key, ret);\n    } catch (e) {\n      onError(e);\n      if (!e._dontReject) {\n        reject(key, e);\n      }\n    }\n  }\n\n  const sagaWithOnEffect = applyOnEffect(onEffect, sagaWithCatch, model, key); \n  // 挂载 onEffect 钩子\n\n  switch (type) {\n    case 'watcher':\n      return sagaWithCatch;\n    case 'takeLatest':\n      return function*() {\n        yield takeLatest(key, sagaWithOnEffect);\n      };\n    case 'throttle': // 起到节流的效果，在 ms 时间内仅仅会被触发一次\n      return function*() {\n        yield throttle(ms, key, sagaWithOnEffect);\n      };\n    default:\n      return function*() {\n        yield takeEvery(key, sagaWithOnEffect);\n      };\n  }\n}\n```\n\n这个函数的工作，可以主要分为以下三个部分：\n\n1.将 effect 包裹成 sagaWithCatch，除了便于错误处理和增加前后钩子，值得我们注意的是 resolve 和 reject，\n\n这个 resolve 和 reject，实际上是来自`createPromiseMiddleware.js`\n\n我们知道，我们在使用redux-saga的过程中，实际上是监听未来的action，并执行 effects，所以我们在一个 effects 函数中执行一些异步操作，然后 put(dispatch) 一个 action，还是会被监听这个 action 的其他 saga 监听到。\n\n所以就有如下场景：我们 dispatch 一个 action，这个时候如果我们想获取到什么时候监听这个 action 的 saga 中的异步操作执行结束，是办不到的(因为不是所有的时候我们都把所有处理逻辑写在 saga 中)，所以我们的 dispatch 有的时候需要返回一个 Promise 从而我们可以进行异步结束后的回调(这个 Promise 在监听者 saga 异步执行完后被决议，见上文`sagaWithCatch`函数源代码)。\n\n如果我讲的还是比较混乱，也可以参考[这个issue](https://github.com/dvajs/dva/issues/175)\n\n对于这个情况，我认为这是 dva 代码最精彩的地方之一，作者通过定义如下的middleware:\n\n```javascript\n const middleware = () => next => (action) => {\n    const { type } = action;\n    if (isEffect(type)) {\n      return new Promise((resolve, reject) => {\n        map[type] = {\n          resolve: wrapped.bind(null, type, resolve),\n          reject: wrapped.bind(null, type, reject),\n        };\n      });\n    } else {\n      return next(action);\n    }\n  };\n\n  function wrapped(type, fn, args) {\n    if (map[type]) delete map[type];\n    fn(args);\n  }\n\n  function resolve(type, args) {\n    if (map[type]) {\n      map[type].resolve(args);\n    }\n  }\n\n  function reject(type, args) {\n    if (map[type]) {\n      map[type].reject(args);\n    }\n  }\n```\n\n并且在上文的`sagaWithCatch`相关effect执行结束的时候调用 resolve，让 dispatch 返回了一个 Promise。\n\n当然，上面这段代码还是有点问题的，这样会导致同名 reducer 和 effect 不会 fallthrough（即两者都执行），因为都已经返回了，action 便不会再进一步传递，关于这样设计的好坏，在[这里](https://github.com/sorrycc/blog/issues/48)有过一些讨论，笔者不进行展开表述。\n\n2.在上面冗长的第一步之后，又通过`applyOnEffect`函数包裹了`OnEffect`的钩子函数，这相当于是一种`compose`，(上文的 dva-loading 中间件实际上就是在这里被处理的)其实现对于熟悉 redux 的同学来说应该不难理解：\n\n```javascript\nfunction applyOnEffect(fns, effect, model, key) {\n  for (const fn of fns) {\n    effect = fn(effect, sagaEffects, model, key);\n  }\n  return effect;\n}\n```\n\n3.最后，根据我们定义的type(默认是`takeEvery`，也就是都执行)，来选择不同的 saga，takeLatest 即为只是执行最近的一个，throttle则起到节流的效果，一定时间内仅仅允许被触发一次，这些都是 redux-saga 的内部实现，dva 也是基本直接引用，因此在这里不进行展开。\n\n**最后我们分析`injectModel`第三个`if`中的内容**:处理`subscriptions`:\n\n```javascript\nif (m.subscriptions) {\n  unlisteners[m.namespace] = runSubscription(m.subscriptions, m, app, onError);\n}\n```\n\n`subscriptions`可以理解为和这个model有关的全局监听，但是相对独立。这一个步骤首先调用`runSubscription`来一个一个调用我们的`subscriptions`:\n\n```javascript\nexport function run(subs, model, app, onError) { // 在index.js中被重命名为 runSubscription\n  const funcs = [];\n  const nonFuncs = [];\n  for (const key in subs) {\n    if (Object.prototype.hasOwnProperty.call(subs, key)) {\n      const sub = subs[key];\n      const unlistener = sub({\n        dispatch: prefixedDispatch(app._store.dispatch, model),\n        history: app._history,\n      }, onError);\n      if (isFunction(unlistener)) {\n        funcs.push(unlistener);\n      } else {\n        nonFuncs.push(key);\n      }\n    }\n  }\n  return { funcs, nonFuncs };\n}\n```\n\n正如我们所期待的，`run`函数就是一个一个执行`subscriptions`，但是这里有一点需要我们注意的，我们定义的`subscriptions`应该是需要返回一个`unlistener`来返回接触函数，这样当整个 model 被卸载的时候 dva 会自动调用这个接解除函数(也就是为什么这里的返回函数被命名为`unlistener`)\n\n#### 第四步\n\n源代码中的第四步，是对 router 的挂载：\n\n```javascript\napp.router(require('./router'));\n```\n\n`require('./router')`返回的内容在源代码中经过一系列引用传递最后直接被构造成 React Component 并且最终调用 ReactDom.render 进行渲染，这里没有什么好说的，值得一提的就是 router 的动态加载。\n\n动态加载在该样例中是这样使用的：\n\n```javascript\nimport React from 'react';\nimport { Router, Switch, Route } from 'dva/router';\nimport dynamic from 'dva/dynamic';\n\nfunction RouterConfig({ history, app }) {\n  const IndexPage = dynamic({\n    app,\n    component: () => import('./routes/IndexPage'),\n  });\n\n  const Users = dynamic({\n    app,\n    models: () => [\n      import('./models/users'),\n    ],\n    component: () => import('./routes/Users'),\n  });\n\n  history.listen((location, action)=>{\n    console.log('history listen:', location, action)\n  })\n\n  return (\n    <Router history={history}>\n      <Switch>\n        <Route exact path=\"/\" component={IndexPage} />\n        <Route exact path=\"/users\" component={Users} />\n      </Switch>\n    </Router>\n  );\n}\n```\n\n我们可以看出，主要就是利用`dva/dynamic.js`暴露的 dynamic 函数进行动态加载，接下来我们简单看一下 dynamic 函数做了什么:\n\n```javascript\nexport default function dynamic(config) {\n  const { app, models: resolveModels, component: resolveComponent } = config;\n  return asyncComponent({\n    resolve: config.resolve || function () {\n      const models = typeof resolveModels === 'function' ? resolveModels() : [];\n      const component = resolveComponent();\n      return new Promise((resolve) => {\n        Promise.all([...models, component]).then((ret) => {\n          if (!models || !models.length) {\n            return resolve(ret[0]);\n          } else {\n            const len = models.length;\n            ret.slice(0, len).forEach((m) => {\n              m = m.default || m;\n              if (!Array.isArray(m)) {\n                m = [m];\n              }\n              m.map(_ => registerModel(app, _)); // 注册所有的 model\n            });\n            resolve(ret[len]);\n          }\n        });\n      });\n    },\n    ...config,\n  });\n}\n```\n\n这里主要调用了 asyncComponent 函数，接下来我们再看一下这个函数：\n\n```javascript\nfunction asyncComponent(config) {\n  const { resolve } = config;\n\n  return class DynamicComponent extends Component {\n    constructor(...args) {\n      super(...args);\n      this.LoadingComponent =\n        config.LoadingComponent || defaultLoadingComponent;\n      this.state = {\n        AsyncComponent: null,\n      };\n      this.load();\n    }\n\n    componentDidMount() {\n      this.mounted = true;\n    }\n\n    componentWillUnmount() {\n      this.mounted = false;\n    }\n\n    load() {\n      resolve().then((m) => {\n        const AsyncComponent = m.default || m;\n        if (this.mounted) {\n          this.setState({ AsyncComponent });\n        } else {\n          this.state.AsyncComponent = AsyncComponent; // eslint-disable-line\n        }\n      });\n    }\n\n    render() {\n      const { AsyncComponent } = this.state;\n      const { LoadingComponent } = this;\n      if (AsyncComponent) return <AsyncComponent {...this.props} />;\n\n      return <LoadingComponent {...this.props} />;\n    }\n  };\n}\n```\n\n这个函数逻辑比较简洁，我们分析一下动态加载流程；\n\n* 在 constructor 里面调用 `this.load();` ( LoadingComponent 为占位 component)\n* 在 `this.load();` 函数里面调用 `dynamic` 函数返回的 resolve 方法\n* resolve 方法实际上是一个 Promise，把相关 models 和 component 加载完之后 resolve (区分这两个 resolve)\n* 加载完成之后返回 AsyncComponent (即加载的 Component)\n\n动态加载主流程结束，至于动态加载的代码分割工作，可以使用 webpack3 的 `import()` 动态加载能力(例子中也是这样使用的)。\n\n\n#### 第五步\n\n第五步骤就是 start 了：\n\n```javascript\napp.start('#root');\n```\n\n这个时候如果我们在 start 函数中传入 DomElement 或者 DomQueryString，就会直接启动应用了，如果我们这个时候不传入任何内容，实际上返回的是一个`<Provider />` (React Component)，便于服务端渲染。 相关判断逻辑如下：\n\n```javascript\n if (container) {\n      render(container, store, app, app._router);\n      app._plugin.apply('onHmr')(render.bind(null, container, store, app));\n    } else {\n      return getProvider(store, this, this._router);\n    }\n```\n\n至此，主要流程结束，以上几个步骤也包括了 dva 源码做的主要工作。\n\n当然 dva 源码中还有一些比如前缀处理等工作，但是相比于以上内容非常简单，所以在这里不进行分析了。\n\n\n### dva-core 文件目录\n\ndva-core中的源码文件目录以及其功能:\n\n* checkModel 对我们定义的 Model 进行检查是否符合要求\n* constants 非常简单的常量文件，目前只定义了一个常量：NAMESPACE_SEP(/)\n* cratePromiseMiddleware 笔者自己定义的 redux 插件\n* createStore 封装了 redux 原生的 createStore\n* getReducer 这里面的函数其实主要就是调用了 handleActions 文件导出的函数\n* getSaga 将用户输入的 effects 部分的键值对函数进行管理\n* handleActions 是将 dva 风格的 reducer 和 state 转化成 redux 本来接受的那种方式\n* index 主入口文件\n* Plugin 插件类：可以管理不同钩子事件的回调函数，拥有增加、获取、执行钩子函数的功能\n* perfixedDispatch 该文件提供了对 Dispatch 增加前缀的工具性函数 prefixedDispatch\n* prefixNamespace 该文件提供了对 reducer 和 effects 增加前缀的工具性函数 prefixNamespace\n* prefixType 判断是 reducer 还是 effects\n* subscriptions 该文件提供了运行 subscriptions 和调用用户返回的 unlisten 函数以及删除缓存的功能\n* utils 提供一些非常基础的工具函数\n\n\n### 优势总结\n\n* 动态 model，已经封装好了整套调用，动态添加/删除 model 变得非常简单\n* 默认封装好了管理 effects 的方式，有限可选可配置，降低学习成本的同时代码更利于维护\n* 易于上手，集成redux、redux-saga、react-router等常用功能\n\n\n### 劣势总结\n\n* 版本区隔不明显，dva 有 1.x 和 2.x 两种版本，之间API有些差异，但是官网提供的一些样例等中没有说明基于的版本，并且有的还是基于旧版本的，会给新手带来很多疑惑。\n* 内容繁杂，但是却没有一个整合性质的官方网站，大都是通过 list 的形式列下来写在README的。\n* 目前比如动态加载等还存在着一些问题，和直接采用react配套工具写的效果有所区别。\n* 很多 issues 不知道为什么就被关闭了，作者在最后也并未给出合理的解释。\n* dva2 之后有点将 effects 和 actions 混淆，这一点我也并不是非常认同，当然原作者可能有自己的考虑，这里不过多评议。\n\n总之，作为一个个人主力的项目(主要开发者贡献了99%以上的代码)，可以看出作者的功底深厚，经验丰富，但是由于这样一个体系化的东西牵扯内容较多，并且非常受制于react、redux、react-router、redux-saga等的版本影响，**不建议具备一定规模的非阿里系团队在生产环境中使用**，但是如果是快速成型的中小型项目或者个人应用，使用起来还是有很大帮助的。\n\n### TODOS\n\n笔者也在准备做一个和 dva 处于同一性质，但是设计、实现和使用有所区别的框架，希望能够尽快落成。\n","source":"_posts/dva源码解读.md","raw":"---\ntitle: dva源码解读\ntags:\n  - 前端框架\nabbrlink: 1779834361\ndate: 2018-04-11 15:07:20\n---\n\n### 声明\n\n本文章用于个人学习研究，并不代表 dva 团队的任何观点。\n\n原文以及包含一定注释的代码见[这里](https://github.com/aircloud/dva-analysis)，若有问题也可以在[这里](https://github.com/aircloud/dva-analysis/issues)进行讨论\n\n### 起步\n\n#### 为什么是dva?\n\n笔者对 dva 的源代码进行解读，主要考虑到 dva 并不是一个和我们熟知的主流技术无关的从0到1的框架，相反，它是对主流技术进行整合，提炼，从而形成一种最佳实践，分析 dva，意味着我们可以对自己掌握的很多相关技术进行回顾，另外，dva 的代码量并不多，也不至于晦涩难懂，可以给我们平时的业务开发以启发。\n\n本文章作为 dva 的源码解读文章，并不面向新手用户，读者应当有一定的 react 使用经验和 ECMAscript 2015+ 的使用经验，并且应当了解 redux 和 redux-saga，以及对 dva 的使用有所了解(可以从[这里](https://github.com/dvajs/dva/blob/master/README_zh-CN.md#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-dva-)了解为什么需要使用 dva)\n\n重点推荐:\n\n* 通过[这里](https://github.com/dvajs/dva-knowledgemap)的内容了解使用dva的最小知识集\n* 通过[这里](https://redux-saga-in-chinese.js.org/docs/introduction/index.html)学习 redux-saga\n\n其他推荐：\n\n* [dva的概念](https://github.com/dvajs/dva/blob/master/docs/Concepts_zh-CN.md)\n* [dva的全部API](https://github.com/dvajs/dva/blob/master/docs/API_zh-CN.md)\n* [React+Redux 最佳实践](https://github.com/sorrycc/blog/issues/1)\n* [React在蚂蚁金服的实践](http://slides.com/sorrycc/dva#/)\n* [dva 2.0的改进](https://github.com/sorrycc/blog/issues/48)\n* [ReSelect介绍](http://cn.redux.js.org/docs/recipes/ComputingDerivedData.html)\n* [浅析Redux 的 store enhancer](https://www.jianshu.com/p/04d3fefea8d7)\n\n\n几个 dva 版本之间的关系:\n\n* dva@2.0：基于 react 和 react-router@4\n* dva-react-router-3@1.0：基于 react 和 react-router@3\n* dva-no-router@1.0：无路由版本，适用于多页面场景，可以和 next.js 组合使用\n* dva-core@1.0：仅封装了 redux 和 redux-saga\n\n我们本次主要分析目标为 dva@2.0 和 dva-core@1.0\n\n\n### 我们为什么需要 redux-saga\n\n目前，在大多数项目开发中，我们现在依然采用的是redux-thunk + async/await (或 Promise)。\n\n实际上这个十几行的插件已经完全可以解决大多是场景下的问题了，如果你在目前的工作中正在使用这一套方案并且能够完全将当下的需求应付自如并且没有什么凌乱的地方，其实也是没有必要换成redux-saga的。\n\n接下来我们讲 redux-saga，先看名字：saga，这个术语常用于CQRS架构，代表查询与责任分离。\n\n相比于 redux-thunk，前者通常是把数据查询等请求放在 actions 中(不纯净的 actions)，并且这些 actions 可以继续回调调用其他 actions(纯净的 actions)，从而完成数据的更新；而 redux-saga，则保持了 actions 的纯粹性，单独抽出一层专门来处理数据请求等操作(saga函数)。\n\n这样做还有另外一些好处：\n\n* 由于我们已经将数据处理数据请求等异步操作抽离出来了，并且通过 generator 来处理，我们便可以方便地进行多种异步管理：比如同时按顺序执行多个任务、在多个异步任务中启动race等。\n* 这样做可以延长任务的生命周期，我们的一次调用可以不再是一个\"调完即走\"的过程，还可以是一个LLT（Long Lived Transaction)的事物处理过程，比如我们可以将用户的登入、登出的管理放在一个saga函数中处理。\n\n当然，redux-saga还有比如拥有有诸多常用并且声明式易测的 Effects、可以无阻塞的fork等一些更复杂的异步操作和管理方法，如果应用中有较多复杂的异步操作流程，使用redux-saga无疑会让条理更加清楚。\n\n当然，本文的目的不是介绍或者安利redux-saga，只是因为redux-saga是 dva 的一个基础，相关概念点到为止，如需了解更多请自行参考资料。\n\n### dva 源码解读\n\n我们的源码分析流程是这样的：通过一个使用 dva 开发的例子，随着其对 dva 函数的逐步调用，来分析内部 dva 相关函数的实现原理。\n\n我们分析采用的例子是 dva 官方提供的一个增删改查的应用，可以在[这里](https://github.com/dvajs/dva/tree/rewrite-dynamic)找到它的源代码。\n\n我们先看该例子的入口文件：\n\n```\nimport dva from 'dva';\nimport createHistory from 'history/createBrowserHistory';\nimport createLoading from 'dva-loading';\nimport { message } from 'antd';\nimport './index.css';\n\nconst ERROR_MSG_DURATION = 3; // 3 秒\n\n// 1. Initialize\nconst app = dva({\n  history: createHistory(),\n  onError(e) {\n    message.error(e.message, ERROR_MSG_DURATION);\n  },\n});\n\n// 2. Plugins\napp.use(createLoading());\n\n// 3. Model\n// Moved to router.js\n// 这里的 Model 被转移到了动态加载的 router 里面，我们也可以如下写：\n// app.model(require('./models/users'));\n\n// 4. Router\napp.router(require('./router'));\n\n// 5. Start\napp.start('#root');\n```\n\n我们发现dva从初始化配置到最后的start(现在的dva start函数在不传入container的情况下可以返回React Component，便于服务端渲染等，但这里我们还是按照例子的写法来)。\n\n这里我们先有必要解释一下，dva 在当前依据能力和依赖版本的不同，有多个可引入的版本，我们的例子和所要分析的源代码都是基于 react-router V4 的 dva 版本。\n\n在源代码中，相关目录主要为 dva 目录(packages/dva) 和 dva-core(packages/dva-core)目录，前者主要拥有history管理、router、动态加载等功能，而后者是不依赖这些内容的基础模块部分，为前者所引用\n\n#### 第一步\n\n第一步这里传入了两个内容：(dva构造函数总共可以传入那些 opts，会在下文中进行说明)\n\n```\nconst app = dva({\n  history: createHistory(),\n  onError(e) {\n    message.error(e.message, ERROR_MSG_DURATION);\n  },\n});\n```\n\n这一步的相关核心代码如下:\n\n```\nexport default function (opts = {}) {\n  const history = opts.history || createHashHistory(); // 默认为 HashHistory\n  const createOpts = {\n    initialReducer: {\n      routing, // 来自 react-router-redux 的 routerReducer\n    },\n    setupMiddlewares(middlewares) {\n      return [\n        routerMiddleware(history), // 来自 react-router-redux 的 routerMiddleware\n        ...middlewares,\n      ];\n    },\n    setupApp(app) {\n      app._history = patchHistory(history); \n    },\n  };\n\n  const app = core.create(opts, createOpts);\n  const oldAppStart = app.start;\n  app.router = router;\n  app.start = start;\n  return app;\n  \n  // 一些用到的函数的定义...\n  \n}  \n```\n\n这里面大多数内容都比较简单，这里面提两个地方：\n\n1. patchHistory：\n\n```\nfunction patchHistory(history) {\n  const oldListen = history.listen;\n  history.listen = (callback) => {\n    callback(history.location);\n    return oldListen.call(history, callback);\n  };\n  return history;\n}\n```\n\n显然，这里的意思是让第一次被绑定 listener 的时候执行一遍 callback，可以用于初始化相关操作。\n\n我们可以在`router.js`中添加如下代码来验证：\n\n```\n  history.listen((location, action)=>{\n    console.log('history listen:', location, action)\n  })\n```\n\n2. 在完成可选项的构造之后，调用了 dva-core 中暴露的 create 函数。\n\ncreate 函数本身也并不复杂，核心代码如下：\n\n```javascript\nexport function create(hooksAndOpts = {}, createOpts = {}) {\n  const {\n    initialReducer,\n    setupApp = noop,\n  } = createOpts;\n\n  const plugin = new Plugin(); // 实例化钩子函数管理类\n  plugin.use(filterHooks(hooksAndOpts)); // 这个时候先对 obj 进行清理，清理出在我们定义的类型之外的 hooks，之后进行统一绑定\n\n  const app = {\n    _models: [\n      prefixNamespace({ ...dvaModel }), // 前缀处理\n    ],\n    _store: null,\n    _plugin: plugin,\n    use: plugin.use.bind(plugin),\n    model, // 下文定义\n    start, // 下文定义\n  };\n  return app;\n \n  //一些函数的定义\n  \n}  \n```\n\n这里面我们可以看到，这里的 `hooksAndOpts` 实际上就是一开始我们构造 dva 的时候传入的 opts 对象经过处理之后的结果。\n\n我们可以传入的可选项，实际上都在 `Plugin.js` 中写明了:\n\n```\nconst hooks = [\n  'onError',\n  'onStateChange',\n  'onAction',\n  'onHmr',\n  'onReducer',\n  'onEffect',\n  'extraReducers',\n  'extraEnhancers',\n];\n```\n\n具体 [hooks的作用可以在这里进行查阅](https://github.com/dvajs/dva/blob/master/docs/API_zh-CN.md#appusehooks)。\n\nPlugin 插件管理类(实际上我认为称其为钩子函数管理类比较合适)除了定义了上文的使用到的use方法(挂载插件)、还有apply方法(执行某一个钩子下挂载的所有回调)、get方法(获取某一个钩子下的所有回调，返回数组)\n\n\n#### 第二步\n\n\n这里的第二步比较简洁：我们知道实际上这里就是使用了`plugin.use`方法挂载了一个插件\n\n```javascript\napp.use(createLoading()); // 需要注意，插件挂载需要在 app.start 之前\n```\n\ncreateLoading 这个插件实际上是官方提供的 Loading 插件，通过这个插件我们可以非常方便地进行 Loading 的管理，无需进行手动管理，我们可以先[看一篇文章](https://www.jianshu.com/p/61fe7a57fad4)来简单了解一下。\n\n这个插件看似神奇，实际上原理也比较简单，主要用了`onEffect`钩子函数(装饰器)：\n\n```javascript\nfunction onEffect(effect, { put }, model, actionType) {\n    const { namespace } = model;\n    if (\n        (only.length === 0 && except.length === 0)\n        || (only.length > 0 && only.indexOf(actionType) !== -1)\n        || (except.length > 0 && except.indexOf(actionType) === -1)\n    ) {\n        return function*(...args) {\n            yield put({ type: SHOW, payload: { namespace, actionType } });\n            yield effect(...args);\n            yield put({ type: HIDE, payload: { namespace, actionType } });\n        };\n    } else {\n        return effect;\n    }\n  }\n```\n\n结合基于的redux-saga，在目标异步调用开始的时候`yield put({ type: SHOW, payload: { namespace, actionType } });`，在异步调用结束的时候`yield put({ type: HIDE, payload: { namespace, actionType } });`，这样就可以管理异步调用开始和结束的Loading状态了。\n\n\n#### 第三步\n\n第三步这里其实省略了，因为使用了动态加载，将 Models 定义的内容和 React Component 进行了动态加载，实际上也可以按照注释的方法来写。\n\n但是没有关系，我们还是可以分析 models 引入的文件中做了哪些事情(下面列出的代码在原基础上进行了一些简化):\n\n```javascript\nimport queryString from 'query-string';\nimport * as usersService from '../services/users';\n\nexport default {\n  namespace: 'users',\n  state: {\n    list: [],\n    total: null,\n    page: null,\n  },\n  reducers: {\n    save(state, { payload: { data: list, total, page } }) {\n      return { ...state, list, total, page };\n    },\n  },\n  effects: {\n    *fetch({ payload: { page = 1 } }, { call, put }) {\n      const { data, headers } = yield call(usersService.fetch, { page });\n      yield put({\n        type: 'save',\n        payload: {\n          data,\n          total: parseInt(headers['x-total-count'], 10),\n          page: parseInt(page, 10),\n        },\n      });\n    },\n    //...\n    *reload(action, { put, select }) {\n      const page = yield select(state => state.users.page);\n      yield put({ type: 'fetch', payload: { page } });\n    },\n  },\n  subscriptions: {\n    setup({ dispatch, history }) {\n      return history.listen(({ pathname, search }) => {\n        const query = queryString.parse(search);\n        if (pathname === '/users') {\n          dispatch({ type: 'fetch', payload: query });\n        }\n      });\n    },\n  },\n};\n```\n\n这些内容，我们通过`app.model(require('./models/users'));`就可以引入。\n\n实际上，model 函数本身还是比较简单的，但由于 dva 拥有 model 动态加载的能力，实际上调用 app.start 前和 app.start 后model函数是不一样的。\n\n调用 start 函数前，我们直接挂载即可(因为start函数中会对所有model进行遍历性统一处理，所以无需过多处理)：\n\n```javascript\nfunction model(m) {\n    if (process.env.NODE_ENV !== 'production') {\n      checkModel(m, app._models);\n    }\n    app._models.push(prefixNamespace(m));\n    // 把 model 注册到 app 的 _models 里面，但是当 app start 之后，就不能仅仅用这种方法了，需要 injectModel\n  }\n```\n\n调用了 start 函数之后，model函数被替换成如下:\n\n```javascript\nfunction injectModel(createReducer, onError, unlisteners, m) {\n    model(m);\n\n    const store = app._store;\n    if (m.reducers) {\n      store.asyncReducers[m.namespace] = getReducer(m.reducers, m.state);\n      store.replaceReducer(createReducer(store.asyncReducers));\n    }\n    if (m.effects) {\n      store.runSaga(app._getSaga(m.effects, m, onError, plugin.get('onEffect')));\n    }\n    if (m.subscriptions) {\n      unlisteners[m.namespace] = runSubscription(m.subscriptions, m, app, onError);\n    }\n  }\n```\n\n**我们首先分析第一个 if 中的内容**：首先通过getReducer函数将转换好的 reducers 挂载(或替换)到 store.asyncReducers[m.namespace] 中，然后通过 redux 本身提供的能力 replaceReducer 完成 reducer 的替换。\n\n这里我们需要注意 getReducer 函数，实际上，dva 里面 reducers 写法和我们之前直接使用 redux 的写法略有不同：\n\n我们这里的 reducers，实际上要和 action 中的 actionType 同名的 reducer，所以这里我们没有必要去写 switch case 了，对于某一个 reducer 来说其行为应该是确定的，这给 reducers 的写法带来了一定的简化，当然，我们可以使用 extraReducers 定义我们之前习惯的那种比较复杂的 reducers。\n\n**接下来我们分析第二个 if 中的内容**：第二个函数首先获取到了我们定义的 effects 并通过 _getSaga 进行处理，然后使用 `runSaga`(实际上就是createSagaMiddleware().run，来自于redux-saga) 进行执行。\n\n实际上，这里的 `_getSaga` 函数比较复杂，我们接下来重点介绍这个函数。\n\n`_getSaga` 函数由 `getSaga.js` 暴露，其定义如下：\n\n```javascript\nexport default function getSaga(resolve, reject, effects, model, onError, onEffect) {\n  return function *() {  // 返回一个函数\n    for (const key in effects) {  // 这个函数对 effects 里面的所有键\n      if (Object.prototype.hasOwnProperty.call(effects, key)) { // 先判断一下键是属于自己的\n        const watcher = getWatcher(resolve, reject, key, effects[key], model, onError, onEffect);\n        // 然后调用getWatch获取watcher\n        const task = yield sagaEffects.fork(watcher); // 利用 fork 开启一个 task\n        yield sagaEffects.fork(function *() { // 这样写的目的是，如果我们移除了这个 model 要及时结束掉\n          yield sagaEffects.take(`${model.namespace}/@@CANCEL_EFFECTS`);\n          yield sagaEffects.cancel(task);\n        });\n      }\n    }\n  };\n}\n```\n\ngetWatcher 的一些核心代码如下:\n\n```javascript\n\nfunction getWatcher(resolve, reject, key, _effect, model, onError, onEffect) {\n  let effect = _effect;\n  let type = 'takeEvery';\n  let ms;\n\n  if (Array.isArray(_effect)) {\n    effect = _effect[0];\n    const opts = _effect[1];\n    // 对 opts 进行一定的校验\n    //...\n  }\n\n  function *sagaWithCatch(...args) { // 都会调用这个过程\n    try {\n      yield sagaEffects.put({ type: `${key}${NAMESPACE_SEP}@@start` });\n      const ret = yield effect(...args.concat(createEffects(model)));\n      yield sagaEffects.put({ type: `${key}${NAMESPACE_SEP}@@end` });\n      resolve(key, ret);\n    } catch (e) {\n      onError(e);\n      if (!e._dontReject) {\n        reject(key, e);\n      }\n    }\n  }\n\n  const sagaWithOnEffect = applyOnEffect(onEffect, sagaWithCatch, model, key); \n  // 挂载 onEffect 钩子\n\n  switch (type) {\n    case 'watcher':\n      return sagaWithCatch;\n    case 'takeLatest':\n      return function*() {\n        yield takeLatest(key, sagaWithOnEffect);\n      };\n    case 'throttle': // 起到节流的效果，在 ms 时间内仅仅会被触发一次\n      return function*() {\n        yield throttle(ms, key, sagaWithOnEffect);\n      };\n    default:\n      return function*() {\n        yield takeEvery(key, sagaWithOnEffect);\n      };\n  }\n}\n```\n\n这个函数的工作，可以主要分为以下三个部分：\n\n1.将 effect 包裹成 sagaWithCatch，除了便于错误处理和增加前后钩子，值得我们注意的是 resolve 和 reject，\n\n这个 resolve 和 reject，实际上是来自`createPromiseMiddleware.js`\n\n我们知道，我们在使用redux-saga的过程中，实际上是监听未来的action，并执行 effects，所以我们在一个 effects 函数中执行一些异步操作，然后 put(dispatch) 一个 action，还是会被监听这个 action 的其他 saga 监听到。\n\n所以就有如下场景：我们 dispatch 一个 action，这个时候如果我们想获取到什么时候监听这个 action 的 saga 中的异步操作执行结束，是办不到的(因为不是所有的时候我们都把所有处理逻辑写在 saga 中)，所以我们的 dispatch 有的时候需要返回一个 Promise 从而我们可以进行异步结束后的回调(这个 Promise 在监听者 saga 异步执行完后被决议，见上文`sagaWithCatch`函数源代码)。\n\n如果我讲的还是比较混乱，也可以参考[这个issue](https://github.com/dvajs/dva/issues/175)\n\n对于这个情况，我认为这是 dva 代码最精彩的地方之一，作者通过定义如下的middleware:\n\n```javascript\n const middleware = () => next => (action) => {\n    const { type } = action;\n    if (isEffect(type)) {\n      return new Promise((resolve, reject) => {\n        map[type] = {\n          resolve: wrapped.bind(null, type, resolve),\n          reject: wrapped.bind(null, type, reject),\n        };\n      });\n    } else {\n      return next(action);\n    }\n  };\n\n  function wrapped(type, fn, args) {\n    if (map[type]) delete map[type];\n    fn(args);\n  }\n\n  function resolve(type, args) {\n    if (map[type]) {\n      map[type].resolve(args);\n    }\n  }\n\n  function reject(type, args) {\n    if (map[type]) {\n      map[type].reject(args);\n    }\n  }\n```\n\n并且在上文的`sagaWithCatch`相关effect执行结束的时候调用 resolve，让 dispatch 返回了一个 Promise。\n\n当然，上面这段代码还是有点问题的，这样会导致同名 reducer 和 effect 不会 fallthrough（即两者都执行），因为都已经返回了，action 便不会再进一步传递，关于这样设计的好坏，在[这里](https://github.com/sorrycc/blog/issues/48)有过一些讨论，笔者不进行展开表述。\n\n2.在上面冗长的第一步之后，又通过`applyOnEffect`函数包裹了`OnEffect`的钩子函数，这相当于是一种`compose`，(上文的 dva-loading 中间件实际上就是在这里被处理的)其实现对于熟悉 redux 的同学来说应该不难理解：\n\n```javascript\nfunction applyOnEffect(fns, effect, model, key) {\n  for (const fn of fns) {\n    effect = fn(effect, sagaEffects, model, key);\n  }\n  return effect;\n}\n```\n\n3.最后，根据我们定义的type(默认是`takeEvery`，也就是都执行)，来选择不同的 saga，takeLatest 即为只是执行最近的一个，throttle则起到节流的效果，一定时间内仅仅允许被触发一次，这些都是 redux-saga 的内部实现，dva 也是基本直接引用，因此在这里不进行展开。\n\n**最后我们分析`injectModel`第三个`if`中的内容**:处理`subscriptions`:\n\n```javascript\nif (m.subscriptions) {\n  unlisteners[m.namespace] = runSubscription(m.subscriptions, m, app, onError);\n}\n```\n\n`subscriptions`可以理解为和这个model有关的全局监听，但是相对独立。这一个步骤首先调用`runSubscription`来一个一个调用我们的`subscriptions`:\n\n```javascript\nexport function run(subs, model, app, onError) { // 在index.js中被重命名为 runSubscription\n  const funcs = [];\n  const nonFuncs = [];\n  for (const key in subs) {\n    if (Object.prototype.hasOwnProperty.call(subs, key)) {\n      const sub = subs[key];\n      const unlistener = sub({\n        dispatch: prefixedDispatch(app._store.dispatch, model),\n        history: app._history,\n      }, onError);\n      if (isFunction(unlistener)) {\n        funcs.push(unlistener);\n      } else {\n        nonFuncs.push(key);\n      }\n    }\n  }\n  return { funcs, nonFuncs };\n}\n```\n\n正如我们所期待的，`run`函数就是一个一个执行`subscriptions`，但是这里有一点需要我们注意的，我们定义的`subscriptions`应该是需要返回一个`unlistener`来返回接触函数，这样当整个 model 被卸载的时候 dva 会自动调用这个接解除函数(也就是为什么这里的返回函数被命名为`unlistener`)\n\n#### 第四步\n\n源代码中的第四步，是对 router 的挂载：\n\n```javascript\napp.router(require('./router'));\n```\n\n`require('./router')`返回的内容在源代码中经过一系列引用传递最后直接被构造成 React Component 并且最终调用 ReactDom.render 进行渲染，这里没有什么好说的，值得一提的就是 router 的动态加载。\n\n动态加载在该样例中是这样使用的：\n\n```javascript\nimport React from 'react';\nimport { Router, Switch, Route } from 'dva/router';\nimport dynamic from 'dva/dynamic';\n\nfunction RouterConfig({ history, app }) {\n  const IndexPage = dynamic({\n    app,\n    component: () => import('./routes/IndexPage'),\n  });\n\n  const Users = dynamic({\n    app,\n    models: () => [\n      import('./models/users'),\n    ],\n    component: () => import('./routes/Users'),\n  });\n\n  history.listen((location, action)=>{\n    console.log('history listen:', location, action)\n  })\n\n  return (\n    <Router history={history}>\n      <Switch>\n        <Route exact path=\"/\" component={IndexPage} />\n        <Route exact path=\"/users\" component={Users} />\n      </Switch>\n    </Router>\n  );\n}\n```\n\n我们可以看出，主要就是利用`dva/dynamic.js`暴露的 dynamic 函数进行动态加载，接下来我们简单看一下 dynamic 函数做了什么:\n\n```javascript\nexport default function dynamic(config) {\n  const { app, models: resolveModels, component: resolveComponent } = config;\n  return asyncComponent({\n    resolve: config.resolve || function () {\n      const models = typeof resolveModels === 'function' ? resolveModels() : [];\n      const component = resolveComponent();\n      return new Promise((resolve) => {\n        Promise.all([...models, component]).then((ret) => {\n          if (!models || !models.length) {\n            return resolve(ret[0]);\n          } else {\n            const len = models.length;\n            ret.slice(0, len).forEach((m) => {\n              m = m.default || m;\n              if (!Array.isArray(m)) {\n                m = [m];\n              }\n              m.map(_ => registerModel(app, _)); // 注册所有的 model\n            });\n            resolve(ret[len]);\n          }\n        });\n      });\n    },\n    ...config,\n  });\n}\n```\n\n这里主要调用了 asyncComponent 函数，接下来我们再看一下这个函数：\n\n```javascript\nfunction asyncComponent(config) {\n  const { resolve } = config;\n\n  return class DynamicComponent extends Component {\n    constructor(...args) {\n      super(...args);\n      this.LoadingComponent =\n        config.LoadingComponent || defaultLoadingComponent;\n      this.state = {\n        AsyncComponent: null,\n      };\n      this.load();\n    }\n\n    componentDidMount() {\n      this.mounted = true;\n    }\n\n    componentWillUnmount() {\n      this.mounted = false;\n    }\n\n    load() {\n      resolve().then((m) => {\n        const AsyncComponent = m.default || m;\n        if (this.mounted) {\n          this.setState({ AsyncComponent });\n        } else {\n          this.state.AsyncComponent = AsyncComponent; // eslint-disable-line\n        }\n      });\n    }\n\n    render() {\n      const { AsyncComponent } = this.state;\n      const { LoadingComponent } = this;\n      if (AsyncComponent) return <AsyncComponent {...this.props} />;\n\n      return <LoadingComponent {...this.props} />;\n    }\n  };\n}\n```\n\n这个函数逻辑比较简洁，我们分析一下动态加载流程；\n\n* 在 constructor 里面调用 `this.load();` ( LoadingComponent 为占位 component)\n* 在 `this.load();` 函数里面调用 `dynamic` 函数返回的 resolve 方法\n* resolve 方法实际上是一个 Promise，把相关 models 和 component 加载完之后 resolve (区分这两个 resolve)\n* 加载完成之后返回 AsyncComponent (即加载的 Component)\n\n动态加载主流程结束，至于动态加载的代码分割工作，可以使用 webpack3 的 `import()` 动态加载能力(例子中也是这样使用的)。\n\n\n#### 第五步\n\n第五步骤就是 start 了：\n\n```javascript\napp.start('#root');\n```\n\n这个时候如果我们在 start 函数中传入 DomElement 或者 DomQueryString，就会直接启动应用了，如果我们这个时候不传入任何内容，实际上返回的是一个`<Provider />` (React Component)，便于服务端渲染。 相关判断逻辑如下：\n\n```javascript\n if (container) {\n      render(container, store, app, app._router);\n      app._plugin.apply('onHmr')(render.bind(null, container, store, app));\n    } else {\n      return getProvider(store, this, this._router);\n    }\n```\n\n至此，主要流程结束，以上几个步骤也包括了 dva 源码做的主要工作。\n\n当然 dva 源码中还有一些比如前缀处理等工作，但是相比于以上内容非常简单，所以在这里不进行分析了。\n\n\n### dva-core 文件目录\n\ndva-core中的源码文件目录以及其功能:\n\n* checkModel 对我们定义的 Model 进行检查是否符合要求\n* constants 非常简单的常量文件，目前只定义了一个常量：NAMESPACE_SEP(/)\n* cratePromiseMiddleware 笔者自己定义的 redux 插件\n* createStore 封装了 redux 原生的 createStore\n* getReducer 这里面的函数其实主要就是调用了 handleActions 文件导出的函数\n* getSaga 将用户输入的 effects 部分的键值对函数进行管理\n* handleActions 是将 dva 风格的 reducer 和 state 转化成 redux 本来接受的那种方式\n* index 主入口文件\n* Plugin 插件类：可以管理不同钩子事件的回调函数，拥有增加、获取、执行钩子函数的功能\n* perfixedDispatch 该文件提供了对 Dispatch 增加前缀的工具性函数 prefixedDispatch\n* prefixNamespace 该文件提供了对 reducer 和 effects 增加前缀的工具性函数 prefixNamespace\n* prefixType 判断是 reducer 还是 effects\n* subscriptions 该文件提供了运行 subscriptions 和调用用户返回的 unlisten 函数以及删除缓存的功能\n* utils 提供一些非常基础的工具函数\n\n\n### 优势总结\n\n* 动态 model，已经封装好了整套调用，动态添加/删除 model 变得非常简单\n* 默认封装好了管理 effects 的方式，有限可选可配置，降低学习成本的同时代码更利于维护\n* 易于上手，集成redux、redux-saga、react-router等常用功能\n\n\n### 劣势总结\n\n* 版本区隔不明显，dva 有 1.x 和 2.x 两种版本，之间API有些差异，但是官网提供的一些样例等中没有说明基于的版本，并且有的还是基于旧版本的，会给新手带来很多疑惑。\n* 内容繁杂，但是却没有一个整合性质的官方网站，大都是通过 list 的形式列下来写在README的。\n* 目前比如动态加载等还存在着一些问题，和直接采用react配套工具写的效果有所区别。\n* 很多 issues 不知道为什么就被关闭了，作者在最后也并未给出合理的解释。\n* dva2 之后有点将 effects 和 actions 混淆，这一点我也并不是非常认同，当然原作者可能有自己的考虑，这里不过多评议。\n\n总之，作为一个个人主力的项目(主要开发者贡献了99%以上的代码)，可以看出作者的功底深厚，经验丰富，但是由于这样一个体系化的东西牵扯内容较多，并且非常受制于react、redux、react-router、redux-saga等的版本影响，**不建议具备一定规模的非阿里系团队在生产环境中使用**，但是如果是快速成型的中小型项目或者个人应用，使用起来还是有很大帮助的。\n\n### TODOS\n\n笔者也在准备做一个和 dva 处于同一性质，但是设计、实现和使用有所区别的框架，希望能够尽快落成。\n","slug":"dva源码解读","published":1,"updated":"2021-12-23T05:50:07.553Z","_id":"ckxijpqtm002od3mrhbdofwqa","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h3><p>本文章用于个人学习研究，并不代表 dva 团队的任何观点。</p>\n<p>原文以及包含一定注释的代码见<a href=\"https://github.com/aircloud/dva-analysis\">这里</a>，若有问题也可以在<a href=\"https://github.com/aircloud/dva-analysis/issues\">这里</a>进行讨论</p>\n<h3 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h3><h4 id=\"为什么是dva\"><a href=\"#为什么是dva\" class=\"headerlink\" title=\"为什么是dva?\"></a>为什么是dva?</h4><p>笔者对 dva 的源代码进行解读，主要考虑到 dva 并不是一个和我们熟知的主流技术无关的从0到1的框架，相反，它是对主流技术进行整合，提炼，从而形成一种最佳实践，分析 dva，意味着我们可以对自己掌握的很多相关技术进行回顾，另外，dva 的代码量并不多，也不至于晦涩难懂，可以给我们平时的业务开发以启发。</p>\n<p>本文章作为 dva 的源码解读文章，并不面向新手用户，读者应当有一定的 react 使用经验和 ECMAscript 2015+ 的使用经验，并且应当了解 redux 和 redux-saga，以及对 dva 的使用有所了解(可以从<a href=\"https://github.com/dvajs/dva/blob/master/README_zh-CN.md#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-dva-\">这里</a>了解为什么需要使用 dva)</p>\n<p>重点推荐:</p>\n<ul>\n<li>通过<a href=\"https://github.com/dvajs/dva-knowledgemap\">这里</a>的内容了解使用dva的最小知识集</li>\n<li>通过<a href=\"https://redux-saga-in-chinese.js.org/docs/introduction/index.html\">这里</a>学习 redux-saga</li>\n</ul>\n<p>其他推荐：</p>\n<ul>\n<li><a href=\"https://github.com/dvajs/dva/blob/master/docs/Concepts_zh-CN.md\">dva的概念</a></li>\n<li><a href=\"https://github.com/dvajs/dva/blob/master/docs/API_zh-CN.md\">dva的全部API</a></li>\n<li><a href=\"https://github.com/sorrycc/blog/issues/1\">React+Redux 最佳实践</a></li>\n<li><a href=\"http://slides.com/sorrycc/dva#/\">React在蚂蚁金服的实践</a></li>\n<li><a href=\"https://github.com/sorrycc/blog/issues/48\">dva 2.0的改进</a></li>\n<li><a href=\"http://cn.redux.js.org/docs/recipes/ComputingDerivedData.html\">ReSelect介绍</a></li>\n<li><a href=\"https://www.jianshu.com/p/04d3fefea8d7\">浅析Redux 的 store enhancer</a></li>\n</ul>\n<p>几个 dva 版本之间的关系:</p>\n<ul>\n<li><a href=\"mailto:&#x64;&#118;&#x61;&#64;&#50;&#46;&#x30;\">&#x64;&#118;&#x61;&#64;&#50;&#46;&#x30;</a>：基于 react 和 react-router@4</li>\n<li><a href=\"mailto:&#100;&#118;&#97;&#x2d;&#114;&#101;&#x61;&#x63;&#116;&#45;&#114;&#x6f;&#x75;&#x74;&#101;&#114;&#x2d;&#x33;&#x40;&#49;&#x2e;&#48;\">&#100;&#118;&#97;&#x2d;&#114;&#101;&#x61;&#x63;&#116;&#45;&#114;&#x6f;&#x75;&#x74;&#101;&#114;&#x2d;&#x33;&#x40;&#49;&#x2e;&#48;</a>：基于 react 和 react-router@3</li>\n<li><a href=\"mailto:&#100;&#118;&#97;&#45;&#x6e;&#x6f;&#45;&#x72;&#x6f;&#117;&#x74;&#101;&#x72;&#x40;&#49;&#x2e;&#x30;\">&#100;&#118;&#97;&#45;&#x6e;&#x6f;&#45;&#x72;&#x6f;&#117;&#x74;&#101;&#x72;&#x40;&#49;&#x2e;&#x30;</a>：无路由版本，适用于多页面场景，可以和 next.js 组合使用</li>\n<li><a href=\"mailto:&#100;&#x76;&#x61;&#45;&#x63;&#111;&#114;&#x65;&#x40;&#49;&#x2e;&#48;\">&#100;&#x76;&#x61;&#45;&#x63;&#111;&#114;&#x65;&#x40;&#49;&#x2e;&#48;</a>：仅封装了 redux 和 redux-saga</li>\n</ul>\n<p>我们本次主要分析目标为 <a href=\"mailto:&#100;&#118;&#x61;&#64;&#x32;&#x2e;&#48;\">&#100;&#118;&#x61;&#64;&#x32;&#x2e;&#48;</a> 和 <a href=\"mailto:&#100;&#118;&#x61;&#x2d;&#99;&#x6f;&#114;&#x65;&#64;&#49;&#x2e;&#48;\">&#100;&#118;&#x61;&#x2d;&#99;&#x6f;&#114;&#x65;&#64;&#49;&#x2e;&#48;</a></p>\n<h3 id=\"我们为什么需要-redux-saga\"><a href=\"#我们为什么需要-redux-saga\" class=\"headerlink\" title=\"我们为什么需要 redux-saga\"></a>我们为什么需要 redux-saga</h3><p>目前，在大多数项目开发中，我们现在依然采用的是redux-thunk + async/await (或 Promise)。</p>\n<p>实际上这个十几行的插件已经完全可以解决大多是场景下的问题了，如果你在目前的工作中正在使用这一套方案并且能够完全将当下的需求应付自如并且没有什么凌乱的地方，其实也是没有必要换成redux-saga的。</p>\n<p>接下来我们讲 redux-saga，先看名字：saga，这个术语常用于CQRS架构，代表查询与责任分离。</p>\n<p>相比于 redux-thunk，前者通常是把数据查询等请求放在 actions 中(不纯净的 actions)，并且这些 actions 可以继续回调调用其他 actions(纯净的 actions)，从而完成数据的更新；而 redux-saga，则保持了 actions 的纯粹性，单独抽出一层专门来处理数据请求等操作(saga函数)。</p>\n<p>这样做还有另外一些好处：</p>\n<ul>\n<li>由于我们已经将数据处理数据请求等异步操作抽离出来了，并且通过 generator 来处理，我们便可以方便地进行多种异步管理：比如同时按顺序执行多个任务、在多个异步任务中启动race等。</li>\n<li>这样做可以延长任务的生命周期，我们的一次调用可以不再是一个”调完即走”的过程，还可以是一个LLT（Long Lived Transaction)的事物处理过程，比如我们可以将用户的登入、登出的管理放在一个saga函数中处理。</li>\n</ul>\n<p>当然，redux-saga还有比如拥有有诸多常用并且声明式易测的 Effects、可以无阻塞的fork等一些更复杂的异步操作和管理方法，如果应用中有较多复杂的异步操作流程，使用redux-saga无疑会让条理更加清楚。</p>\n<p>当然，本文的目的不是介绍或者安利redux-saga，只是因为redux-saga是 dva 的一个基础，相关概念点到为止，如需了解更多请自行参考资料。</p>\n<h3 id=\"dva-源码解读\"><a href=\"#dva-源码解读\" class=\"headerlink\" title=\"dva 源码解读\"></a>dva 源码解读</h3><p>我们的源码分析流程是这样的：通过一个使用 dva 开发的例子，随着其对 dva 函数的逐步调用，来分析内部 dva 相关函数的实现原理。</p>\n<p>我们分析采用的例子是 dva 官方提供的一个增删改查的应用，可以在<a href=\"https://github.com/dvajs/dva/tree/rewrite-dynamic\">这里</a>找到它的源代码。</p>\n<p>我们先看该例子的入口文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> dva <span class=\"keyword\">from</span> <span class=\"string\">&#x27;dva&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> createHistory <span class=\"keyword\">from</span> <span class=\"string\">&#x27;history/createBrowserHistory&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> createLoading <span class=\"keyword\">from</span> <span class=\"string\">&#x27;dva-loading&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; message &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;antd&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;./index.css&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ERROR_MSG_DURATION = <span class=\"number\">3</span>; <span class=\"comment\">// 3 秒</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. Initialize</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = dva(&#123;</span><br><span class=\"line\">  <span class=\"attr\">history</span>: createHistory(),</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">onError</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    message.error(e.message, ERROR_MSG_DURATION);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. Plugins</span></span><br><span class=\"line\">app.use(createLoading());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. Model</span></span><br><span class=\"line\"><span class=\"comment\">// Moved to router.js</span></span><br><span class=\"line\"><span class=\"comment\">// 这里的 Model 被转移到了动态加载的 router 里面，我们也可以如下写：</span></span><br><span class=\"line\"><span class=\"comment\">// app.model(require(&#x27;./models/users&#x27;));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. Router</span></span><br><span class=\"line\">app.router(<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./router&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. Start</span></span><br><span class=\"line\">app.start(<span class=\"string\">&#x27;#root&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们发现dva从初始化配置到最后的start(现在的dva start函数在不传入container的情况下可以返回React Component，便于服务端渲染等，但这里我们还是按照例子的写法来)。</p>\n<p>这里我们先有必要解释一下，dva 在当前依据能力和依赖版本的不同，有多个可引入的版本，我们的例子和所要分析的源代码都是基于 react-router V4 的 dva 版本。</p>\n<p>在源代码中，相关目录主要为 dva 目录(packages/dva) 和 dva-core(packages/dva-core)目录，前者主要拥有history管理、router、动态加载等功能，而后者是不依赖这些内容的基础模块部分，为前者所引用</p>\n<h4 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h4><p>第一步这里传入了两个内容：(dva构造函数总共可以传入那些 opts，会在下文中进行说明)</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const app = dva(&#123;</span><br><span class=\"line\">  history: createHistory(),</span><br><span class=\"line\">  onError(<span class=\"name\">e</span>) &#123;</span><br><span class=\"line\">    message.error(<span class=\"name\">e</span>.message, ERROR_MSG_DURATION)<span class=\"comment\">;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>这一步的相关核心代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">opts = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> history = opts.history || createHashHistory(); <span class=\"comment\">// 默认为 HashHistory</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> createOpts = &#123;</span><br><span class=\"line\">    <span class=\"attr\">initialReducer</span>: &#123;</span><br><span class=\"line\">      routing, <span class=\"comment\">// 来自 react-router-redux 的 routerReducer</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">setupMiddlewares</span>(<span class=\"params\">middlewares</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        routerMiddleware(history), <span class=\"comment\">// 来自 react-router-redux 的 routerMiddleware</span></span><br><span class=\"line\">        ...middlewares,</span><br><span class=\"line\">      ];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">setupApp</span>(<span class=\"params\">app</span>)</span> &#123;</span><br><span class=\"line\">      app._history = patchHistory(history); </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> app = core.create(opts, createOpts);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldAppStart = app.start;</span><br><span class=\"line\">  app.router = router;</span><br><span class=\"line\">  app.start = start;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 一些用到的函数的定义...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>这里面大多数内容都比较简单，这里面提两个地方：</p>\n<ol>\n<li>patchHistory：</li>\n</ol>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function patchHistory(<span class=\"keyword\">history</span>) &#123;</span><br><span class=\"line\">  const oldListen = <span class=\"keyword\">history</span>.listen;</span><br><span class=\"line\">  <span class=\"keyword\">history</span>.listen = (callback) =&gt; &#123;</span><br><span class=\"line\">    callback(<span class=\"keyword\">history</span>.location);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldListen.call(<span class=\"keyword\">history</span>, callback);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">history</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显然，这里的意思是让第一次被绑定 listener 的时候执行一遍 callback，可以用于初始化相关操作。</p>\n<p>我们可以在<code>router.js</code>中添加如下代码来验证：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.listen(<span class=\"function\"><span class=\"params\">(location, action)</span>=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;history listen:&#x27;</span>, location, action)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在完成可选项的构造之后，调用了 dva-core 中暴露的 create 函数。</li>\n</ol>\n<p>create 函数本身也并不复杂，核心代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">hooksAndOpts = &#123;&#125;, createOpts = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    initialReducer,</span><br><span class=\"line\">    setupApp = noop,</span><br><span class=\"line\">  &#125; = createOpts;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> plugin = <span class=\"keyword\">new</span> Plugin(); <span class=\"comment\">// 实例化钩子函数管理类</span></span><br><span class=\"line\">  plugin.use(filterHooks(hooksAndOpts)); <span class=\"comment\">// 这个时候先对 obj 进行清理，清理出在我们定义的类型之外的 hooks，之后进行统一绑定</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> app = &#123;</span><br><span class=\"line\">    <span class=\"attr\">_models</span>: [</span><br><span class=\"line\">      prefixNamespace(&#123; ...dvaModel &#125;), <span class=\"comment\">// 前缀处理</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">_store</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">_plugin</span>: plugin,</span><br><span class=\"line\">    <span class=\"attr\">use</span>: plugin.use.bind(plugin),</span><br><span class=\"line\">    model, <span class=\"comment\">// 下文定义</span></span><br><span class=\"line\">    start, <span class=\"comment\">// 下文定义</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> app;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">//一些函数的定义</span></span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>这里面我们可以看到，这里的 <code>hooksAndOpts</code> 实际上就是一开始我们构造 dva 的时候传入的 opts 对象经过处理之后的结果。</p>\n<p>我们可以传入的可选项，实际上都在 <code>Plugin.js</code> 中写明了:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">const hooks</span> = [</span><br><span class=\"line\">  <span class=\"string\">&#x27;onError&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onStateChange&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onAction&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onHmr&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onReducer&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onEffect&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;extraReducers&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;extraEnhancers&#x27;</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>具体 <a href=\"https://github.com/dvajs/dva/blob/master/docs/API_zh-CN.md#appusehooks\">hooks的作用可以在这里进行查阅</a>。</p>\n<p>Plugin 插件管理类(实际上我认为称其为钩子函数管理类比较合适)除了定义了上文的使用到的use方法(挂载插件)、还有apply方法(执行某一个钩子下挂载的所有回调)、get方法(获取某一个钩子下的所有回调，返回数组)</p>\n<h4 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h4><p>这里的第二步比较简洁：我们知道实际上这里就是使用了<code>plugin.use</code>方法挂载了一个插件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(createLoading()); <span class=\"comment\">// 需要注意，插件挂载需要在 app.start 之前</span></span><br></pre></td></tr></table></figure>\n\n<p>createLoading 这个插件实际上是官方提供的 Loading 插件，通过这个插件我们可以非常方便地进行 Loading 的管理，无需进行手动管理，我们可以先<a href=\"https://www.jianshu.com/p/61fe7a57fad4\">看一篇文章</a>来简单了解一下。</p>\n<p>这个插件看似神奇，实际上原理也比较简单，主要用了<code>onEffect</code>钩子函数(装饰器)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onEffect</span>(<span class=\"params\">effect, &#123; put &#125;, model, actionType</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; namespace &#125; = model;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        (only.length === <span class=\"number\">0</span> &amp;&amp; except.length === <span class=\"number\">0</span>)</span><br><span class=\"line\">        || (only.length &gt; <span class=\"number\">0</span> &amp;&amp; only.indexOf(actionType) !== -<span class=\"number\">1</span>)</span><br><span class=\"line\">        || (except.length &gt; <span class=\"number\">0</span> &amp;&amp; except.indexOf(actionType) === -<span class=\"number\">1</span>)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> put(&#123; <span class=\"attr\">type</span>: SHOW, <span class=\"attr\">payload</span>: &#123; namespace, actionType &#125; &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> effect(...args);</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> put(&#123; <span class=\"attr\">type</span>: HIDE, <span class=\"attr\">payload</span>: &#123; namespace, actionType &#125; &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> effect;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>结合基于的redux-saga，在目标异步调用开始的时候<code>yield put(&#123; type: SHOW, payload: &#123; namespace, actionType &#125; &#125;);</code>，在异步调用结束的时候<code>yield put(&#123; type: HIDE, payload: &#123; namespace, actionType &#125; &#125;);</code>，这样就可以管理异步调用开始和结束的Loading状态了。</p>\n<h4 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h4><p>第三步这里其实省略了，因为使用了动态加载，将 Models 定义的内容和 React Component 进行了动态加载，实际上也可以按照注释的方法来写。</p>\n<p>但是没有关系，我们还是可以分析 models 引入的文件中做了哪些事情(下面列出的代码在原基础上进行了一些简化):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> queryString <span class=\"keyword\">from</span> <span class=\"string\">&#x27;query-string&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> usersService <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../services/users&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">namespace</span>: <span class=\"string\">&#x27;users&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">list</span>: [],</span><br><span class=\"line\">    <span class=\"attr\">total</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">page</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">reducers</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">save</span>(<span class=\"params\">state, &#123; payload: &#123; data: list, total, page &#125; &#125;</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; ...state, list, total, page &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">effects</span>: &#123;</span><br><span class=\"line\">    *<span class=\"function\"><span class=\"title\">fetch</span>(<span class=\"params\">&#123; payload: &#123; page = <span class=\"number\">1</span> &#125; &#125;, &#123; call, put &#125;</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; data, headers &#125; = <span class=\"keyword\">yield</span> call(usersService.fetch, &#123; page &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> put(&#123;</span><br><span class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">&#x27;save&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">payload</span>: &#123;</span><br><span class=\"line\">          data,</span><br><span class=\"line\">          <span class=\"attr\">total</span>: <span class=\"built_in\">parseInt</span>(headers[<span class=\"string\">&#x27;x-total-count&#x27;</span>], <span class=\"number\">10</span>),</span><br><span class=\"line\">          <span class=\"attr\">page</span>: <span class=\"built_in\">parseInt</span>(page, <span class=\"number\">10</span>),</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    *<span class=\"function\"><span class=\"title\">reload</span>(<span class=\"params\">action, &#123; put, select &#125;</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> page = <span class=\"keyword\">yield</span> select(<span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.users.page);</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> put(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;fetch&#x27;</span>, <span class=\"attr\">payload</span>: &#123; page &#125; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">subscriptions</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\">&#123; dispatch, history &#125;</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> history.listen(<span class=\"function\">(<span class=\"params\">&#123; pathname, search &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> query = queryString.parse(search);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pathname === <span class=\"string\">&#x27;/users&#x27;</span>) &#123;</span><br><span class=\"line\">          dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;fetch&#x27;</span>, <span class=\"attr\">payload</span>: query &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这些内容，我们通过<code>app.model(require(&#39;./models/users&#39;));</code>就可以引入。</p>\n<p>实际上，model 函数本身还是比较简单的，但由于 dva 拥有 model 动态加载的能力，实际上调用 app.start 前和 app.start 后model函数是不一样的。</p>\n<p>调用 start 函数前，我们直接挂载即可(因为start函数中会对所有model进行遍历性统一处理，所以无需过多处理)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">model</span>(<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">&#x27;production&#x27;</span>) &#123;</span><br><span class=\"line\">      checkModel(m, app._models);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    app._models.push(prefixNamespace(m));</span><br><span class=\"line\">    <span class=\"comment\">// 把 model 注册到 app 的 _models 里面，但是当 app start 之后，就不能仅仅用这种方法了，需要 injectModel</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用了 start 函数之后，model函数被替换成如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">injectModel</span>(<span class=\"params\">createReducer, onError, unlisteners, m</span>) </span>&#123;</span><br><span class=\"line\">    model(m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = app._store;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.reducers) &#123;</span><br><span class=\"line\">      store.asyncReducers[m.namespace] = getReducer(m.reducers, m.state);</span><br><span class=\"line\">      store.replaceReducer(createReducer(store.asyncReducers));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.effects) &#123;</span><br><span class=\"line\">      store.runSaga(app._getSaga(m.effects, m, onError, plugin.get(<span class=\"string\">&#x27;onEffect&#x27;</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.subscriptions) &#123;</span><br><span class=\"line\">      unlisteners[m.namespace] = runSubscription(m.subscriptions, m, app, onError);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>我们首先分析第一个 if 中的内容</strong>：首先通过getReducer函数将转换好的 reducers 挂载(或替换)到 store.asyncReducers[m.namespace] 中，然后通过 redux 本身提供的能力 replaceReducer 完成 reducer 的替换。</p>\n<p>这里我们需要注意 getReducer 函数，实际上，dva 里面 reducers 写法和我们之前直接使用 redux 的写法略有不同：</p>\n<p>我们这里的 reducers，实际上要和 action 中的 actionType 同名的 reducer，所以这里我们没有必要去写 switch case 了，对于某一个 reducer 来说其行为应该是确定的，这给 reducers 的写法带来了一定的简化，当然，我们可以使用 extraReducers 定义我们之前习惯的那种比较复杂的 reducers。</p>\n<p><strong>接下来我们分析第二个 if 中的内容</strong>：第二个函数首先获取到了我们定义的 effects 并通过 _getSaga 进行处理，然后使用 <code>runSaga</code>(实际上就是createSagaMiddleware().run，来自于redux-saga) 进行执行。</p>\n<p>实际上，这里的 <code>_getSaga</code> 函数比较复杂，我们接下来重点介绍这个函数。</p>\n<p><code>_getSaga</code> 函数由 <code>getSaga.js</code> 暴露，其定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSaga</span>(<span class=\"params\">resolve, reject, effects, model, onError, onEffect</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;  <span class=\"comment\">// 返回一个函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> effects) &#123;  <span class=\"comment\">// 这个函数对 effects 里面的所有键</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(effects, key)) &#123; <span class=\"comment\">// 先判断一下键是属于自己的</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> watcher = getWatcher(resolve, reject, key, effects[key], model, onError, onEffect);</span><br><span class=\"line\">        <span class=\"comment\">// 然后调用getWatch获取watcher</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> task = <span class=\"keyword\">yield</span> sagaEffects.fork(watcher); <span class=\"comment\">// 利用 fork 开启一个 task</span></span><br><span class=\"line\">        <span class=\"keyword\">yield</span> sagaEffects.fork(<span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 这样写的目的是，如果我们移除了这个 model 要及时结束掉</span></span><br><span class=\"line\">          <span class=\"keyword\">yield</span> sagaEffects.take(<span class=\"string\">`<span class=\"subst\">$&#123;model.namespace&#125;</span>/@@CANCEL_EFFECTS`</span>);</span><br><span class=\"line\">          <span class=\"keyword\">yield</span> sagaEffects.cancel(task);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>getWatcher 的一些核心代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getWatcher</span>(<span class=\"params\">resolve, reject, key, _effect, model, onError, onEffect</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> effect = _effect;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> type = <span class=\"string\">&#x27;takeEvery&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ms;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(_effect)) &#123;</span><br><span class=\"line\">    effect = _effect[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> opts = _effect[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 对 opts 进行一定的校验</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">sagaWithCatch</span>(<span class=\"params\">...args</span>) </span>&#123; <span class=\"comment\">// 都会调用这个过程</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> sagaEffects.put(&#123; <span class=\"attr\">type</span>: <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span><span class=\"subst\">$&#123;NAMESPACE_SEP&#125;</span>@@start`</span> &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> ret = <span class=\"keyword\">yield</span> effect(...args.concat(createEffects(model)));</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> sagaEffects.put(&#123; <span class=\"attr\">type</span>: <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span><span class=\"subst\">$&#123;NAMESPACE_SEP&#125;</span>@@end`</span> &#125;);</span><br><span class=\"line\">      resolve(key, ret);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      onError(e);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!e._dontReject) &#123;</span><br><span class=\"line\">        reject(key, e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> sagaWithOnEffect = applyOnEffect(onEffect, sagaWithCatch, model, key); </span><br><span class=\"line\">  <span class=\"comment\">// 挂载 onEffect 钩子</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;watcher&#x27;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> sagaWithCatch;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;takeLatest&#x27;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> takeLatest(key, sagaWithOnEffect);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;throttle&#x27;</span>: <span class=\"comment\">// 起到节流的效果，在 ms 时间内仅仅会被触发一次</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> throttle(ms, key, sagaWithOnEffect);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> takeEvery(key, sagaWithOnEffect);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数的工作，可以主要分为以下三个部分：</p>\n<p>1.将 effect 包裹成 sagaWithCatch，除了便于错误处理和增加前后钩子，值得我们注意的是 resolve 和 reject，</p>\n<p>这个 resolve 和 reject，实际上是来自<code>createPromiseMiddleware.js</code></p>\n<p>我们知道，我们在使用redux-saga的过程中，实际上是监听未来的action，并执行 effects，所以我们在一个 effects 函数中执行一些异步操作，然后 put(dispatch) 一个 action，还是会被监听这个 action 的其他 saga 监听到。</p>\n<p>所以就有如下场景：我们 dispatch 一个 action，这个时候如果我们想获取到什么时候监听这个 action 的 saga 中的异步操作执行结束，是办不到的(因为不是所有的时候我们都把所有处理逻辑写在 saga 中)，所以我们的 dispatch 有的时候需要返回一个 Promise 从而我们可以进行异步结束后的回调(这个 Promise 在监听者 saga 异步执行完后被决议，见上文<code>sagaWithCatch</code>函数源代码)。</p>\n<p>如果我讲的还是比较混乱，也可以参考<a href=\"https://github.com/dvajs/dva/issues/175\">这个issue</a></p>\n<p>对于这个情况，我认为这是 dva 代码最精彩的地方之一，作者通过定义如下的middleware:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> middleware = <span class=\"function\">() =&gt;</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">const</span> &#123; type &#125; = action;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isEffect(type)) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">       map[type] = &#123;</span><br><span class=\"line\">         <span class=\"attr\">resolve</span>: wrapped.bind(<span class=\"literal\">null</span>, type, resolve),</span><br><span class=\"line\">         <span class=\"attr\">reject</span>: wrapped.bind(<span class=\"literal\">null</span>, type, reject),</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> next(action);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapped</span>(<span class=\"params\">type, fn, args</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (map[type]) <span class=\"keyword\">delete</span> map[type];</span><br><span class=\"line\">   fn(args);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">type, args</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (map[type]) &#123;</span><br><span class=\"line\">     map[type].resolve(args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">type, args</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (map[type]) &#123;</span><br><span class=\"line\">     map[type].reject(args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且在上文的<code>sagaWithCatch</code>相关effect执行结束的时候调用 resolve，让 dispatch 返回了一个 Promise。</p>\n<p>当然，上面这段代码还是有点问题的，这样会导致同名 reducer 和 effect 不会 fallthrough（即两者都执行），因为都已经返回了，action 便不会再进一步传递，关于这样设计的好坏，在<a href=\"https://github.com/sorrycc/blog/issues/48\">这里</a>有过一些讨论，笔者不进行展开表述。</p>\n<p>2.在上面冗长的第一步之后，又通过<code>applyOnEffect</code>函数包裹了<code>OnEffect</code>的钩子函数，这相当于是一种<code>compose</code>，(上文的 dva-loading 中间件实际上就是在这里被处理的)其实现对于熟悉 redux 的同学来说应该不难理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyOnEffect</span>(<span class=\"params\">fns, effect, model, key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> fn <span class=\"keyword\">of</span> fns) &#123;</span><br><span class=\"line\">    effect = fn(effect, sagaEffects, model, key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> effect;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.最后，根据我们定义的type(默认是<code>takeEvery</code>，也就是都执行)，来选择不同的 saga，takeLatest 即为只是执行最近的一个，throttle则起到节流的效果，一定时间内仅仅允许被触发一次，这些都是 redux-saga 的内部实现，dva 也是基本直接引用，因此在这里不进行展开。</p>\n<p><strong>最后我们分析<code>injectModel</code>第三个<code>if</code>中的内容</strong>:处理<code>subscriptions</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (m.subscriptions) &#123;</span><br><span class=\"line\">  unlisteners[m.namespace] = runSubscription(m.subscriptions, m, app, onError);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>subscriptions</code>可以理解为和这个model有关的全局监听，但是相对独立。这一个步骤首先调用<code>runSubscription</code>来一个一个调用我们的<code>subscriptions</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">subs, model, app, onError</span>) </span>&#123; <span class=\"comment\">// 在index.js中被重命名为 runSubscription</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> funcs = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nonFuncs = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> subs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(subs, key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> sub = subs[key];</span><br><span class=\"line\">      <span class=\"keyword\">const</span> unlistener = sub(&#123;</span><br><span class=\"line\">        <span class=\"attr\">dispatch</span>: prefixedDispatch(app._store.dispatch, model),</span><br><span class=\"line\">        <span class=\"attr\">history</span>: app._history,</span><br><span class=\"line\">      &#125;, onError);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isFunction(unlistener)) &#123;</span><br><span class=\"line\">        funcs.push(unlistener);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        nonFuncs.push(key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; funcs, nonFuncs &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正如我们所期待的，<code>run</code>函数就是一个一个执行<code>subscriptions</code>，但是这里有一点需要我们注意的，我们定义的<code>subscriptions</code>应该是需要返回一个<code>unlistener</code>来返回接触函数，这样当整个 model 被卸载的时候 dva 会自动调用这个接解除函数(也就是为什么这里的返回函数被命名为<code>unlistener</code>)</p>\n<h4 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h4><p>源代码中的第四步，是对 router 的挂载：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.router(<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./router&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p><code>require(&#39;./router&#39;)</code>返回的内容在源代码中经过一系列引用传递最后直接被构造成 React Component 并且最终调用 ReactDom.render 进行渲染，这里没有什么好说的，值得一提的就是 router 的动态加载。</p>\n<p>动态加载在该样例中是这样使用的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router, Switch, Route &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;dva/router&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> dynamic <span class=\"keyword\">from</span> <span class=\"string\">&#x27;dva/dynamic&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">RouterConfig</span>(<span class=\"params\">&#123; history, app &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> IndexPage = dynamic(&#123;</span><br><span class=\"line\">    app,</span><br><span class=\"line\">    <span class=\"attr\">component</span>: <span class=\"function\">() =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./routes/IndexPage&#x27;</span>),</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Users = dynamic(&#123;</span><br><span class=\"line\">    app,</span><br><span class=\"line\">    <span class=\"attr\">models</span>: <span class=\"function\">() =&gt;</span> [</span><br><span class=\"line\">      <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./models/users&#x27;</span>),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">component</span>: <span class=\"function\">() =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./routes/Users&#x27;</span>),</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  history.listen(<span class=\"function\">(<span class=\"params\">location, action</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;history listen:&#x27;</span>, location, action)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">history</span>=<span class=\"string\">&#123;history&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">exact</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/&quot;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;IndexPage&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">exact</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/users&quot;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Users&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看出，主要就是利用<code>dva/dynamic.js</code>暴露的 dynamic 函数进行动态加载，接下来我们简单看一下 dynamic 函数做了什么:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dynamic</span>(<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; app, <span class=\"attr\">models</span>: resolveModels, <span class=\"attr\">component</span>: resolveComponent &#125; = config;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> asyncComponent(&#123;</span><br><span class=\"line\">    <span class=\"attr\">resolve</span>: config.resolve || <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> models = <span class=\"keyword\">typeof</span> resolveModels === <span class=\"string\">&#x27;function&#x27;</span> ? resolveModels() : [];</span><br><span class=\"line\">      <span class=\"keyword\">const</span> component = resolveComponent();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.all([...models, component]).then(<span class=\"function\">(<span class=\"params\">ret</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!models || !models.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> resolve(ret[<span class=\"number\">0</span>]);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> len = models.length;</span><br><span class=\"line\">            ret.slice(<span class=\"number\">0</span>, len).forEach(<span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">              m = m.default || m;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(m)) &#123;</span><br><span class=\"line\">                m = [m];</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              m.map(<span class=\"function\"><span class=\"params\">_</span> =&gt;</span> registerModel(app, _)); <span class=\"comment\">// 注册所有的 model</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            resolve(ret[len]);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...config,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里主要调用了 asyncComponent 函数，接下来我们再看一下这个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncComponent</span>(<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; resolve &#125; = config;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">...args</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(...args);</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.LoadingComponent =</span><br><span class=\"line\">        config.LoadingComponent || defaultLoadingComponent;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">        <span class=\"attr\">AsyncComponent</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.load();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.mounted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">componentWillUnmount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.mounted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">load</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      resolve().then(<span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> AsyncComponent = m.default || m;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.mounted) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">this</span>.setState(&#123; AsyncComponent &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">this</span>.state.AsyncComponent = AsyncComponent; <span class=\"comment\">// eslint-disable-line</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; AsyncComponent &#125; = <span class=\"built_in\">this</span>.state;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; LoadingComponent &#125; = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (AsyncComponent) <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AsyncComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">LoadingComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数逻辑比较简洁，我们分析一下动态加载流程；</p>\n<ul>\n<li>在 constructor 里面调用 <code>this.load();</code> ( LoadingComponent 为占位 component)</li>\n<li>在 <code>this.load();</code> 函数里面调用 <code>dynamic</code> 函数返回的 resolve 方法</li>\n<li>resolve 方法实际上是一个 Promise，把相关 models 和 component 加载完之后 resolve (区分这两个 resolve)</li>\n<li>加载完成之后返回 AsyncComponent (即加载的 Component)</li>\n</ul>\n<p>动态加载主流程结束，至于动态加载的代码分割工作，可以使用 webpack3 的 <code>import()</code> 动态加载能力(例子中也是这样使用的)。</p>\n<h4 id=\"第五步\"><a href=\"#第五步\" class=\"headerlink\" title=\"第五步\"></a>第五步</h4><p>第五步骤就是 start 了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.start(<span class=\"string\">&#x27;#root&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候如果我们在 start 函数中传入 DomElement 或者 DomQueryString，就会直接启动应用了，如果我们这个时候不传入任何内容，实际上返回的是一个<code>&lt;Provider /&gt;</code> (React Component)，便于服务端渲染。 相关判断逻辑如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (container) &#123;</span><br><span class=\"line\">     render(container, store, app, app._router);</span><br><span class=\"line\">     app._plugin.apply(<span class=\"string\">&#x27;onHmr&#x27;</span>)(render.bind(<span class=\"literal\">null</span>, container, store, app));</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> getProvider(store, <span class=\"built_in\">this</span>, <span class=\"built_in\">this</span>._router);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，主要流程结束，以上几个步骤也包括了 dva 源码做的主要工作。</p>\n<p>当然 dva 源码中还有一些比如前缀处理等工作，但是相比于以上内容非常简单，所以在这里不进行分析了。</p>\n<h3 id=\"dva-core-文件目录\"><a href=\"#dva-core-文件目录\" class=\"headerlink\" title=\"dva-core 文件目录\"></a>dva-core 文件目录</h3><p>dva-core中的源码文件目录以及其功能:</p>\n<ul>\n<li>checkModel 对我们定义的 Model 进行检查是否符合要求</li>\n<li>constants 非常简单的常量文件，目前只定义了一个常量：NAMESPACE_SEP(/)</li>\n<li>cratePromiseMiddleware 笔者自己定义的 redux 插件</li>\n<li>createStore 封装了 redux 原生的 createStore</li>\n<li>getReducer 这里面的函数其实主要就是调用了 handleActions 文件导出的函数</li>\n<li>getSaga 将用户输入的 effects 部分的键值对函数进行管理</li>\n<li>handleActions 是将 dva 风格的 reducer 和 state 转化成 redux 本来接受的那种方式</li>\n<li>index 主入口文件</li>\n<li>Plugin 插件类：可以管理不同钩子事件的回调函数，拥有增加、获取、执行钩子函数的功能</li>\n<li>perfixedDispatch 该文件提供了对 Dispatch 增加前缀的工具性函数 prefixedDispatch</li>\n<li>prefixNamespace 该文件提供了对 reducer 和 effects 增加前缀的工具性函数 prefixNamespace</li>\n<li>prefixType 判断是 reducer 还是 effects</li>\n<li>subscriptions 该文件提供了运行 subscriptions 和调用用户返回的 unlisten 函数以及删除缓存的功能</li>\n<li>utils 提供一些非常基础的工具函数</li>\n</ul>\n<h3 id=\"优势总结\"><a href=\"#优势总结\" class=\"headerlink\" title=\"优势总结\"></a>优势总结</h3><ul>\n<li>动态 model，已经封装好了整套调用，动态添加/删除 model 变得非常简单</li>\n<li>默认封装好了管理 effects 的方式，有限可选可配置，降低学习成本的同时代码更利于维护</li>\n<li>易于上手，集成redux、redux-saga、react-router等常用功能</li>\n</ul>\n<h3 id=\"劣势总结\"><a href=\"#劣势总结\" class=\"headerlink\" title=\"劣势总结\"></a>劣势总结</h3><ul>\n<li>版本区隔不明显，dva 有 1.x 和 2.x 两种版本，之间API有些差异，但是官网提供的一些样例等中没有说明基于的版本，并且有的还是基于旧版本的，会给新手带来很多疑惑。</li>\n<li>内容繁杂，但是却没有一个整合性质的官方网站，大都是通过 list 的形式列下来写在README的。</li>\n<li>目前比如动态加载等还存在着一些问题，和直接采用react配套工具写的效果有所区别。</li>\n<li>很多 issues 不知道为什么就被关闭了，作者在最后也并未给出合理的解释。</li>\n<li>dva2 之后有点将 effects 和 actions 混淆，这一点我也并不是非常认同，当然原作者可能有自己的考虑，这里不过多评议。</li>\n</ul>\n<p>总之，作为一个个人主力的项目(主要开发者贡献了99%以上的代码)，可以看出作者的功底深厚，经验丰富，但是由于这样一个体系化的东西牵扯内容较多，并且非常受制于react、redux、react-router、redux-saga等的版本影响，<strong>不建议具备一定规模的非阿里系团队在生产环境中使用</strong>，但是如果是快速成型的中小型项目或者个人应用，使用起来还是有很大帮助的。</p>\n<h3 id=\"TODOS\"><a href=\"#TODOS\" class=\"headerlink\" title=\"TODOS\"></a>TODOS</h3><p>笔者也在准备做一个和 dva 处于同一性质，但是设计、实现和使用有所区别的框架，希望能够尽快落成。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h3><p>本文章用于个人学习研究，并不代表 dva 团队的任何观点。</p>\n<p>原文以及包含一定注释的代码见<a href=\"https://github.com/aircloud/dva-analysis\">这里</a>，若有问题也可以在<a href=\"https://github.com/aircloud/dva-analysis/issues\">这里</a>进行讨论</p>\n<h3 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h3><h4 id=\"为什么是dva\"><a href=\"#为什么是dva\" class=\"headerlink\" title=\"为什么是dva?\"></a>为什么是dva?</h4><p>笔者对 dva 的源代码进行解读，主要考虑到 dva 并不是一个和我们熟知的主流技术无关的从0到1的框架，相反，它是对主流技术进行整合，提炼，从而形成一种最佳实践，分析 dva，意味着我们可以对自己掌握的很多相关技术进行回顾，另外，dva 的代码量并不多，也不至于晦涩难懂，可以给我们平时的业务开发以启发。</p>\n<p>本文章作为 dva 的源码解读文章，并不面向新手用户，读者应当有一定的 react 使用经验和 ECMAscript 2015+ 的使用经验，并且应当了解 redux 和 redux-saga，以及对 dva 的使用有所了解(可以从<a href=\"https://github.com/dvajs/dva/blob/master/README_zh-CN.md#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-dva-\">这里</a>了解为什么需要使用 dva)</p>\n<p>重点推荐:</p>\n<ul>\n<li>通过<a href=\"https://github.com/dvajs/dva-knowledgemap\">这里</a>的内容了解使用dva的最小知识集</li>\n<li>通过<a href=\"https://redux-saga-in-chinese.js.org/docs/introduction/index.html\">这里</a>学习 redux-saga</li>\n</ul>\n<p>其他推荐：</p>\n<ul>\n<li><a href=\"https://github.com/dvajs/dva/blob/master/docs/Concepts_zh-CN.md\">dva的概念</a></li>\n<li><a href=\"https://github.com/dvajs/dva/blob/master/docs/API_zh-CN.md\">dva的全部API</a></li>\n<li><a href=\"https://github.com/sorrycc/blog/issues/1\">React+Redux 最佳实践</a></li>\n<li><a href=\"http://slides.com/sorrycc/dva#/\">React在蚂蚁金服的实践</a></li>\n<li><a href=\"https://github.com/sorrycc/blog/issues/48\">dva 2.0的改进</a></li>\n<li><a href=\"http://cn.redux.js.org/docs/recipes/ComputingDerivedData.html\">ReSelect介绍</a></li>\n<li><a href=\"https://www.jianshu.com/p/04d3fefea8d7\">浅析Redux 的 store enhancer</a></li>\n</ul>\n<p>几个 dva 版本之间的关系:</p>\n<ul>\n<li><a href=\"mailto:&#x64;&#118;&#x61;&#64;&#50;&#46;&#x30;\">&#x64;&#118;&#x61;&#64;&#50;&#46;&#x30;</a>：基于 react 和 react-router@4</li>\n<li><a href=\"mailto:&#100;&#118;&#97;&#x2d;&#114;&#101;&#x61;&#x63;&#116;&#45;&#114;&#x6f;&#x75;&#x74;&#101;&#114;&#x2d;&#x33;&#x40;&#49;&#x2e;&#48;\">&#100;&#118;&#97;&#x2d;&#114;&#101;&#x61;&#x63;&#116;&#45;&#114;&#x6f;&#x75;&#x74;&#101;&#114;&#x2d;&#x33;&#x40;&#49;&#x2e;&#48;</a>：基于 react 和 react-router@3</li>\n<li><a href=\"mailto:&#100;&#118;&#97;&#45;&#x6e;&#x6f;&#45;&#x72;&#x6f;&#117;&#x74;&#101;&#x72;&#x40;&#49;&#x2e;&#x30;\">&#100;&#118;&#97;&#45;&#x6e;&#x6f;&#45;&#x72;&#x6f;&#117;&#x74;&#101;&#x72;&#x40;&#49;&#x2e;&#x30;</a>：无路由版本，适用于多页面场景，可以和 next.js 组合使用</li>\n<li><a href=\"mailto:&#100;&#x76;&#x61;&#45;&#x63;&#111;&#114;&#x65;&#x40;&#49;&#x2e;&#48;\">&#100;&#x76;&#x61;&#45;&#x63;&#111;&#114;&#x65;&#x40;&#49;&#x2e;&#48;</a>：仅封装了 redux 和 redux-saga</li>\n</ul>\n<p>我们本次主要分析目标为 <a href=\"mailto:&#100;&#118;&#x61;&#64;&#x32;&#x2e;&#48;\">&#100;&#118;&#x61;&#64;&#x32;&#x2e;&#48;</a> 和 <a href=\"mailto:&#100;&#118;&#x61;&#x2d;&#99;&#x6f;&#114;&#x65;&#64;&#49;&#x2e;&#48;\">&#100;&#118;&#x61;&#x2d;&#99;&#x6f;&#114;&#x65;&#64;&#49;&#x2e;&#48;</a></p>\n<h3 id=\"我们为什么需要-redux-saga\"><a href=\"#我们为什么需要-redux-saga\" class=\"headerlink\" title=\"我们为什么需要 redux-saga\"></a>我们为什么需要 redux-saga</h3><p>目前，在大多数项目开发中，我们现在依然采用的是redux-thunk + async/await (或 Promise)。</p>\n<p>实际上这个十几行的插件已经完全可以解决大多是场景下的问题了，如果你在目前的工作中正在使用这一套方案并且能够完全将当下的需求应付自如并且没有什么凌乱的地方，其实也是没有必要换成redux-saga的。</p>\n<p>接下来我们讲 redux-saga，先看名字：saga，这个术语常用于CQRS架构，代表查询与责任分离。</p>\n<p>相比于 redux-thunk，前者通常是把数据查询等请求放在 actions 中(不纯净的 actions)，并且这些 actions 可以继续回调调用其他 actions(纯净的 actions)，从而完成数据的更新；而 redux-saga，则保持了 actions 的纯粹性，单独抽出一层专门来处理数据请求等操作(saga函数)。</p>\n<p>这样做还有另外一些好处：</p>\n<ul>\n<li>由于我们已经将数据处理数据请求等异步操作抽离出来了，并且通过 generator 来处理，我们便可以方便地进行多种异步管理：比如同时按顺序执行多个任务、在多个异步任务中启动race等。</li>\n<li>这样做可以延长任务的生命周期，我们的一次调用可以不再是一个”调完即走”的过程，还可以是一个LLT（Long Lived Transaction)的事物处理过程，比如我们可以将用户的登入、登出的管理放在一个saga函数中处理。</li>\n</ul>\n<p>当然，redux-saga还有比如拥有有诸多常用并且声明式易测的 Effects、可以无阻塞的fork等一些更复杂的异步操作和管理方法，如果应用中有较多复杂的异步操作流程，使用redux-saga无疑会让条理更加清楚。</p>\n<p>当然，本文的目的不是介绍或者安利redux-saga，只是因为redux-saga是 dva 的一个基础，相关概念点到为止，如需了解更多请自行参考资料。</p>\n<h3 id=\"dva-源码解读\"><a href=\"#dva-源码解读\" class=\"headerlink\" title=\"dva 源码解读\"></a>dva 源码解读</h3><p>我们的源码分析流程是这样的：通过一个使用 dva 开发的例子，随着其对 dva 函数的逐步调用，来分析内部 dva 相关函数的实现原理。</p>\n<p>我们分析采用的例子是 dva 官方提供的一个增删改查的应用，可以在<a href=\"https://github.com/dvajs/dva/tree/rewrite-dynamic\">这里</a>找到它的源代码。</p>\n<p>我们先看该例子的入口文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> dva <span class=\"keyword\">from</span> <span class=\"string\">&#x27;dva&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> createHistory <span class=\"keyword\">from</span> <span class=\"string\">&#x27;history/createBrowserHistory&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> createLoading <span class=\"keyword\">from</span> <span class=\"string\">&#x27;dva-loading&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; message &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;antd&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;./index.css&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ERROR_MSG_DURATION = <span class=\"number\">3</span>; <span class=\"comment\">// 3 秒</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. Initialize</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = dva(&#123;</span><br><span class=\"line\">  <span class=\"attr\">history</span>: createHistory(),</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">onError</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    message.error(e.message, ERROR_MSG_DURATION);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. Plugins</span></span><br><span class=\"line\">app.use(createLoading());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. Model</span></span><br><span class=\"line\"><span class=\"comment\">// Moved to router.js</span></span><br><span class=\"line\"><span class=\"comment\">// 这里的 Model 被转移到了动态加载的 router 里面，我们也可以如下写：</span></span><br><span class=\"line\"><span class=\"comment\">// app.model(require(&#x27;./models/users&#x27;));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. Router</span></span><br><span class=\"line\">app.router(<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./router&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. Start</span></span><br><span class=\"line\">app.start(<span class=\"string\">&#x27;#root&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们发现dva从初始化配置到最后的start(现在的dva start函数在不传入container的情况下可以返回React Component，便于服务端渲染等，但这里我们还是按照例子的写法来)。</p>\n<p>这里我们先有必要解释一下，dva 在当前依据能力和依赖版本的不同，有多个可引入的版本，我们的例子和所要分析的源代码都是基于 react-router V4 的 dva 版本。</p>\n<p>在源代码中，相关目录主要为 dva 目录(packages/dva) 和 dva-core(packages/dva-core)目录，前者主要拥有history管理、router、动态加载等功能，而后者是不依赖这些内容的基础模块部分，为前者所引用</p>\n<h4 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h4><p>第一步这里传入了两个内容：(dva构造函数总共可以传入那些 opts，会在下文中进行说明)</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const app = dva(&#123;</span><br><span class=\"line\">  history: createHistory(),</span><br><span class=\"line\">  onError(<span class=\"name\">e</span>) &#123;</span><br><span class=\"line\">    message.error(<span class=\"name\">e</span>.message, ERROR_MSG_DURATION)<span class=\"comment\">;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>这一步的相关核心代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">opts = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> history = opts.history || createHashHistory(); <span class=\"comment\">// 默认为 HashHistory</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> createOpts = &#123;</span><br><span class=\"line\">    <span class=\"attr\">initialReducer</span>: &#123;</span><br><span class=\"line\">      routing, <span class=\"comment\">// 来自 react-router-redux 的 routerReducer</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">setupMiddlewares</span>(<span class=\"params\">middlewares</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        routerMiddleware(history), <span class=\"comment\">// 来自 react-router-redux 的 routerMiddleware</span></span><br><span class=\"line\">        ...middlewares,</span><br><span class=\"line\">      ];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">setupApp</span>(<span class=\"params\">app</span>)</span> &#123;</span><br><span class=\"line\">      app._history = patchHistory(history); </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> app = core.create(opts, createOpts);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldAppStart = app.start;</span><br><span class=\"line\">  app.router = router;</span><br><span class=\"line\">  app.start = start;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 一些用到的函数的定义...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>这里面大多数内容都比较简单，这里面提两个地方：</p>\n<ol>\n<li>patchHistory：</li>\n</ol>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function patchHistory(<span class=\"keyword\">history</span>) &#123;</span><br><span class=\"line\">  const oldListen = <span class=\"keyword\">history</span>.listen;</span><br><span class=\"line\">  <span class=\"keyword\">history</span>.listen = (callback) =&gt; &#123;</span><br><span class=\"line\">    callback(<span class=\"keyword\">history</span>.location);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldListen.call(<span class=\"keyword\">history</span>, callback);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">history</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显然，这里的意思是让第一次被绑定 listener 的时候执行一遍 callback，可以用于初始化相关操作。</p>\n<p>我们可以在<code>router.js</code>中添加如下代码来验证：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.listen(<span class=\"function\"><span class=\"params\">(location, action)</span>=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;history listen:&#x27;</span>, location, action)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在完成可选项的构造之后，调用了 dva-core 中暴露的 create 函数。</li>\n</ol>\n<p>create 函数本身也并不复杂，核心代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">hooksAndOpts = &#123;&#125;, createOpts = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    initialReducer,</span><br><span class=\"line\">    setupApp = noop,</span><br><span class=\"line\">  &#125; = createOpts;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> plugin = <span class=\"keyword\">new</span> Plugin(); <span class=\"comment\">// 实例化钩子函数管理类</span></span><br><span class=\"line\">  plugin.use(filterHooks(hooksAndOpts)); <span class=\"comment\">// 这个时候先对 obj 进行清理，清理出在我们定义的类型之外的 hooks，之后进行统一绑定</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> app = &#123;</span><br><span class=\"line\">    <span class=\"attr\">_models</span>: [</span><br><span class=\"line\">      prefixNamespace(&#123; ...dvaModel &#125;), <span class=\"comment\">// 前缀处理</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">_store</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">_plugin</span>: plugin,</span><br><span class=\"line\">    <span class=\"attr\">use</span>: plugin.use.bind(plugin),</span><br><span class=\"line\">    model, <span class=\"comment\">// 下文定义</span></span><br><span class=\"line\">    start, <span class=\"comment\">// 下文定义</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> app;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">//一些函数的定义</span></span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>这里面我们可以看到，这里的 <code>hooksAndOpts</code> 实际上就是一开始我们构造 dva 的时候传入的 opts 对象经过处理之后的结果。</p>\n<p>我们可以传入的可选项，实际上都在 <code>Plugin.js</code> 中写明了:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">const hooks</span> = [</span><br><span class=\"line\">  <span class=\"string\">&#x27;onError&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onStateChange&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onAction&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onHmr&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onReducer&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onEffect&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;extraReducers&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;extraEnhancers&#x27;</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>具体 <a href=\"https://github.com/dvajs/dva/blob/master/docs/API_zh-CN.md#appusehooks\">hooks的作用可以在这里进行查阅</a>。</p>\n<p>Plugin 插件管理类(实际上我认为称其为钩子函数管理类比较合适)除了定义了上文的使用到的use方法(挂载插件)、还有apply方法(执行某一个钩子下挂载的所有回调)、get方法(获取某一个钩子下的所有回调，返回数组)</p>\n<h4 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h4><p>这里的第二步比较简洁：我们知道实际上这里就是使用了<code>plugin.use</code>方法挂载了一个插件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(createLoading()); <span class=\"comment\">// 需要注意，插件挂载需要在 app.start 之前</span></span><br></pre></td></tr></table></figure>\n\n<p>createLoading 这个插件实际上是官方提供的 Loading 插件，通过这个插件我们可以非常方便地进行 Loading 的管理，无需进行手动管理，我们可以先<a href=\"https://www.jianshu.com/p/61fe7a57fad4\">看一篇文章</a>来简单了解一下。</p>\n<p>这个插件看似神奇，实际上原理也比较简单，主要用了<code>onEffect</code>钩子函数(装饰器)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onEffect</span>(<span class=\"params\">effect, &#123; put &#125;, model, actionType</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; namespace &#125; = model;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        (only.length === <span class=\"number\">0</span> &amp;&amp; except.length === <span class=\"number\">0</span>)</span><br><span class=\"line\">        || (only.length &gt; <span class=\"number\">0</span> &amp;&amp; only.indexOf(actionType) !== -<span class=\"number\">1</span>)</span><br><span class=\"line\">        || (except.length &gt; <span class=\"number\">0</span> &amp;&amp; except.indexOf(actionType) === -<span class=\"number\">1</span>)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> put(&#123; <span class=\"attr\">type</span>: SHOW, <span class=\"attr\">payload</span>: &#123; namespace, actionType &#125; &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> effect(...args);</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> put(&#123; <span class=\"attr\">type</span>: HIDE, <span class=\"attr\">payload</span>: &#123; namespace, actionType &#125; &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> effect;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>结合基于的redux-saga，在目标异步调用开始的时候<code>yield put(&#123; type: SHOW, payload: &#123; namespace, actionType &#125; &#125;);</code>，在异步调用结束的时候<code>yield put(&#123; type: HIDE, payload: &#123; namespace, actionType &#125; &#125;);</code>，这样就可以管理异步调用开始和结束的Loading状态了。</p>\n<h4 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h4><p>第三步这里其实省略了，因为使用了动态加载，将 Models 定义的内容和 React Component 进行了动态加载，实际上也可以按照注释的方法来写。</p>\n<p>但是没有关系，我们还是可以分析 models 引入的文件中做了哪些事情(下面列出的代码在原基础上进行了一些简化):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> queryString <span class=\"keyword\">from</span> <span class=\"string\">&#x27;query-string&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> usersService <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../services/users&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">namespace</span>: <span class=\"string\">&#x27;users&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">list</span>: [],</span><br><span class=\"line\">    <span class=\"attr\">total</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">page</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">reducers</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">save</span>(<span class=\"params\">state, &#123; payload: &#123; data: list, total, page &#125; &#125;</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; ...state, list, total, page &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">effects</span>: &#123;</span><br><span class=\"line\">    *<span class=\"function\"><span class=\"title\">fetch</span>(<span class=\"params\">&#123; payload: &#123; page = <span class=\"number\">1</span> &#125; &#125;, &#123; call, put &#125;</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; data, headers &#125; = <span class=\"keyword\">yield</span> call(usersService.fetch, &#123; page &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> put(&#123;</span><br><span class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">&#x27;save&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">payload</span>: &#123;</span><br><span class=\"line\">          data,</span><br><span class=\"line\">          <span class=\"attr\">total</span>: <span class=\"built_in\">parseInt</span>(headers[<span class=\"string\">&#x27;x-total-count&#x27;</span>], <span class=\"number\">10</span>),</span><br><span class=\"line\">          <span class=\"attr\">page</span>: <span class=\"built_in\">parseInt</span>(page, <span class=\"number\">10</span>),</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    *<span class=\"function\"><span class=\"title\">reload</span>(<span class=\"params\">action, &#123; put, select &#125;</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> page = <span class=\"keyword\">yield</span> select(<span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.users.page);</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> put(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;fetch&#x27;</span>, <span class=\"attr\">payload</span>: &#123; page &#125; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">subscriptions</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\">&#123; dispatch, history &#125;</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> history.listen(<span class=\"function\">(<span class=\"params\">&#123; pathname, search &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> query = queryString.parse(search);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pathname === <span class=\"string\">&#x27;/users&#x27;</span>) &#123;</span><br><span class=\"line\">          dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;fetch&#x27;</span>, <span class=\"attr\">payload</span>: query &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这些内容，我们通过<code>app.model(require(&#39;./models/users&#39;));</code>就可以引入。</p>\n<p>实际上，model 函数本身还是比较简单的，但由于 dva 拥有 model 动态加载的能力，实际上调用 app.start 前和 app.start 后model函数是不一样的。</p>\n<p>调用 start 函数前，我们直接挂载即可(因为start函数中会对所有model进行遍历性统一处理，所以无需过多处理)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">model</span>(<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">&#x27;production&#x27;</span>) &#123;</span><br><span class=\"line\">      checkModel(m, app._models);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    app._models.push(prefixNamespace(m));</span><br><span class=\"line\">    <span class=\"comment\">// 把 model 注册到 app 的 _models 里面，但是当 app start 之后，就不能仅仅用这种方法了，需要 injectModel</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用了 start 函数之后，model函数被替换成如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">injectModel</span>(<span class=\"params\">createReducer, onError, unlisteners, m</span>) </span>&#123;</span><br><span class=\"line\">    model(m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = app._store;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.reducers) &#123;</span><br><span class=\"line\">      store.asyncReducers[m.namespace] = getReducer(m.reducers, m.state);</span><br><span class=\"line\">      store.replaceReducer(createReducer(store.asyncReducers));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.effects) &#123;</span><br><span class=\"line\">      store.runSaga(app._getSaga(m.effects, m, onError, plugin.get(<span class=\"string\">&#x27;onEffect&#x27;</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.subscriptions) &#123;</span><br><span class=\"line\">      unlisteners[m.namespace] = runSubscription(m.subscriptions, m, app, onError);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>我们首先分析第一个 if 中的内容</strong>：首先通过getReducer函数将转换好的 reducers 挂载(或替换)到 store.asyncReducers[m.namespace] 中，然后通过 redux 本身提供的能力 replaceReducer 完成 reducer 的替换。</p>\n<p>这里我们需要注意 getReducer 函数，实际上，dva 里面 reducers 写法和我们之前直接使用 redux 的写法略有不同：</p>\n<p>我们这里的 reducers，实际上要和 action 中的 actionType 同名的 reducer，所以这里我们没有必要去写 switch case 了，对于某一个 reducer 来说其行为应该是确定的，这给 reducers 的写法带来了一定的简化，当然，我们可以使用 extraReducers 定义我们之前习惯的那种比较复杂的 reducers。</p>\n<p><strong>接下来我们分析第二个 if 中的内容</strong>：第二个函数首先获取到了我们定义的 effects 并通过 _getSaga 进行处理，然后使用 <code>runSaga</code>(实际上就是createSagaMiddleware().run，来自于redux-saga) 进行执行。</p>\n<p>实际上，这里的 <code>_getSaga</code> 函数比较复杂，我们接下来重点介绍这个函数。</p>\n<p><code>_getSaga</code> 函数由 <code>getSaga.js</code> 暴露，其定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSaga</span>(<span class=\"params\">resolve, reject, effects, model, onError, onEffect</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;  <span class=\"comment\">// 返回一个函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> effects) &#123;  <span class=\"comment\">// 这个函数对 effects 里面的所有键</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(effects, key)) &#123; <span class=\"comment\">// 先判断一下键是属于自己的</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> watcher = getWatcher(resolve, reject, key, effects[key], model, onError, onEffect);</span><br><span class=\"line\">        <span class=\"comment\">// 然后调用getWatch获取watcher</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> task = <span class=\"keyword\">yield</span> sagaEffects.fork(watcher); <span class=\"comment\">// 利用 fork 开启一个 task</span></span><br><span class=\"line\">        <span class=\"keyword\">yield</span> sagaEffects.fork(<span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 这样写的目的是，如果我们移除了这个 model 要及时结束掉</span></span><br><span class=\"line\">          <span class=\"keyword\">yield</span> sagaEffects.take(<span class=\"string\">`<span class=\"subst\">$&#123;model.namespace&#125;</span>/@@CANCEL_EFFECTS`</span>);</span><br><span class=\"line\">          <span class=\"keyword\">yield</span> sagaEffects.cancel(task);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>getWatcher 的一些核心代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getWatcher</span>(<span class=\"params\">resolve, reject, key, _effect, model, onError, onEffect</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> effect = _effect;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> type = <span class=\"string\">&#x27;takeEvery&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ms;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(_effect)) &#123;</span><br><span class=\"line\">    effect = _effect[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> opts = _effect[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 对 opts 进行一定的校验</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">sagaWithCatch</span>(<span class=\"params\">...args</span>) </span>&#123; <span class=\"comment\">// 都会调用这个过程</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> sagaEffects.put(&#123; <span class=\"attr\">type</span>: <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span><span class=\"subst\">$&#123;NAMESPACE_SEP&#125;</span>@@start`</span> &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> ret = <span class=\"keyword\">yield</span> effect(...args.concat(createEffects(model)));</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> sagaEffects.put(&#123; <span class=\"attr\">type</span>: <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span><span class=\"subst\">$&#123;NAMESPACE_SEP&#125;</span>@@end`</span> &#125;);</span><br><span class=\"line\">      resolve(key, ret);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      onError(e);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!e._dontReject) &#123;</span><br><span class=\"line\">        reject(key, e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> sagaWithOnEffect = applyOnEffect(onEffect, sagaWithCatch, model, key); </span><br><span class=\"line\">  <span class=\"comment\">// 挂载 onEffect 钩子</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;watcher&#x27;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> sagaWithCatch;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;takeLatest&#x27;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> takeLatest(key, sagaWithOnEffect);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;throttle&#x27;</span>: <span class=\"comment\">// 起到节流的效果，在 ms 时间内仅仅会被触发一次</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> throttle(ms, key, sagaWithOnEffect);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> takeEvery(key, sagaWithOnEffect);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数的工作，可以主要分为以下三个部分：</p>\n<p>1.将 effect 包裹成 sagaWithCatch，除了便于错误处理和增加前后钩子，值得我们注意的是 resolve 和 reject，</p>\n<p>这个 resolve 和 reject，实际上是来自<code>createPromiseMiddleware.js</code></p>\n<p>我们知道，我们在使用redux-saga的过程中，实际上是监听未来的action，并执行 effects，所以我们在一个 effects 函数中执行一些异步操作，然后 put(dispatch) 一个 action，还是会被监听这个 action 的其他 saga 监听到。</p>\n<p>所以就有如下场景：我们 dispatch 一个 action，这个时候如果我们想获取到什么时候监听这个 action 的 saga 中的异步操作执行结束，是办不到的(因为不是所有的时候我们都把所有处理逻辑写在 saga 中)，所以我们的 dispatch 有的时候需要返回一个 Promise 从而我们可以进行异步结束后的回调(这个 Promise 在监听者 saga 异步执行完后被决议，见上文<code>sagaWithCatch</code>函数源代码)。</p>\n<p>如果我讲的还是比较混乱，也可以参考<a href=\"https://github.com/dvajs/dva/issues/175\">这个issue</a></p>\n<p>对于这个情况，我认为这是 dva 代码最精彩的地方之一，作者通过定义如下的middleware:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> middleware = <span class=\"function\">() =&gt;</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">const</span> &#123; type &#125; = action;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isEffect(type)) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">       map[type] = &#123;</span><br><span class=\"line\">         <span class=\"attr\">resolve</span>: wrapped.bind(<span class=\"literal\">null</span>, type, resolve),</span><br><span class=\"line\">         <span class=\"attr\">reject</span>: wrapped.bind(<span class=\"literal\">null</span>, type, reject),</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> next(action);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapped</span>(<span class=\"params\">type, fn, args</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (map[type]) <span class=\"keyword\">delete</span> map[type];</span><br><span class=\"line\">   fn(args);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">type, args</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (map[type]) &#123;</span><br><span class=\"line\">     map[type].resolve(args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">type, args</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (map[type]) &#123;</span><br><span class=\"line\">     map[type].reject(args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且在上文的<code>sagaWithCatch</code>相关effect执行结束的时候调用 resolve，让 dispatch 返回了一个 Promise。</p>\n<p>当然，上面这段代码还是有点问题的，这样会导致同名 reducer 和 effect 不会 fallthrough（即两者都执行），因为都已经返回了，action 便不会再进一步传递，关于这样设计的好坏，在<a href=\"https://github.com/sorrycc/blog/issues/48\">这里</a>有过一些讨论，笔者不进行展开表述。</p>\n<p>2.在上面冗长的第一步之后，又通过<code>applyOnEffect</code>函数包裹了<code>OnEffect</code>的钩子函数，这相当于是一种<code>compose</code>，(上文的 dva-loading 中间件实际上就是在这里被处理的)其实现对于熟悉 redux 的同学来说应该不难理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyOnEffect</span>(<span class=\"params\">fns, effect, model, key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> fn <span class=\"keyword\">of</span> fns) &#123;</span><br><span class=\"line\">    effect = fn(effect, sagaEffects, model, key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> effect;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.最后，根据我们定义的type(默认是<code>takeEvery</code>，也就是都执行)，来选择不同的 saga，takeLatest 即为只是执行最近的一个，throttle则起到节流的效果，一定时间内仅仅允许被触发一次，这些都是 redux-saga 的内部实现，dva 也是基本直接引用，因此在这里不进行展开。</p>\n<p><strong>最后我们分析<code>injectModel</code>第三个<code>if</code>中的内容</strong>:处理<code>subscriptions</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (m.subscriptions) &#123;</span><br><span class=\"line\">  unlisteners[m.namespace] = runSubscription(m.subscriptions, m, app, onError);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>subscriptions</code>可以理解为和这个model有关的全局监听，但是相对独立。这一个步骤首先调用<code>runSubscription</code>来一个一个调用我们的<code>subscriptions</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">subs, model, app, onError</span>) </span>&#123; <span class=\"comment\">// 在index.js中被重命名为 runSubscription</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> funcs = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nonFuncs = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> subs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(subs, key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> sub = subs[key];</span><br><span class=\"line\">      <span class=\"keyword\">const</span> unlistener = sub(&#123;</span><br><span class=\"line\">        <span class=\"attr\">dispatch</span>: prefixedDispatch(app._store.dispatch, model),</span><br><span class=\"line\">        <span class=\"attr\">history</span>: app._history,</span><br><span class=\"line\">      &#125;, onError);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isFunction(unlistener)) &#123;</span><br><span class=\"line\">        funcs.push(unlistener);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        nonFuncs.push(key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; funcs, nonFuncs &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正如我们所期待的，<code>run</code>函数就是一个一个执行<code>subscriptions</code>，但是这里有一点需要我们注意的，我们定义的<code>subscriptions</code>应该是需要返回一个<code>unlistener</code>来返回接触函数，这样当整个 model 被卸载的时候 dva 会自动调用这个接解除函数(也就是为什么这里的返回函数被命名为<code>unlistener</code>)</p>\n<h4 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h4><p>源代码中的第四步，是对 router 的挂载：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.router(<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./router&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p><code>require(&#39;./router&#39;)</code>返回的内容在源代码中经过一系列引用传递最后直接被构造成 React Component 并且最终调用 ReactDom.render 进行渲染，这里没有什么好说的，值得一提的就是 router 的动态加载。</p>\n<p>动态加载在该样例中是这样使用的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router, Switch, Route &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;dva/router&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> dynamic <span class=\"keyword\">from</span> <span class=\"string\">&#x27;dva/dynamic&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">RouterConfig</span>(<span class=\"params\">&#123; history, app &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> IndexPage = dynamic(&#123;</span><br><span class=\"line\">    app,</span><br><span class=\"line\">    <span class=\"attr\">component</span>: <span class=\"function\">() =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./routes/IndexPage&#x27;</span>),</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Users = dynamic(&#123;</span><br><span class=\"line\">    app,</span><br><span class=\"line\">    <span class=\"attr\">models</span>: <span class=\"function\">() =&gt;</span> [</span><br><span class=\"line\">      <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./models/users&#x27;</span>),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">component</span>: <span class=\"function\">() =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./routes/Users&#x27;</span>),</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  history.listen(<span class=\"function\">(<span class=\"params\">location, action</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;history listen:&#x27;</span>, location, action)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">history</span>=<span class=\"string\">&#123;history&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">exact</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/&quot;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;IndexPage&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">exact</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/users&quot;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Users&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看出，主要就是利用<code>dva/dynamic.js</code>暴露的 dynamic 函数进行动态加载，接下来我们简单看一下 dynamic 函数做了什么:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dynamic</span>(<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; app, <span class=\"attr\">models</span>: resolveModels, <span class=\"attr\">component</span>: resolveComponent &#125; = config;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> asyncComponent(&#123;</span><br><span class=\"line\">    <span class=\"attr\">resolve</span>: config.resolve || <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> models = <span class=\"keyword\">typeof</span> resolveModels === <span class=\"string\">&#x27;function&#x27;</span> ? resolveModels() : [];</span><br><span class=\"line\">      <span class=\"keyword\">const</span> component = resolveComponent();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.all([...models, component]).then(<span class=\"function\">(<span class=\"params\">ret</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!models || !models.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> resolve(ret[<span class=\"number\">0</span>]);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> len = models.length;</span><br><span class=\"line\">            ret.slice(<span class=\"number\">0</span>, len).forEach(<span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">              m = m.default || m;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(m)) &#123;</span><br><span class=\"line\">                m = [m];</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              m.map(<span class=\"function\"><span class=\"params\">_</span> =&gt;</span> registerModel(app, _)); <span class=\"comment\">// 注册所有的 model</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            resolve(ret[len]);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...config,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里主要调用了 asyncComponent 函数，接下来我们再看一下这个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncComponent</span>(<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; resolve &#125; = config;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">...args</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(...args);</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.LoadingComponent =</span><br><span class=\"line\">        config.LoadingComponent || defaultLoadingComponent;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">        <span class=\"attr\">AsyncComponent</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.load();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.mounted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">componentWillUnmount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.mounted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">load</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      resolve().then(<span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> AsyncComponent = m.default || m;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.mounted) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">this</span>.setState(&#123; AsyncComponent &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">this</span>.state.AsyncComponent = AsyncComponent; <span class=\"comment\">// eslint-disable-line</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; AsyncComponent &#125; = <span class=\"built_in\">this</span>.state;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; LoadingComponent &#125; = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (AsyncComponent) <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AsyncComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">LoadingComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数逻辑比较简洁，我们分析一下动态加载流程；</p>\n<ul>\n<li>在 constructor 里面调用 <code>this.load();</code> ( LoadingComponent 为占位 component)</li>\n<li>在 <code>this.load();</code> 函数里面调用 <code>dynamic</code> 函数返回的 resolve 方法</li>\n<li>resolve 方法实际上是一个 Promise，把相关 models 和 component 加载完之后 resolve (区分这两个 resolve)</li>\n<li>加载完成之后返回 AsyncComponent (即加载的 Component)</li>\n</ul>\n<p>动态加载主流程结束，至于动态加载的代码分割工作，可以使用 webpack3 的 <code>import()</code> 动态加载能力(例子中也是这样使用的)。</p>\n<h4 id=\"第五步\"><a href=\"#第五步\" class=\"headerlink\" title=\"第五步\"></a>第五步</h4><p>第五步骤就是 start 了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.start(<span class=\"string\">&#x27;#root&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候如果我们在 start 函数中传入 DomElement 或者 DomQueryString，就会直接启动应用了，如果我们这个时候不传入任何内容，实际上返回的是一个<code>&lt;Provider /&gt;</code> (React Component)，便于服务端渲染。 相关判断逻辑如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (container) &#123;</span><br><span class=\"line\">     render(container, store, app, app._router);</span><br><span class=\"line\">     app._plugin.apply(<span class=\"string\">&#x27;onHmr&#x27;</span>)(render.bind(<span class=\"literal\">null</span>, container, store, app));</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> getProvider(store, <span class=\"built_in\">this</span>, <span class=\"built_in\">this</span>._router);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，主要流程结束，以上几个步骤也包括了 dva 源码做的主要工作。</p>\n<p>当然 dva 源码中还有一些比如前缀处理等工作，但是相比于以上内容非常简单，所以在这里不进行分析了。</p>\n<h3 id=\"dva-core-文件目录\"><a href=\"#dva-core-文件目录\" class=\"headerlink\" title=\"dva-core 文件目录\"></a>dva-core 文件目录</h3><p>dva-core中的源码文件目录以及其功能:</p>\n<ul>\n<li>checkModel 对我们定义的 Model 进行检查是否符合要求</li>\n<li>constants 非常简单的常量文件，目前只定义了一个常量：NAMESPACE_SEP(/)</li>\n<li>cratePromiseMiddleware 笔者自己定义的 redux 插件</li>\n<li>createStore 封装了 redux 原生的 createStore</li>\n<li>getReducer 这里面的函数其实主要就是调用了 handleActions 文件导出的函数</li>\n<li>getSaga 将用户输入的 effects 部分的键值对函数进行管理</li>\n<li>handleActions 是将 dva 风格的 reducer 和 state 转化成 redux 本来接受的那种方式</li>\n<li>index 主入口文件</li>\n<li>Plugin 插件类：可以管理不同钩子事件的回调函数，拥有增加、获取、执行钩子函数的功能</li>\n<li>perfixedDispatch 该文件提供了对 Dispatch 增加前缀的工具性函数 prefixedDispatch</li>\n<li>prefixNamespace 该文件提供了对 reducer 和 effects 增加前缀的工具性函数 prefixNamespace</li>\n<li>prefixType 判断是 reducer 还是 effects</li>\n<li>subscriptions 该文件提供了运行 subscriptions 和调用用户返回的 unlisten 函数以及删除缓存的功能</li>\n<li>utils 提供一些非常基础的工具函数</li>\n</ul>\n<h3 id=\"优势总结\"><a href=\"#优势总结\" class=\"headerlink\" title=\"优势总结\"></a>优势总结</h3><ul>\n<li>动态 model，已经封装好了整套调用，动态添加/删除 model 变得非常简单</li>\n<li>默认封装好了管理 effects 的方式，有限可选可配置，降低学习成本的同时代码更利于维护</li>\n<li>易于上手，集成redux、redux-saga、react-router等常用功能</li>\n</ul>\n<h3 id=\"劣势总结\"><a href=\"#劣势总结\" class=\"headerlink\" title=\"劣势总结\"></a>劣势总结</h3><ul>\n<li>版本区隔不明显，dva 有 1.x 和 2.x 两种版本，之间API有些差异，但是官网提供的一些样例等中没有说明基于的版本，并且有的还是基于旧版本的，会给新手带来很多疑惑。</li>\n<li>内容繁杂，但是却没有一个整合性质的官方网站，大都是通过 list 的形式列下来写在README的。</li>\n<li>目前比如动态加载等还存在着一些问题，和直接采用react配套工具写的效果有所区别。</li>\n<li>很多 issues 不知道为什么就被关闭了，作者在最后也并未给出合理的解释。</li>\n<li>dva2 之后有点将 effects 和 actions 混淆，这一点我也并不是非常认同，当然原作者可能有自己的考虑，这里不过多评议。</li>\n</ul>\n<p>总之，作为一个个人主力的项目(主要开发者贡献了99%以上的代码)，可以看出作者的功底深厚，经验丰富，但是由于这样一个体系化的东西牵扯内容较多，并且非常受制于react、redux、react-router、redux-saga等的版本影响，<strong>不建议具备一定规模的非阿里系团队在生产环境中使用</strong>，但是如果是快速成型的中小型项目或者个人应用，使用起来还是有很大帮助的。</p>\n<h3 id=\"TODOS\"><a href=\"#TODOS\" class=\"headerlink\" title=\"TODOS\"></a>TODOS</h3><p>笔者也在准备做一个和 dva 处于同一性质，但是设计、实现和使用有所区别的框架，希望能够尽快落成。</p>\n"},{"title":"从源码分析sentry的错误信息收集","abbrlink":3989724746,"date":"2018-08-18T11:23:55.000Z","_content":"\nraven.js 是 sentry 为 JavaScript 错误上报提供的 JS-SDK，本篇我们基于其源代码对其原理进行分析，本篇文章只分析前端部分，对应的文件目录是`https://github.com/getsentry/sentry-javascript/tree/master/packages/raven-js`。\n\n首先抛出几个问题：\n\n* **raven.js 是如何收集浏览器错误信息的？**\n* **raven.js 上报的错误信息格式是什么样的？又是如何把这些信息传给后端？支不支持合并上报？**\n* **面包屑（breadcrumbs）是什么？raven.js 如何来收集面包屑信息？**\n* **raven.js 如何和框架配合使用（比如 vue、react）？**\n\n在回答以上这几个问题之前，我们首先来对 raven.js 做一个宏观的分析，主要涉及其文件目录、所引用的第三方框架等。\n\nraven.js 的核心文件内容并不多，其中使用了三个第三方库，放在了 vendor 文件夹下：\n\n* [json-stringify-safe](https://github.com/moll/json-stringify-safe) ：一个对 `JSON.stringify` 的封装，安全的 json 序列化操作函数，不会抛出循环引用的错误。\n\t* 这里面有一个注意点要单独说一下，我们熟知的 `JSON.stringify` , 可以接受三个参数：第一个参数是我们要序列化的对象；第二个参数是对其中键值对的处理函数；第三个参数是控制缩进空格。reven.js 的 `json-stringify-safe` 就是充分利用了这三个参数。\n* [md5](https://github.com/blueimp/JavaScript-MD5)：js 的 md5 函数。\n* [TraceKit](https://github.com/csnover/TraceKit)：TraceKit 是一个已经比较完善的错误收集、堆栈格式化的库，reven.js 的功能在很大程度上对它有所依赖。\n\n除此之外，raven.js 支持插件，官方提供的一些知名库的 sentry 插件主要放在了 plugin 文件夹下面，raven.js 的一些核心文件，则放在了 src 文件夹下面。\n\n### raven.js 是如何收集错误信息的？\n\n我们知道，在前端收集错误，肯定离不开 `window.onerror` 这个函数，那么我们就从这个函数说起。\n\n实际上，这部分工作是 raven.js 引用的第三方库 TraceKit 完成的：\n\n```\nfunction installGlobalHandler() {\n  if (_onErrorHandlerInstalled) { // 一个起到标志作用的全局变量\n    return;\n  }\n  _oldOnerrorHandler = _window.onerror; \n  // _oldOnerrorHandler 是防止对用户其他地方定义的回调函数进行覆盖\n  // 该 _window 经过兼容，实际上就是 window\n  _window.onerror = traceKitWindowOnError;\n  _onErrorHandlerInstalled = true;\n}\n```\n\n相关错误回调函数交给 traceKitWindowOnError 处理，下面我们来看一下 traceKitWindowOnError 函数，为了避免太多冗余代码，我们仅分析一种主要情况：\n\n```\nfunction traceKitWindowOnError(msg, url, lineNo, colNo, ex) {\n\t\n\tvar exception = utils.isErrorEvent(ex) ? ex.error : ex;\n\t//...\n    stack = TraceKit.computeStackTrace(exception);\n    notifyHandlers(stack, true);\n    //...\n   \n    //...\n    if (_oldOnerrorHandler) {\n       return _oldOnerrorHandler.apply(this, arguments);\n    }\n    return false;\n}\n```\n\n其中调用的最重要的一个函数，就是 computeStackTrace，而这个函数也是 TraceKit 的核心函数，简单来讲，它做的事情就是统一格式化报错信息调用栈，因为对于各个浏览器来说，返回的 Error 调用栈信息格式不尽相同，另外甚至还有的浏览器并不返回调用栈，computeStackTrace 函数对这些情况都做了兼容性处理，并且对于一些不返回调用栈的情况，还使用了 caller 来向上回溯函数的调用栈，最终把报错信息转化成一个键相同的对象数组，做到了报错信息格式的统一。\n\nnotifyHandlers 函数则是通知相关的回调函数。 实际上，raven.js 在 install 函数中会调用 TraceKit.report.subscribe 函数，并把对错误的处理逻辑写入回调：\n\n```\nfunction subscribe(handler) {\n    installGlobalHandler();\n    handlers.push(handler);\n}\n```\n\n以上过程完成了错误处理过程中的负责角色转换，并且借助 TraceKit，可以使 raven.js 得到一个结构比较清晰的带有格式化好的调用栈信息的错误内容对象，之后，raven.js 对错误内容进一步处理并最终上报。\n\n下面我们对错误处理 raven.js 控制的部分做了一些梳理：\n\n```\n _handleOnErrorStackInfo: function(stackInfo, options) {\n    options.mechanism = options.mechanism || {\n      type: 'onerror',\n      handled: false\n    };\n    // mechanism 和错误统计来源有关\n\n    if (!this._ignoreOnError) {\n      this._handleStackInfo(stackInfo, options);\n    }\n},\n\n_handleStackInfo: function(stackInfo, options) {\n    var frames = this._prepareFrames(stackInfo, options);\n\n    this._triggerEvent('handle', {\n      stackInfo: stackInfo,\n      options: options\n    });\n\n    this._processException(\n      stackInfo.name,\n      stackInfo.message,\n      stackInfo.url,\n      stackInfo.lineno,\n      frames,\n      options\n    );\n},\n\n_processException: function(type, message, fileurl, lineno, frames, options) {\n    // 首先根据 message 信息判断是否是需要忽略的错误类型\n    // 然后判断出错的文件是否在黑名单中或者白名单中\n    // 接下来对错误内容进行必要的整合与转换，构造出 data 对象\n    // 最后调用上报函数\n    this._send(data);\n}\n\n_send: function(data) {\n\t\n\t// 对 data 进一步处理，增加必要的信息，包括后续会提到的面包屑信息\n\n\t// 交由 _sendProcessedPayload 进行进一步处理\n\tthis._sendProcessedPayload(data);\n}\n\n_sendProcessedPayload: function(data, callback) {\n\n\t// 对 data 增加一些必要的元信息\n\t// 可以通过自定义 globalOptions.transport 的方式来自定义上报函数 \n\t(globalOptions.transport || this._makeRequest).call(this, {\n\t     url: url,\n\t     auth: auth,\n\t     data: data,\n\t     options: globalOptions,\n\t     onSuccess: function success() {\n\t       \n\t     },\n\t     onError: function failure(error) {\n\t       \n\t     }\n\t});\n}    \n\n// 真正发起请求的函数\n_makeRequest: function(opts) {\n\t// 对于支持 fetch 的浏览器，直接使用 fetch 的方式发送 POST 请求\n\t// 如果浏览器不支持 fetch，则使用 XHR 的传统方式发送 POST 请求\n}\n``` \n\n实际上我们可以发现，从拿到已经初步格式化的报错信息，到最终真正执行数据上报，raven.js 的过程非常漫长，这其中我分析有如下几个原因：\n\n* 每个函数只处理一件或者一些事情，保持函数的短小整洁。\n* 部分函数可以做到复用（因为除了自动捕获错误的方式， raven.js 还提供通过 captureException，即 `try {\n    doSomething(a[0])\n} catch(e) {\n    Raven.captureException(e)\n}` 的方式来上报错误，两个过程中有一些函数的调用是有重叠的）。\n\n但是笔者认为，raven.js 的代码设计还有很多值得优化的地方，比如：\n\n* 对最终上报数据（data）的属性处理和增加分散在多个函数，并且有较多可选项目，很难梳理出一个完整的 data 格式，并且不便于维护。\n* 部分函数的拆分必要性不足，并且会增加链路的复杂性，比如 `_processException `、`_sendProcessedPayload `、`_makeRequest `等都只在一个链路中被调用一次。\n* 部分属性重命名会造成资源浪费，由于 TraceKit 部分最终返回的数据格式并不完全满足 raven.js 的需要，所以 raven.js 之后又在较后阶段进行了重命名等处理，实际上这些内容完全可以通过一些其他的方式避免。\n\n最后，非常遗憾，sentry 目前完全不支持合并上报，就算是在同一个事件循环（甚至事件循环的同一个阶段，关于事件循环，可以参考我之前绘制的[一张图](https://www.processon.com/view/link/5b6ec8cbe4b053a09c2fb977)）的两个错误，sentry 都是分开来上报的，这里有一个简单例子：\n\n```javascript\nRaven.config('http://8ec3f1a9f652463bb58191bd0b35f20c@localhost:9000/2').install()\nlet s = window.ss;\n\ntry{\n    let b = s.b\n} catch (e) {\n    Raven.captureException(e)\n    // sentry should report error now\n}\n\ns.nomethod();\n// sentry should report error now\n```\n\n以上例子中，sentry 会发送两个 POST 请求。\n\n### raven.js 最终上报数据的格式\n\n\n这一部分，我们并不会详细地分析 raven.js 上报的数据的每一项内容，仅会给读者展示一个比较典型的情况。\n\n我们看一下对于一个一般的 js 错误，raven.js 上报的 json 中包含哪些内容，下面是一个已经删掉一些冗余内容的典型上报信息：\n\n```\n{\n  \"project\": \"2\",\n  \"logger\": \"javascript\",\n  \"platform\": \"javascript\",\n  \"request\": {\n    \"headers\": {\n      \"User-Agent\": \"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\"\n    },\n    \"url\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\"\n  },\n  \"exception\": {\n    \"values\": [\n      {\n        \"type\": \"TypeError\",\n        \"value\": \"Cannot read property 'b' of undefined\",\n        \"stacktrace\": {\n          \"frames\": [\n            {\n              \"filename\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\",\n              \"lineno\": 19,\n              \"colno\": 19,\n              \"function\": \"?\",\n              \"in_app\": true\n            }\n          ]\n        }\n      }\n    ],\n    \"mechanism\": {\n      \"type\": \"generic\",\n      \"handled\": true\n    }\n  },\n  \"transaction\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\",\n  \"extra\": {\n    \"session:duration\": 6\n  },\n  \"breadcrumbs\": {\n    \"values\": [\n      {\n        \"timestamp\": 1534257309.996,\n        \"message\": \"_prepareFrames stackInfo: [object Object]\",\n        \"level\": \"log\",\n        \"category\": \"console\"\n      },\n      // ...\n   ]\n  },\n  \"event_id\": \"ea0334adaf9d43b78e72da2b10e084a9\",\n  \"trimHeadFrames\": 0\n}\n```\n\n其中支持的信息类型重点分为以下几种：\n\n* sentry 基本配置信息，包括库本身的配置和使用者的配置信息，以及用户的一些自定义信息\n* 错误信息，主要包括错误调用栈信息\n* request 信息，主要包括浏览器的 User-Agent、当前请求地址等\n* 面包屑信息，关于面包屑具体指的是什么，我们会在下一环节进行介绍\n\n### raven.js 面包屑收集\n\n面包屑信息，也就是错误在发生之前，一些用户、浏览器的行为信息，raven.js 实现了一个简单的队列（有一个最大条目长度，默认为 100），这个队列在时刻记录着这些信息，一旦错误发生并且需要上报，raven.js 就把这个队列的信息内容，作为面包屑 breadcrumbs，发回客户端。\n\n面包屑信息主要包括这几类：\n\n* 用户对某个元素的点击或者用户对某个可输入元素的输入\n* 发送的 http 请求\n* console 打印的信息（支持配置 'debug', 'info', 'warn', 'error', 'log' 等不同级别）\n* window.location 变化信息\n\n接下来，我们对这几类面包屑信息 sentry 的记录实现进行简单的分析。\n\n实际上，sentry 对这些信息记录的方式比较一致，都是通过对原声的函数进行包装，并且在包装好的函数中增加自己的钩子函数，来实现触发时候的事件记录，实际上，sentry 总共包装的函数有：\n\n* window.setTimeout\n* window.setInterval\n* window.requestAnimationFrame\n* EventTarget.addEventListener\n* EventTarget.removeEventListener\n* XMLHTTPRequest.open\n* XMLHTTPRequest.send\n* window.fetch\n* History.pushState\n* History.replaceState\n\n>备注：这里包装的所有函数，其中有一部分只是使 raven.js 具有捕获回调函数中错误的能力（对回调函数进行包装）\n\n接下来我们看一段典型的代码，来分析 raven.js 是如何记录用户的点击和输入信息的（通过对 EventTarget.addEventListener 进行封装）：\n\n```javascript\nfunction wrapEventTarget(global) {\n      var proto = _window[global] && _window[global].prototype;\n      if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {\n        fill(\n          proto,\n          'addEventListener',\n          function(orig) {\n            return function(evtName, fn, capture, secure) {\n              try {\n                if (fn && fn.handleEvent) { //兼容通过 handleEvent 的方式进行绑定事件\n                  fn.handleEvent = self.wrap(\n                    {\n                      mechanism: {\n                        type: 'instrument',\n                        data: {\n                          target: global,\n                          function: 'handleEvent',\n                          handler: (fn && fn.name) || '<anonymous>'\n                        }\n                      }\n                    },\n                    fn.handleEvent\n                  );\n                }\n              } catch (err) {\n              }\n\n              var before, clickHandler, keypressHandler;\n\n              if (\n                autoBreadcrumbs &&\n                autoBreadcrumbs.dom &&\n                (global === 'EventTarget' || global === 'Node')\n              ) {\n                // NOTE: generating multiple handlers per addEventListener invocation, should\n                //       revisit and verify we can just use one (almost certainly)\n                clickHandler = self._breadcrumbEventHandler('click');\n                keypressHandler = self._keypressEventHandler();\n                before = function(evt) { // 钩子函数，用于在回调函数调用的时候记录信息\n                  if (!evt) return;\n\n                  var eventType;\n                  try {\n                    eventType = evt.type;\n                  } catch (e) {\n                    // just accessing event properties can throw an exception in some rare circumstances\n                    // see: https://github.com/getsentry/raven-js/issues/838\n                    return;\n                  }\n                  if (eventType === 'click') return clickHandler(evt);\n                  else if (eventType === 'keypress') return keypressHandler(evt);\n                };\n              }\n              return orig.call(\n                this,\n                evtName,\n                self.wrap(\n                  {\n                    mechanism: {\n                      type: 'instrument',\n                      data: {\n                        target: global,\n                        function: 'addEventListener',\n                        handler: (fn && fn.name) || '<anonymous>'\n                      }\n                    }\n                  },\n                  fn,\n                  before\n                ),\n                capture,\n                secure\n              );\n            };\n          },\n          wrappedBuiltIns\n        );\n        fill(\n          proto,\n          'removeEventListener',\n          function(orig) {\n            return function(evt, fn, capture, secure) {\n              try {\n                fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);\n              } catch (e) {\n                // ignore, accessing __raven_wrapper__ will throw in some Selenium environments\n              }\n              return orig.call(this, evt, fn, capture, secure);\n            };\n          },\n          wrappedBuiltIns\n        );\n      }\n    }\n```\n\n以上代码兼容了通过 handleEvent 的方式进行绑定事件（如果没有听说过这种方式，可以在[这里](http://www.ayqy.net/blog/handleevent%E4%B8%8Eaddeventlistener/)补充一些相关的知识）。\n\n默认情况下，raven.js 只记录通过 `EventTarget.addEventListener` 绑定的点击和输入信息，实际上这是比较科学的，并且这些信息较为有效。另外，raven.js 也提供了记录所有点击和输入信息的可选项，其实现方式更为简单，直接在 document 上添加相关的监听即可。\n\n### raven.js 如何和框架配合使用\n\nraven.js 和框架配合使用的方式非常简单，但是我们要知道，很多框架内置了错误边界处理，或者对错误进行转义。以至于我们通过 window.onerror 的方式得不到完整的错误信息。同时，有些框架提供了错误处理的接口（比如 vue），利用错误处理的接口，我们能够获取到和错误有关的更多更重要的信息。\n\nraven.js 利用各个框架的官方接口，提供了 vue、require.js、angular、ember、react-native 等各个框架的官方插件。\n\n插件内容本身非常简单，我们可以看一下 vue 插件的代码：\n\n```\nfunction formatComponentName(vm) {\n  if (vm.$root === vm) {\n    return 'root instance';\n  }\n  var name = vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n  return (\n    (name ? 'component <' + name + '>' : 'anonymous component') +\n    (vm._isVue && vm.$options.__file ? ' at ' + vm.$options.__file : '')\n  );\n}\n\nfunction vuePlugin(Raven, Vue) {\n  Vue = Vue || window.Vue;\n\n  // quit if Vue isn't on the page\n  if (!Vue || !Vue.config) return;\n\n  var _oldOnError = Vue.config.errorHandler;\n  Vue.config.errorHandler = function VueErrorHandler(error, vm, info) {\n    var metaData = {};\n\n    // vm and lifecycleHook are not always available\n    if (Object.prototype.toString.call(vm) === '[object Object]') {\n      metaData.componentName = formatComponentName(vm);\n      metaData.propsData = vm.$options.propsData;\n    }\n\n    if (typeof info !== 'undefined') {\n      metaData.lifecycleHook = info;\n    }\n\n    Raven.captureException(error, {\n      extra: metaData\n    });\n\n    if (typeof _oldOnError === 'function') {\n      _oldOnError.call(this, error, vm, info);\n    }\n  };\n}\n\nmodule.exports = vuePlugin;\n```\n\n应该不用进行过多解释。\n\n你也许想知道为什么没有提供 react 插件，事实上，react 16 以后才引入了[Error Boundaries](https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html)，这种方式由于灵活性太强，并不太适合使用插件，另外，就算不使用插件，也非常方便地使用 raven.js 进行错误上报，可以参考[这里](https://docs.sentry.io/clients/javascript/integrations/react/)\n\n>但笔者认为，目前 react 的引入方式会对源代码进行侵入，并且比较难通过构建的方式进行 sentry 的配置，也许我们可以寻找更好的方式。\n\n完。\n\n","source":"_posts/从源码分析sentry的错误信息收集.md","raw":"---\ntitle: 从源码分析sentry的错误信息收集\ntags:\n  - javascript\n  - 前端监控\nabbrlink: 3989724746\ndate: 2018-08-18 19:23:55\n---\n\nraven.js 是 sentry 为 JavaScript 错误上报提供的 JS-SDK，本篇我们基于其源代码对其原理进行分析，本篇文章只分析前端部分，对应的文件目录是`https://github.com/getsentry/sentry-javascript/tree/master/packages/raven-js`。\n\n首先抛出几个问题：\n\n* **raven.js 是如何收集浏览器错误信息的？**\n* **raven.js 上报的错误信息格式是什么样的？又是如何把这些信息传给后端？支不支持合并上报？**\n* **面包屑（breadcrumbs）是什么？raven.js 如何来收集面包屑信息？**\n* **raven.js 如何和框架配合使用（比如 vue、react）？**\n\n在回答以上这几个问题之前，我们首先来对 raven.js 做一个宏观的分析，主要涉及其文件目录、所引用的第三方框架等。\n\nraven.js 的核心文件内容并不多，其中使用了三个第三方库，放在了 vendor 文件夹下：\n\n* [json-stringify-safe](https://github.com/moll/json-stringify-safe) ：一个对 `JSON.stringify` 的封装，安全的 json 序列化操作函数，不会抛出循环引用的错误。\n\t* 这里面有一个注意点要单独说一下，我们熟知的 `JSON.stringify` , 可以接受三个参数：第一个参数是我们要序列化的对象；第二个参数是对其中键值对的处理函数；第三个参数是控制缩进空格。reven.js 的 `json-stringify-safe` 就是充分利用了这三个参数。\n* [md5](https://github.com/blueimp/JavaScript-MD5)：js 的 md5 函数。\n* [TraceKit](https://github.com/csnover/TraceKit)：TraceKit 是一个已经比较完善的错误收集、堆栈格式化的库，reven.js 的功能在很大程度上对它有所依赖。\n\n除此之外，raven.js 支持插件，官方提供的一些知名库的 sentry 插件主要放在了 plugin 文件夹下面，raven.js 的一些核心文件，则放在了 src 文件夹下面。\n\n### raven.js 是如何收集错误信息的？\n\n我们知道，在前端收集错误，肯定离不开 `window.onerror` 这个函数，那么我们就从这个函数说起。\n\n实际上，这部分工作是 raven.js 引用的第三方库 TraceKit 完成的：\n\n```\nfunction installGlobalHandler() {\n  if (_onErrorHandlerInstalled) { // 一个起到标志作用的全局变量\n    return;\n  }\n  _oldOnerrorHandler = _window.onerror; \n  // _oldOnerrorHandler 是防止对用户其他地方定义的回调函数进行覆盖\n  // 该 _window 经过兼容，实际上就是 window\n  _window.onerror = traceKitWindowOnError;\n  _onErrorHandlerInstalled = true;\n}\n```\n\n相关错误回调函数交给 traceKitWindowOnError 处理，下面我们来看一下 traceKitWindowOnError 函数，为了避免太多冗余代码，我们仅分析一种主要情况：\n\n```\nfunction traceKitWindowOnError(msg, url, lineNo, colNo, ex) {\n\t\n\tvar exception = utils.isErrorEvent(ex) ? ex.error : ex;\n\t//...\n    stack = TraceKit.computeStackTrace(exception);\n    notifyHandlers(stack, true);\n    //...\n   \n    //...\n    if (_oldOnerrorHandler) {\n       return _oldOnerrorHandler.apply(this, arguments);\n    }\n    return false;\n}\n```\n\n其中调用的最重要的一个函数，就是 computeStackTrace，而这个函数也是 TraceKit 的核心函数，简单来讲，它做的事情就是统一格式化报错信息调用栈，因为对于各个浏览器来说，返回的 Error 调用栈信息格式不尽相同，另外甚至还有的浏览器并不返回调用栈，computeStackTrace 函数对这些情况都做了兼容性处理，并且对于一些不返回调用栈的情况，还使用了 caller 来向上回溯函数的调用栈，最终把报错信息转化成一个键相同的对象数组，做到了报错信息格式的统一。\n\nnotifyHandlers 函数则是通知相关的回调函数。 实际上，raven.js 在 install 函数中会调用 TraceKit.report.subscribe 函数，并把对错误的处理逻辑写入回调：\n\n```\nfunction subscribe(handler) {\n    installGlobalHandler();\n    handlers.push(handler);\n}\n```\n\n以上过程完成了错误处理过程中的负责角色转换，并且借助 TraceKit，可以使 raven.js 得到一个结构比较清晰的带有格式化好的调用栈信息的错误内容对象，之后，raven.js 对错误内容进一步处理并最终上报。\n\n下面我们对错误处理 raven.js 控制的部分做了一些梳理：\n\n```\n _handleOnErrorStackInfo: function(stackInfo, options) {\n    options.mechanism = options.mechanism || {\n      type: 'onerror',\n      handled: false\n    };\n    // mechanism 和错误统计来源有关\n\n    if (!this._ignoreOnError) {\n      this._handleStackInfo(stackInfo, options);\n    }\n},\n\n_handleStackInfo: function(stackInfo, options) {\n    var frames = this._prepareFrames(stackInfo, options);\n\n    this._triggerEvent('handle', {\n      stackInfo: stackInfo,\n      options: options\n    });\n\n    this._processException(\n      stackInfo.name,\n      stackInfo.message,\n      stackInfo.url,\n      stackInfo.lineno,\n      frames,\n      options\n    );\n},\n\n_processException: function(type, message, fileurl, lineno, frames, options) {\n    // 首先根据 message 信息判断是否是需要忽略的错误类型\n    // 然后判断出错的文件是否在黑名单中或者白名单中\n    // 接下来对错误内容进行必要的整合与转换，构造出 data 对象\n    // 最后调用上报函数\n    this._send(data);\n}\n\n_send: function(data) {\n\t\n\t// 对 data 进一步处理，增加必要的信息，包括后续会提到的面包屑信息\n\n\t// 交由 _sendProcessedPayload 进行进一步处理\n\tthis._sendProcessedPayload(data);\n}\n\n_sendProcessedPayload: function(data, callback) {\n\n\t// 对 data 增加一些必要的元信息\n\t// 可以通过自定义 globalOptions.transport 的方式来自定义上报函数 \n\t(globalOptions.transport || this._makeRequest).call(this, {\n\t     url: url,\n\t     auth: auth,\n\t     data: data,\n\t     options: globalOptions,\n\t     onSuccess: function success() {\n\t       \n\t     },\n\t     onError: function failure(error) {\n\t       \n\t     }\n\t});\n}    \n\n// 真正发起请求的函数\n_makeRequest: function(opts) {\n\t// 对于支持 fetch 的浏览器，直接使用 fetch 的方式发送 POST 请求\n\t// 如果浏览器不支持 fetch，则使用 XHR 的传统方式发送 POST 请求\n}\n``` \n\n实际上我们可以发现，从拿到已经初步格式化的报错信息，到最终真正执行数据上报，raven.js 的过程非常漫长，这其中我分析有如下几个原因：\n\n* 每个函数只处理一件或者一些事情，保持函数的短小整洁。\n* 部分函数可以做到复用（因为除了自动捕获错误的方式， raven.js 还提供通过 captureException，即 `try {\n    doSomething(a[0])\n} catch(e) {\n    Raven.captureException(e)\n}` 的方式来上报错误，两个过程中有一些函数的调用是有重叠的）。\n\n但是笔者认为，raven.js 的代码设计还有很多值得优化的地方，比如：\n\n* 对最终上报数据（data）的属性处理和增加分散在多个函数，并且有较多可选项目，很难梳理出一个完整的 data 格式，并且不便于维护。\n* 部分函数的拆分必要性不足，并且会增加链路的复杂性，比如 `_processException `、`_sendProcessedPayload `、`_makeRequest `等都只在一个链路中被调用一次。\n* 部分属性重命名会造成资源浪费，由于 TraceKit 部分最终返回的数据格式并不完全满足 raven.js 的需要，所以 raven.js 之后又在较后阶段进行了重命名等处理，实际上这些内容完全可以通过一些其他的方式避免。\n\n最后，非常遗憾，sentry 目前完全不支持合并上报，就算是在同一个事件循环（甚至事件循环的同一个阶段，关于事件循环，可以参考我之前绘制的[一张图](https://www.processon.com/view/link/5b6ec8cbe4b053a09c2fb977)）的两个错误，sentry 都是分开来上报的，这里有一个简单例子：\n\n```javascript\nRaven.config('http://8ec3f1a9f652463bb58191bd0b35f20c@localhost:9000/2').install()\nlet s = window.ss;\n\ntry{\n    let b = s.b\n} catch (e) {\n    Raven.captureException(e)\n    // sentry should report error now\n}\n\ns.nomethod();\n// sentry should report error now\n```\n\n以上例子中，sentry 会发送两个 POST 请求。\n\n### raven.js 最终上报数据的格式\n\n\n这一部分，我们并不会详细地分析 raven.js 上报的数据的每一项内容，仅会给读者展示一个比较典型的情况。\n\n我们看一下对于一个一般的 js 错误，raven.js 上报的 json 中包含哪些内容，下面是一个已经删掉一些冗余内容的典型上报信息：\n\n```\n{\n  \"project\": \"2\",\n  \"logger\": \"javascript\",\n  \"platform\": \"javascript\",\n  \"request\": {\n    \"headers\": {\n      \"User-Agent\": \"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\"\n    },\n    \"url\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\"\n  },\n  \"exception\": {\n    \"values\": [\n      {\n        \"type\": \"TypeError\",\n        \"value\": \"Cannot read property 'b' of undefined\",\n        \"stacktrace\": {\n          \"frames\": [\n            {\n              \"filename\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\",\n              \"lineno\": 19,\n              \"colno\": 19,\n              \"function\": \"?\",\n              \"in_app\": true\n            }\n          ]\n        }\n      }\n    ],\n    \"mechanism\": {\n      \"type\": \"generic\",\n      \"handled\": true\n    }\n  },\n  \"transaction\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\",\n  \"extra\": {\n    \"session:duration\": 6\n  },\n  \"breadcrumbs\": {\n    \"values\": [\n      {\n        \"timestamp\": 1534257309.996,\n        \"message\": \"_prepareFrames stackInfo: [object Object]\",\n        \"level\": \"log\",\n        \"category\": \"console\"\n      },\n      // ...\n   ]\n  },\n  \"event_id\": \"ea0334adaf9d43b78e72da2b10e084a9\",\n  \"trimHeadFrames\": 0\n}\n```\n\n其中支持的信息类型重点分为以下几种：\n\n* sentry 基本配置信息，包括库本身的配置和使用者的配置信息，以及用户的一些自定义信息\n* 错误信息，主要包括错误调用栈信息\n* request 信息，主要包括浏览器的 User-Agent、当前请求地址等\n* 面包屑信息，关于面包屑具体指的是什么，我们会在下一环节进行介绍\n\n### raven.js 面包屑收集\n\n面包屑信息，也就是错误在发生之前，一些用户、浏览器的行为信息，raven.js 实现了一个简单的队列（有一个最大条目长度，默认为 100），这个队列在时刻记录着这些信息，一旦错误发生并且需要上报，raven.js 就把这个队列的信息内容，作为面包屑 breadcrumbs，发回客户端。\n\n面包屑信息主要包括这几类：\n\n* 用户对某个元素的点击或者用户对某个可输入元素的输入\n* 发送的 http 请求\n* console 打印的信息（支持配置 'debug', 'info', 'warn', 'error', 'log' 等不同级别）\n* window.location 变化信息\n\n接下来，我们对这几类面包屑信息 sentry 的记录实现进行简单的分析。\n\n实际上，sentry 对这些信息记录的方式比较一致，都是通过对原声的函数进行包装，并且在包装好的函数中增加自己的钩子函数，来实现触发时候的事件记录，实际上，sentry 总共包装的函数有：\n\n* window.setTimeout\n* window.setInterval\n* window.requestAnimationFrame\n* EventTarget.addEventListener\n* EventTarget.removeEventListener\n* XMLHTTPRequest.open\n* XMLHTTPRequest.send\n* window.fetch\n* History.pushState\n* History.replaceState\n\n>备注：这里包装的所有函数，其中有一部分只是使 raven.js 具有捕获回调函数中错误的能力（对回调函数进行包装）\n\n接下来我们看一段典型的代码，来分析 raven.js 是如何记录用户的点击和输入信息的（通过对 EventTarget.addEventListener 进行封装）：\n\n```javascript\nfunction wrapEventTarget(global) {\n      var proto = _window[global] && _window[global].prototype;\n      if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {\n        fill(\n          proto,\n          'addEventListener',\n          function(orig) {\n            return function(evtName, fn, capture, secure) {\n              try {\n                if (fn && fn.handleEvent) { //兼容通过 handleEvent 的方式进行绑定事件\n                  fn.handleEvent = self.wrap(\n                    {\n                      mechanism: {\n                        type: 'instrument',\n                        data: {\n                          target: global,\n                          function: 'handleEvent',\n                          handler: (fn && fn.name) || '<anonymous>'\n                        }\n                      }\n                    },\n                    fn.handleEvent\n                  );\n                }\n              } catch (err) {\n              }\n\n              var before, clickHandler, keypressHandler;\n\n              if (\n                autoBreadcrumbs &&\n                autoBreadcrumbs.dom &&\n                (global === 'EventTarget' || global === 'Node')\n              ) {\n                // NOTE: generating multiple handlers per addEventListener invocation, should\n                //       revisit and verify we can just use one (almost certainly)\n                clickHandler = self._breadcrumbEventHandler('click');\n                keypressHandler = self._keypressEventHandler();\n                before = function(evt) { // 钩子函数，用于在回调函数调用的时候记录信息\n                  if (!evt) return;\n\n                  var eventType;\n                  try {\n                    eventType = evt.type;\n                  } catch (e) {\n                    // just accessing event properties can throw an exception in some rare circumstances\n                    // see: https://github.com/getsentry/raven-js/issues/838\n                    return;\n                  }\n                  if (eventType === 'click') return clickHandler(evt);\n                  else if (eventType === 'keypress') return keypressHandler(evt);\n                };\n              }\n              return orig.call(\n                this,\n                evtName,\n                self.wrap(\n                  {\n                    mechanism: {\n                      type: 'instrument',\n                      data: {\n                        target: global,\n                        function: 'addEventListener',\n                        handler: (fn && fn.name) || '<anonymous>'\n                      }\n                    }\n                  },\n                  fn,\n                  before\n                ),\n                capture,\n                secure\n              );\n            };\n          },\n          wrappedBuiltIns\n        );\n        fill(\n          proto,\n          'removeEventListener',\n          function(orig) {\n            return function(evt, fn, capture, secure) {\n              try {\n                fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);\n              } catch (e) {\n                // ignore, accessing __raven_wrapper__ will throw in some Selenium environments\n              }\n              return orig.call(this, evt, fn, capture, secure);\n            };\n          },\n          wrappedBuiltIns\n        );\n      }\n    }\n```\n\n以上代码兼容了通过 handleEvent 的方式进行绑定事件（如果没有听说过这种方式，可以在[这里](http://www.ayqy.net/blog/handleevent%E4%B8%8Eaddeventlistener/)补充一些相关的知识）。\n\n默认情况下，raven.js 只记录通过 `EventTarget.addEventListener` 绑定的点击和输入信息，实际上这是比较科学的，并且这些信息较为有效。另外，raven.js 也提供了记录所有点击和输入信息的可选项，其实现方式更为简单，直接在 document 上添加相关的监听即可。\n\n### raven.js 如何和框架配合使用\n\nraven.js 和框架配合使用的方式非常简单，但是我们要知道，很多框架内置了错误边界处理，或者对错误进行转义。以至于我们通过 window.onerror 的方式得不到完整的错误信息。同时，有些框架提供了错误处理的接口（比如 vue），利用错误处理的接口，我们能够获取到和错误有关的更多更重要的信息。\n\nraven.js 利用各个框架的官方接口，提供了 vue、require.js、angular、ember、react-native 等各个框架的官方插件。\n\n插件内容本身非常简单，我们可以看一下 vue 插件的代码：\n\n```\nfunction formatComponentName(vm) {\n  if (vm.$root === vm) {\n    return 'root instance';\n  }\n  var name = vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n  return (\n    (name ? 'component <' + name + '>' : 'anonymous component') +\n    (vm._isVue && vm.$options.__file ? ' at ' + vm.$options.__file : '')\n  );\n}\n\nfunction vuePlugin(Raven, Vue) {\n  Vue = Vue || window.Vue;\n\n  // quit if Vue isn't on the page\n  if (!Vue || !Vue.config) return;\n\n  var _oldOnError = Vue.config.errorHandler;\n  Vue.config.errorHandler = function VueErrorHandler(error, vm, info) {\n    var metaData = {};\n\n    // vm and lifecycleHook are not always available\n    if (Object.prototype.toString.call(vm) === '[object Object]') {\n      metaData.componentName = formatComponentName(vm);\n      metaData.propsData = vm.$options.propsData;\n    }\n\n    if (typeof info !== 'undefined') {\n      metaData.lifecycleHook = info;\n    }\n\n    Raven.captureException(error, {\n      extra: metaData\n    });\n\n    if (typeof _oldOnError === 'function') {\n      _oldOnError.call(this, error, vm, info);\n    }\n  };\n}\n\nmodule.exports = vuePlugin;\n```\n\n应该不用进行过多解释。\n\n你也许想知道为什么没有提供 react 插件，事实上，react 16 以后才引入了[Error Boundaries](https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html)，这种方式由于灵活性太强，并不太适合使用插件，另外，就算不使用插件，也非常方便地使用 raven.js 进行错误上报，可以参考[这里](https://docs.sentry.io/clients/javascript/integrations/react/)\n\n>但笔者认为，目前 react 的引入方式会对源代码进行侵入，并且比较难通过构建的方式进行 sentry 的配置，也许我们可以寻找更好的方式。\n\n完。\n\n","slug":"从源码分析sentry的错误信息收集","published":1,"updated":"2021-12-23T05:50:07.554Z","_id":"ckxijpqtn002pd3mr71jueqtf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>raven.js 是 sentry 为 JavaScript 错误上报提供的 JS-SDK，本篇我们基于其源代码对其原理进行分析，本篇文章只分析前端部分，对应的文件目录是<code>https://github.com/getsentry/sentry-javascript/tree/master/packages/raven-js</code>。</p>\n<p>首先抛出几个问题：</p>\n<ul>\n<li><strong>raven.js 是如何收集浏览器错误信息的？</strong></li>\n<li><strong>raven.js 上报的错误信息格式是什么样的？又是如何把这些信息传给后端？支不支持合并上报？</strong></li>\n<li><strong>面包屑（breadcrumbs）是什么？raven.js 如何来收集面包屑信息？</strong></li>\n<li><strong>raven.js 如何和框架配合使用（比如 vue、react）？</strong></li>\n</ul>\n<p>在回答以上这几个问题之前，我们首先来对 raven.js 做一个宏观的分析，主要涉及其文件目录、所引用的第三方框架等。</p>\n<p>raven.js 的核心文件内容并不多，其中使用了三个第三方库，放在了 vendor 文件夹下：</p>\n<ul>\n<li><a href=\"https://github.com/moll/json-stringify-safe\">json-stringify-safe</a> ：一个对 <code>JSON.stringify</code> 的封装，安全的 json 序列化操作函数，不会抛出循环引用的错误。<ul>\n<li>这里面有一个注意点要单独说一下，我们熟知的 <code>JSON.stringify</code> , 可以接受三个参数：第一个参数是我们要序列化的对象；第二个参数是对其中键值对的处理函数；第三个参数是控制缩进空格。reven.js 的 <code>json-stringify-safe</code> 就是充分利用了这三个参数。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/blueimp/JavaScript-MD5\">md5</a>：js 的 md5 函数。</li>\n<li><a href=\"https://github.com/csnover/TraceKit\">TraceKit</a>：TraceKit 是一个已经比较完善的错误收集、堆栈格式化的库，reven.js 的功能在很大程度上对它有所依赖。</li>\n</ul>\n<p>除此之外，raven.js 支持插件，官方提供的一些知名库的 sentry 插件主要放在了 plugin 文件夹下面，raven.js 的一些核心文件，则放在了 src 文件夹下面。</p>\n<h3 id=\"raven-js-是如何收集错误信息的？\"><a href=\"#raven-js-是如何收集错误信息的？\" class=\"headerlink\" title=\"raven.js 是如何收集错误信息的？\"></a>raven.js 是如何收集错误信息的？</h3><p>我们知道，在前端收集错误，肯定离不开 <code>window.onerror</code> 这个函数，那么我们就从这个函数说起。</p>\n<p>实际上，这部分工作是 raven.js 引用的第三方库 TraceKit 完成的：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> install<span class=\"constructor\">GlobalHandler()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_onErrorHandlerInstalled) &#123; <span class=\"comment\">// 一个起到标志作用的全局变量</span></span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _oldOnerrorHandler = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_window</span>.</span></span>onerror; </span><br><span class=\"line\">  <span class=\"comment\">// _oldOnerrorHandler 是防止对用户其他地方定义的回调函数进行覆盖</span></span><br><span class=\"line\">  <span class=\"comment\">// 该 _window 经过兼容，实际上就是 window</span></span><br><span class=\"line\">  <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_window</span>.</span></span>onerror = traceKitWindowOnError;</span><br><span class=\"line\">  _onErrorHandlerInstalled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相关错误回调函数交给 traceKitWindowOnError 处理，下面我们来看一下 traceKitWindowOnError 函数，为了避免太多冗余代码，我们仅分析一种主要情况：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> trace<span class=\"constructor\">KitWindowOnError(<span class=\"params\">msg</span>, <span class=\"params\">url</span>, <span class=\"params\">lineNo</span>, <span class=\"params\">colNo</span>, <span class=\"params\">ex</span>)</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvar <span class=\"keyword\">exception</span> = utils.is<span class=\"constructor\">ErrorEvent(<span class=\"params\">ex</span>)</span> ? ex.error : ex;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    stack = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">TraceKit</span>.</span></span>compute<span class=\"constructor\">StackTrace(<span class=\"params\">exception</span>)</span>;</span><br><span class=\"line\">    notify<span class=\"constructor\">Handlers(<span class=\"params\">stack</span>, <span class=\"params\">true</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_oldOnerrorHandler) &#123;</span><br><span class=\"line\">       return <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_oldOnerrorHandler</span>.</span></span>apply(this, arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中调用的最重要的一个函数，就是 computeStackTrace，而这个函数也是 TraceKit 的核心函数，简单来讲，它做的事情就是统一格式化报错信息调用栈，因为对于各个浏览器来说，返回的 Error 调用栈信息格式不尽相同，另外甚至还有的浏览器并不返回调用栈，computeStackTrace 函数对这些情况都做了兼容性处理，并且对于一些不返回调用栈的情况，还使用了 caller 来向上回溯函数的调用栈，最终把报错信息转化成一个键相同的对象数组，做到了报错信息格式的统一。</p>\n<p>notifyHandlers 函数则是通知相关的回调函数。 实际上，raven.js 在 install 函数中会调用 TraceKit.report.subscribe 函数，并把对错误的处理逻辑写入回调：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(handler) &#123;</span><br><span class=\"line\">    installGlobalHandler();</span><br><span class=\"line\">    handlers.push(handler);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上过程完成了错误处理过程中的负责角色转换，并且借助 TraceKit，可以使 raven.js 得到一个结构比较清晰的带有格式化好的调用栈信息的错误内容对象，之后，raven.js 对错误内容进一步处理并最终上报。</p>\n<p>下面我们对错误处理 raven.js 控制的部分做了一些梳理：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"attribute\">_handleOnErrorStackInfo</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">stackInfo, options</span>) </span>&#123;</span><br><span class=\"line\">    options.mechanism = options.mechanism || &#123;</span><br><span class=\"line\">      <span class=\"attribute\">type</span>: <span class=\"string\">&#x27;onerror&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attribute\">handled</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// mechanism 和错误统计来源有关</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>._ignoreOnError) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._handleStackInfo(stackInfo, options);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">_handleStackInfo</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">stackInfo, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> frames = <span class=\"keyword\">this</span>._prepareFrames(stackInfo, options);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._triggerEvent(<span class=\"string\">&#x27;handle&#x27;</span>, &#123;</span><br><span class=\"line\">      <span class=\"attribute\">stackInfo</span>: stackInfo,</span><br><span class=\"line\">      <span class=\"attribute\">options</span>: options</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._processException(</span><br><span class=\"line\">      stackInfo.name,</span><br><span class=\"line\">      stackInfo.message,</span><br><span class=\"line\">      stackInfo.url,</span><br><span class=\"line\">      stackInfo.lineno,</span><br><span class=\"line\">      frames,</span><br><span class=\"line\">      options</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">_processException</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, message, fileurl, lineno, frames, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先根据 message 信息判断是否是需要忽略的错误类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后判断出错的文件是否在黑名单中或者白名单中</span></span><br><span class=\"line\">    <span class=\"comment\">// 接下来对错误内容进行必要的整合与转换，构造出 data 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后调用上报函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._send(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">_send</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 对 data 进一步处理，增加必要的信息，包括后续会提到的面包屑信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 交由 _sendProcessedPayload 进行进一步处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>._sendProcessedPayload(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">_sendProcessedPayload</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, callback</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 对 data 增加一些必要的元信息</span></span><br><span class=\"line\">\t<span class=\"comment\">// 可以通过自定义 globalOptions.transport 的方式来自定义上报函数 </span></span><br><span class=\"line\">\t(globalOptions.transport || <span class=\"keyword\">this</span>._makeRequest).call(<span class=\"keyword\">this</span>, &#123;</span><br><span class=\"line\">\t     <span class=\"attribute\">url</span>: <span class=\"built_in\">url</span>,</span><br><span class=\"line\">\t     <span class=\"attribute\">auth</span>: auth,</span><br><span class=\"line\">\t     <span class=\"attribute\">data</span>: data,</span><br><span class=\"line\">\t     <span class=\"attribute\">options</span>: globalOptions,</span><br><span class=\"line\">\t     <span class=\"attribute\">onSuccess</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">success</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t       </span><br><span class=\"line\">\t     &#125;,</span><br><span class=\"line\">\t     <span class=\"attribute\">onError</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">failure</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">\t       </span><br><span class=\"line\">\t     &#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 真正发起请求的函数</span></span><br><span class=\"line\"><span class=\"attribute\">_makeRequest</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 对于支持 fetch 的浏览器，直接使用 fetch 的方式发送 POST 请求</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果浏览器不支持 fetch，则使用 XHR 的传统方式发送 POST 请求</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上我们可以发现，从拿到已经初步格式化的报错信息，到最终真正执行数据上报，raven.js 的过程非常漫长，这其中我分析有如下几个原因：</p>\n<ul>\n<li>每个函数只处理一件或者一些事情，保持函数的短小整洁。</li>\n<li>部分函数可以做到复用（因为除了自动捕获错误的方式， raven.js 还提供通过 captureException，即 <code>try &#123;   doSomething(a[0]) &#125; catch(e) &#123;   Raven.captureException(e) &#125;</code> 的方式来上报错误，两个过程中有一些函数的调用是有重叠的）。</li>\n</ul>\n<p>但是笔者认为，raven.js 的代码设计还有很多值得优化的地方，比如：</p>\n<ul>\n<li>对最终上报数据（data）的属性处理和增加分散在多个函数，并且有较多可选项目，很难梳理出一个完整的 data 格式，并且不便于维护。</li>\n<li>部分函数的拆分必要性不足，并且会增加链路的复杂性，比如 <code>_processException </code>、<code>_sendProcessedPayload </code>、<code>_makeRequest </code>等都只在一个链路中被调用一次。</li>\n<li>部分属性重命名会造成资源浪费，由于 TraceKit 部分最终返回的数据格式并不完全满足 raven.js 的需要，所以 raven.js 之后又在较后阶段进行了重命名等处理，实际上这些内容完全可以通过一些其他的方式避免。</li>\n</ul>\n<p>最后，非常遗憾，sentry 目前完全不支持合并上报，就算是在同一个事件循环（甚至事件循环的同一个阶段，关于事件循环，可以参考我之前绘制的<a href=\"https://www.processon.com/view/link/5b6ec8cbe4b053a09c2fb977\">一张图</a>）的两个错误，sentry 都是分开来上报的，这里有一个简单例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Raven.config(<span class=\"string\">&#x27;http://8ec3f1a9f652463bb58191bd0b35f20c@localhost:9000/2&#x27;</span>).install()</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">window</span>.ss;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = s.b</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    Raven.captureException(e)</span><br><span class=\"line\">    <span class=\"comment\">// sentry should report error now</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">s.nomethod();</span><br><span class=\"line\"><span class=\"comment\">// sentry should report error now</span></span><br></pre></td></tr></table></figure>\n\n<p>以上例子中，sentry 会发送两个 POST 请求。</p>\n<h3 id=\"raven-js-最终上报数据的格式\"><a href=\"#raven-js-最终上报数据的格式\" class=\"headerlink\" title=\"raven.js 最终上报数据的格式\"></a>raven.js 最终上报数据的格式</h3><p>这一部分，我们并不会详细地分析 raven.js 上报的数据的每一项内容，仅会给读者展示一个比较典型的情况。</p>\n<p>我们看一下对于一个一般的 js 错误，raven.js 上报的 json 中包含哪些内容，下面是一个已经删掉一些冗余内容的典型上报信息：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;project&quot;</span>: <span class=\"string\">&quot;2&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;logger&quot;</span>: <span class=\"string\">&quot;javascript&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;platform&quot;</span>: <span class=\"string\">&quot;javascript&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;request&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;headers&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;User-Agent&quot;</span>: <span class=\"string\">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">&quot;url&quot;</span>: <span class=\"string\">&quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;exception&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;values&quot;</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;TypeError&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span>: <span class=\"string\">&quot;Cannot read property &#x27;b&#x27; of undefined&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;stacktrace&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">&quot;frames&quot;</span>: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"attr\">&quot;filename&quot;</span>: <span class=\"string\">&quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;</span>,</span><br><span class=\"line\">              <span class=\"attr\">&quot;lineno&quot;</span>: <span class=\"number\">19</span>,</span><br><span class=\"line\">              <span class=\"attr\">&quot;colno&quot;</span>: <span class=\"number\">19</span>,</span><br><span class=\"line\">              <span class=\"attr\">&quot;function&quot;</span>: <span class=\"string\">&quot;?&quot;</span>,</span><br><span class=\"line\">              <span class=\"attr\">&quot;in_app&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">&quot;mechanism&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;generic&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;handled&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;transaction&quot;</span>: <span class=\"string\">&quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;extra&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;session:duration&quot;</span>: <span class=\"number\">6</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;breadcrumbs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;values&quot;</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;timestamp&quot;</span>: <span class=\"number\">1534257309.996</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;message&quot;</span>: <span class=\"string\">&quot;_prepareFrames stackInfo: [object Object]&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;level&quot;</span>: <span class=\"string\">&quot;log&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;category&quot;</span>: <span class=\"string\">&quot;console&quot;</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">   ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;event_id&quot;</span>: <span class=\"string\">&quot;ea0334adaf9d43b78e72da2b10e084a9&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;trimHeadFrames&quot;</span>: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中支持的信息类型重点分为以下几种：</p>\n<ul>\n<li>sentry 基本配置信息，包括库本身的配置和使用者的配置信息，以及用户的一些自定义信息</li>\n<li>错误信息，主要包括错误调用栈信息</li>\n<li>request 信息，主要包括浏览器的 User-Agent、当前请求地址等</li>\n<li>面包屑信息，关于面包屑具体指的是什么，我们会在下一环节进行介绍</li>\n</ul>\n<h3 id=\"raven-js-面包屑收集\"><a href=\"#raven-js-面包屑收集\" class=\"headerlink\" title=\"raven.js 面包屑收集\"></a>raven.js 面包屑收集</h3><p>面包屑信息，也就是错误在发生之前，一些用户、浏览器的行为信息，raven.js 实现了一个简单的队列（有一个最大条目长度，默认为 100），这个队列在时刻记录着这些信息，一旦错误发生并且需要上报，raven.js 就把这个队列的信息内容，作为面包屑 breadcrumbs，发回客户端。</p>\n<p>面包屑信息主要包括这几类：</p>\n<ul>\n<li>用户对某个元素的点击或者用户对某个可输入元素的输入</li>\n<li>发送的 http 请求</li>\n<li>console 打印的信息（支持配置 ‘debug’, ‘info’, ‘warn’, ‘error’, ‘log’ 等不同级别）</li>\n<li>window.location 变化信息</li>\n</ul>\n<p>接下来，我们对这几类面包屑信息 sentry 的记录实现进行简单的分析。</p>\n<p>实际上，sentry 对这些信息记录的方式比较一致，都是通过对原声的函数进行包装，并且在包装好的函数中增加自己的钩子函数，来实现触发时候的事件记录，实际上，sentry 总共包装的函数有：</p>\n<ul>\n<li>window.setTimeout</li>\n<li>window.setInterval</li>\n<li>window.requestAnimationFrame</li>\n<li>EventTarget.addEventListener</li>\n<li>EventTarget.removeEventListener</li>\n<li>XMLHTTPRequest.open</li>\n<li>XMLHTTPRequest.send</li>\n<li>window.fetch</li>\n<li>History.pushState</li>\n<li>History.replaceState</li>\n</ul>\n<blockquote>\n<p>备注：这里包装的所有函数，其中有一部分只是使 raven.js 具有捕获回调函数中错误的能力（对回调函数进行包装）</p>\n</blockquote>\n<p>接下来我们看一段典型的代码，来分析 raven.js 是如何记录用户的点击和输入信息的（通过对 EventTarget.addEventListener 进行封装）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapEventTarget</span>(<span class=\"params\"><span class=\"built_in\">global</span></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> proto = _window[<span class=\"built_in\">global</span>] &amp;&amp; _window[<span class=\"built_in\">global</span>].prototype;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (proto &amp;&amp; proto.hasOwnProperty &amp;&amp; proto.hasOwnProperty(<span class=\"string\">&#x27;addEventListener&#x27;</span>)) &#123;</span><br><span class=\"line\">        fill(</span><br><span class=\"line\">          proto,</span><br><span class=\"line\">          <span class=\"string\">&#x27;addEventListener&#x27;</span>,</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">orig</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evtName, fn, capture, secure</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fn &amp;&amp; fn.handleEvent) &#123; <span class=\"comment\">//兼容通过 handleEvent 的方式进行绑定事件</span></span><br><span class=\"line\">                  fn.handleEvent = self.wrap(</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                      <span class=\"attr\">mechanism</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">type</span>: <span class=\"string\">&#x27;instrument&#x27;</span>,</span><br><span class=\"line\">                        <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">                          <span class=\"attr\">target</span>: <span class=\"built_in\">global</span>,</span><br><span class=\"line\">                          <span class=\"attr\">function</span>: <span class=\"string\">&#x27;handleEvent&#x27;</span>,</span><br><span class=\"line\">                          <span class=\"attr\">handler</span>: (fn &amp;&amp; fn.name) || <span class=\"string\">&#x27;&lt;anonymous&gt;&#x27;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    fn.handleEvent</span><br><span class=\"line\">                  );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">var</span> before, clickHandler, keypressHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                autoBreadcrumbs &amp;&amp;</span><br><span class=\"line\">                autoBreadcrumbs.dom &amp;&amp;</span><br><span class=\"line\">                (<span class=\"built_in\">global</span> === <span class=\"string\">&#x27;EventTarget&#x27;</span> || <span class=\"built_in\">global</span> === <span class=\"string\">&#x27;Node&#x27;</span>)</span><br><span class=\"line\">              ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> generating multiple handlers per addEventListener invocation, should</span></span><br><span class=\"line\">                <span class=\"comment\">//       revisit and verify we can just use one (almost certainly)</span></span><br><span class=\"line\">                clickHandler = self._breadcrumbEventHandler(<span class=\"string\">&#x27;click&#x27;</span>);</span><br><span class=\"line\">                keypressHandler = self._keypressEventHandler();</span><br><span class=\"line\">                before = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>) </span>&#123; <span class=\"comment\">// 钩子函数，用于在回调函数调用的时候记录信息</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (!evt) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">var</span> eventType;</span><br><span class=\"line\">                  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    eventType = evt.type;</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// just accessing event properties can throw an exception in some rare circumstances</span></span><br><span class=\"line\">                    <span class=\"comment\">// see: https://github.com/getsentry/raven-js/issues/838</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (eventType === <span class=\"string\">&#x27;click&#x27;</span>) <span class=\"keyword\">return</span> clickHandler(evt);</span><br><span class=\"line\">                  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eventType === <span class=\"string\">&#x27;keypress&#x27;</span>) <span class=\"keyword\">return</span> keypressHandler(evt);</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> orig.call(</span><br><span class=\"line\">                <span class=\"built_in\">this</span>,</span><br><span class=\"line\">                evtName,</span><br><span class=\"line\">                self.wrap(</span><br><span class=\"line\">                  &#123;</span><br><span class=\"line\">                    <span class=\"attr\">mechanism</span>: &#123;</span><br><span class=\"line\">                      <span class=\"attr\">type</span>: <span class=\"string\">&#x27;instrument&#x27;</span>,</span><br><span class=\"line\">                      <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">target</span>: <span class=\"built_in\">global</span>,</span><br><span class=\"line\">                        <span class=\"attr\">function</span>: <span class=\"string\">&#x27;addEventListener&#x27;</span>,</span><br><span class=\"line\">                        <span class=\"attr\">handler</span>: (fn &amp;&amp; fn.name) || <span class=\"string\">&#x27;&lt;anonymous&gt;&#x27;</span></span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  fn,</span><br><span class=\"line\">                  before</span><br><span class=\"line\">                ),</span><br><span class=\"line\">                capture,</span><br><span class=\"line\">                secure</span><br><span class=\"line\">              );</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          wrappedBuiltIns</span><br><span class=\"line\">        );</span><br><span class=\"line\">        fill(</span><br><span class=\"line\">          proto,</span><br><span class=\"line\">          <span class=\"string\">&#x27;removeEventListener&#x27;</span>,</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">orig</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt, fn, capture, secure</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                fn = fn &amp;&amp; (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ignore, accessing __raven_wrapper__ will throw in some Selenium environments</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> orig.call(<span class=\"built_in\">this</span>, evt, fn, capture, secure);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          wrappedBuiltIns</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码兼容了通过 handleEvent 的方式进行绑定事件（如果没有听说过这种方式，可以在<a href=\"http://www.ayqy.net/blog/handleevent%E4%B8%8Eaddeventlistener/\">这里</a>补充一些相关的知识）。</p>\n<p>默认情况下，raven.js 只记录通过 <code>EventTarget.addEventListener</code> 绑定的点击和输入信息，实际上这是比较科学的，并且这些信息较为有效。另外，raven.js 也提供了记录所有点击和输入信息的可选项，其实现方式更为简单，直接在 document 上添加相关的监听即可。</p>\n<h3 id=\"raven-js-如何和框架配合使用\"><a href=\"#raven-js-如何和框架配合使用\" class=\"headerlink\" title=\"raven.js 如何和框架配合使用\"></a>raven.js 如何和框架配合使用</h3><p>raven.js 和框架配合使用的方式非常简单，但是我们要知道，很多框架内置了错误边界处理，或者对错误进行转义。以至于我们通过 window.onerror 的方式得不到完整的错误信息。同时，有些框架提供了错误处理的接口（比如 vue），利用错误处理的接口，我们能够获取到和错误有关的更多更重要的信息。</p>\n<p>raven.js 利用各个框架的官方接口，提供了 vue、require.js、angular、ember、react-native 等各个框架的官方插件。</p>\n<p>插件内容本身非常简单，我们可以看一下 vue 插件的代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatComponentName</span>(<span class=\"params\">vm</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vm.<span class=\"variable\">$root</span> === vm) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;root instance&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = vm._isVue ? vm.<span class=\"variable\">$options</span>.name || vm.<span class=\"variable\">$options</span>._componentTag : vm.name;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    (name ? <span class=\"string\">&#x27;component &lt;&#x27;</span> + name + <span class=\"string\">&#x27;&gt;&#x27;</span> : <span class=\"string\">&#x27;anonymous component&#x27;</span>) +</span><br><span class=\"line\">    (vm._isVue &amp;&amp; vm.<span class=\"variable\">$options</span>.__file ? <span class=\"string\">&#x27; at &#x27;</span> + vm.<span class=\"variable\">$options</span>.__file : <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuePlugin</span>(<span class=\"params\">Raven, Vue</span>) </span>&#123;</span><br><span class=\"line\">  Vue = Vue || window.Vue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// quit if Vue isn&#x27;t on the page</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!Vue || !Vue.config) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _oldOnError = Vue.config.errorHandler;</span><br><span class=\"line\">  Vue.config.errorHandler = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">VueErrorHandler</span>(<span class=\"params\"><span class=\"built_in\">error</span>, vm, info</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> metaData = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// vm and lifecycleHook are not always available</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">Object</span>.prototype.toString.call(vm) === <span class=\"string\">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class=\"line\">      metaData.componentName = formatComponentName(vm);</span><br><span class=\"line\">      metaData.propsData = vm.<span class=\"variable\">$options</span>.propsData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeof info !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">      metaData.lifecycleHook = info;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Raven.captureException(<span class=\"built_in\">error</span>, &#123;</span><br><span class=\"line\">      extra: metaData</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeof _oldOnError === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      _oldOnError.call(this, <span class=\"built_in\">error</span>, vm, info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = vuePlugin;</span><br></pre></td></tr></table></figure>\n\n<p>应该不用进行过多解释。</p>\n<p>你也许想知道为什么没有提供 react 插件，事实上，react 16 以后才引入了<a href=\"https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html\">Error Boundaries</a>，这种方式由于灵活性太强，并不太适合使用插件，另外，就算不使用插件，也非常方便地使用 raven.js 进行错误上报，可以参考<a href=\"https://docs.sentry.io/clients/javascript/integrations/react/\">这里</a></p>\n<blockquote>\n<p>但笔者认为，目前 react 的引入方式会对源代码进行侵入，并且比较难通过构建的方式进行 sentry 的配置，也许我们可以寻找更好的方式。</p>\n</blockquote>\n<p>完。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>raven.js 是 sentry 为 JavaScript 错误上报提供的 JS-SDK，本篇我们基于其源代码对其原理进行分析，本篇文章只分析前端部分，对应的文件目录是<code>https://github.com/getsentry/sentry-javascript/tree/master/packages/raven-js</code>。</p>\n<p>首先抛出几个问题：</p>\n<ul>\n<li><strong>raven.js 是如何收集浏览器错误信息的？</strong></li>\n<li><strong>raven.js 上报的错误信息格式是什么样的？又是如何把这些信息传给后端？支不支持合并上报？</strong></li>\n<li><strong>面包屑（breadcrumbs）是什么？raven.js 如何来收集面包屑信息？</strong></li>\n<li><strong>raven.js 如何和框架配合使用（比如 vue、react）？</strong></li>\n</ul>\n<p>在回答以上这几个问题之前，我们首先来对 raven.js 做一个宏观的分析，主要涉及其文件目录、所引用的第三方框架等。</p>\n<p>raven.js 的核心文件内容并不多，其中使用了三个第三方库，放在了 vendor 文件夹下：</p>\n<ul>\n<li><a href=\"https://github.com/moll/json-stringify-safe\">json-stringify-safe</a> ：一个对 <code>JSON.stringify</code> 的封装，安全的 json 序列化操作函数，不会抛出循环引用的错误。<ul>\n<li>这里面有一个注意点要单独说一下，我们熟知的 <code>JSON.stringify</code> , 可以接受三个参数：第一个参数是我们要序列化的对象；第二个参数是对其中键值对的处理函数；第三个参数是控制缩进空格。reven.js 的 <code>json-stringify-safe</code> 就是充分利用了这三个参数。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/blueimp/JavaScript-MD5\">md5</a>：js 的 md5 函数。</li>\n<li><a href=\"https://github.com/csnover/TraceKit\">TraceKit</a>：TraceKit 是一个已经比较完善的错误收集、堆栈格式化的库，reven.js 的功能在很大程度上对它有所依赖。</li>\n</ul>\n<p>除此之外，raven.js 支持插件，官方提供的一些知名库的 sentry 插件主要放在了 plugin 文件夹下面，raven.js 的一些核心文件，则放在了 src 文件夹下面。</p>\n<h3 id=\"raven-js-是如何收集错误信息的？\"><a href=\"#raven-js-是如何收集错误信息的？\" class=\"headerlink\" title=\"raven.js 是如何收集错误信息的？\"></a>raven.js 是如何收集错误信息的？</h3><p>我们知道，在前端收集错误，肯定离不开 <code>window.onerror</code> 这个函数，那么我们就从这个函数说起。</p>\n<p>实际上，这部分工作是 raven.js 引用的第三方库 TraceKit 完成的：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> install<span class=\"constructor\">GlobalHandler()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_onErrorHandlerInstalled) &#123; <span class=\"comment\">// 一个起到标志作用的全局变量</span></span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _oldOnerrorHandler = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_window</span>.</span></span>onerror; </span><br><span class=\"line\">  <span class=\"comment\">// _oldOnerrorHandler 是防止对用户其他地方定义的回调函数进行覆盖</span></span><br><span class=\"line\">  <span class=\"comment\">// 该 _window 经过兼容，实际上就是 window</span></span><br><span class=\"line\">  <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_window</span>.</span></span>onerror = traceKitWindowOnError;</span><br><span class=\"line\">  _onErrorHandlerInstalled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相关错误回调函数交给 traceKitWindowOnError 处理，下面我们来看一下 traceKitWindowOnError 函数，为了避免太多冗余代码，我们仅分析一种主要情况：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> trace<span class=\"constructor\">KitWindowOnError(<span class=\"params\">msg</span>, <span class=\"params\">url</span>, <span class=\"params\">lineNo</span>, <span class=\"params\">colNo</span>, <span class=\"params\">ex</span>)</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvar <span class=\"keyword\">exception</span> = utils.is<span class=\"constructor\">ErrorEvent(<span class=\"params\">ex</span>)</span> ? ex.error : ex;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    stack = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">TraceKit</span>.</span></span>compute<span class=\"constructor\">StackTrace(<span class=\"params\">exception</span>)</span>;</span><br><span class=\"line\">    notify<span class=\"constructor\">Handlers(<span class=\"params\">stack</span>, <span class=\"params\">true</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_oldOnerrorHandler) &#123;</span><br><span class=\"line\">       return <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">_oldOnerrorHandler</span>.</span></span>apply(this, arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中调用的最重要的一个函数，就是 computeStackTrace，而这个函数也是 TraceKit 的核心函数，简单来讲，它做的事情就是统一格式化报错信息调用栈，因为对于各个浏览器来说，返回的 Error 调用栈信息格式不尽相同，另外甚至还有的浏览器并不返回调用栈，computeStackTrace 函数对这些情况都做了兼容性处理，并且对于一些不返回调用栈的情况，还使用了 caller 来向上回溯函数的调用栈，最终把报错信息转化成一个键相同的对象数组，做到了报错信息格式的统一。</p>\n<p>notifyHandlers 函数则是通知相关的回调函数。 实际上，raven.js 在 install 函数中会调用 TraceKit.report.subscribe 函数，并把对错误的处理逻辑写入回调：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(handler) &#123;</span><br><span class=\"line\">    installGlobalHandler();</span><br><span class=\"line\">    handlers.push(handler);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上过程完成了错误处理过程中的负责角色转换，并且借助 TraceKit，可以使 raven.js 得到一个结构比较清晰的带有格式化好的调用栈信息的错误内容对象，之后，raven.js 对错误内容进一步处理并最终上报。</p>\n<p>下面我们对错误处理 raven.js 控制的部分做了一些梳理：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"attribute\">_handleOnErrorStackInfo</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">stackInfo, options</span>) </span>&#123;</span><br><span class=\"line\">    options.mechanism = options.mechanism || &#123;</span><br><span class=\"line\">      <span class=\"attribute\">type</span>: <span class=\"string\">&#x27;onerror&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attribute\">handled</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// mechanism 和错误统计来源有关</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>._ignoreOnError) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._handleStackInfo(stackInfo, options);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">_handleStackInfo</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">stackInfo, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> frames = <span class=\"keyword\">this</span>._prepareFrames(stackInfo, options);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._triggerEvent(<span class=\"string\">&#x27;handle&#x27;</span>, &#123;</span><br><span class=\"line\">      <span class=\"attribute\">stackInfo</span>: stackInfo,</span><br><span class=\"line\">      <span class=\"attribute\">options</span>: options</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._processException(</span><br><span class=\"line\">      stackInfo.name,</span><br><span class=\"line\">      stackInfo.message,</span><br><span class=\"line\">      stackInfo.url,</span><br><span class=\"line\">      stackInfo.lineno,</span><br><span class=\"line\">      frames,</span><br><span class=\"line\">      options</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">_processException</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, message, fileurl, lineno, frames, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先根据 message 信息判断是否是需要忽略的错误类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后判断出错的文件是否在黑名单中或者白名单中</span></span><br><span class=\"line\">    <span class=\"comment\">// 接下来对错误内容进行必要的整合与转换，构造出 data 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后调用上报函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._send(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">_send</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 对 data 进一步处理，增加必要的信息，包括后续会提到的面包屑信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 交由 _sendProcessedPayload 进行进一步处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>._sendProcessedPayload(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">_sendProcessedPayload</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, callback</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 对 data 增加一些必要的元信息</span></span><br><span class=\"line\">\t<span class=\"comment\">// 可以通过自定义 globalOptions.transport 的方式来自定义上报函数 </span></span><br><span class=\"line\">\t(globalOptions.transport || <span class=\"keyword\">this</span>._makeRequest).call(<span class=\"keyword\">this</span>, &#123;</span><br><span class=\"line\">\t     <span class=\"attribute\">url</span>: <span class=\"built_in\">url</span>,</span><br><span class=\"line\">\t     <span class=\"attribute\">auth</span>: auth,</span><br><span class=\"line\">\t     <span class=\"attribute\">data</span>: data,</span><br><span class=\"line\">\t     <span class=\"attribute\">options</span>: globalOptions,</span><br><span class=\"line\">\t     <span class=\"attribute\">onSuccess</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">success</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t       </span><br><span class=\"line\">\t     &#125;,</span><br><span class=\"line\">\t     <span class=\"attribute\">onError</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">failure</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">\t       </span><br><span class=\"line\">\t     &#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 真正发起请求的函数</span></span><br><span class=\"line\"><span class=\"attribute\">_makeRequest</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 对于支持 fetch 的浏览器，直接使用 fetch 的方式发送 POST 请求</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果浏览器不支持 fetch，则使用 XHR 的传统方式发送 POST 请求</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上我们可以发现，从拿到已经初步格式化的报错信息，到最终真正执行数据上报，raven.js 的过程非常漫长，这其中我分析有如下几个原因：</p>\n<ul>\n<li>每个函数只处理一件或者一些事情，保持函数的短小整洁。</li>\n<li>部分函数可以做到复用（因为除了自动捕获错误的方式， raven.js 还提供通过 captureException，即 <code>try &#123;   doSomething(a[0]) &#125; catch(e) &#123;   Raven.captureException(e) &#125;</code> 的方式来上报错误，两个过程中有一些函数的调用是有重叠的）。</li>\n</ul>\n<p>但是笔者认为，raven.js 的代码设计还有很多值得优化的地方，比如：</p>\n<ul>\n<li>对最终上报数据（data）的属性处理和增加分散在多个函数，并且有较多可选项目，很难梳理出一个完整的 data 格式，并且不便于维护。</li>\n<li>部分函数的拆分必要性不足，并且会增加链路的复杂性，比如 <code>_processException </code>、<code>_sendProcessedPayload </code>、<code>_makeRequest </code>等都只在一个链路中被调用一次。</li>\n<li>部分属性重命名会造成资源浪费，由于 TraceKit 部分最终返回的数据格式并不完全满足 raven.js 的需要，所以 raven.js 之后又在较后阶段进行了重命名等处理，实际上这些内容完全可以通过一些其他的方式避免。</li>\n</ul>\n<p>最后，非常遗憾，sentry 目前完全不支持合并上报，就算是在同一个事件循环（甚至事件循环的同一个阶段，关于事件循环，可以参考我之前绘制的<a href=\"https://www.processon.com/view/link/5b6ec8cbe4b053a09c2fb977\">一张图</a>）的两个错误，sentry 都是分开来上报的，这里有一个简单例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Raven.config(<span class=\"string\">&#x27;http://8ec3f1a9f652463bb58191bd0b35f20c@localhost:9000/2&#x27;</span>).install()</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">window</span>.ss;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = s.b</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    Raven.captureException(e)</span><br><span class=\"line\">    <span class=\"comment\">// sentry should report error now</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">s.nomethod();</span><br><span class=\"line\"><span class=\"comment\">// sentry should report error now</span></span><br></pre></td></tr></table></figure>\n\n<p>以上例子中，sentry 会发送两个 POST 请求。</p>\n<h3 id=\"raven-js-最终上报数据的格式\"><a href=\"#raven-js-最终上报数据的格式\" class=\"headerlink\" title=\"raven.js 最终上报数据的格式\"></a>raven.js 最终上报数据的格式</h3><p>这一部分，我们并不会详细地分析 raven.js 上报的数据的每一项内容，仅会给读者展示一个比较典型的情况。</p>\n<p>我们看一下对于一个一般的 js 错误，raven.js 上报的 json 中包含哪些内容，下面是一个已经删掉一些冗余内容的典型上报信息：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;project&quot;</span>: <span class=\"string\">&quot;2&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;logger&quot;</span>: <span class=\"string\">&quot;javascript&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;platform&quot;</span>: <span class=\"string\">&quot;javascript&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;request&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;headers&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;User-Agent&quot;</span>: <span class=\"string\">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">&quot;url&quot;</span>: <span class=\"string\">&quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;exception&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;values&quot;</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;TypeError&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span>: <span class=\"string\">&quot;Cannot read property &#x27;b&#x27; of undefined&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;stacktrace&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">&quot;frames&quot;</span>: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"attr\">&quot;filename&quot;</span>: <span class=\"string\">&quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;</span>,</span><br><span class=\"line\">              <span class=\"attr\">&quot;lineno&quot;</span>: <span class=\"number\">19</span>,</span><br><span class=\"line\">              <span class=\"attr\">&quot;colno&quot;</span>: <span class=\"number\">19</span>,</span><br><span class=\"line\">              <span class=\"attr\">&quot;function&quot;</span>: <span class=\"string\">&quot;?&quot;</span>,</span><br><span class=\"line\">              <span class=\"attr\">&quot;in_app&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">&quot;mechanism&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;generic&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;handled&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;transaction&quot;</span>: <span class=\"string\">&quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;extra&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;session:duration&quot;</span>: <span class=\"number\">6</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;breadcrumbs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;values&quot;</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;timestamp&quot;</span>: <span class=\"number\">1534257309.996</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;message&quot;</span>: <span class=\"string\">&quot;_prepareFrames stackInfo: [object Object]&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;level&quot;</span>: <span class=\"string\">&quot;log&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;category&quot;</span>: <span class=\"string\">&quot;console&quot;</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">   ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;event_id&quot;</span>: <span class=\"string\">&quot;ea0334adaf9d43b78e72da2b10e084a9&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;trimHeadFrames&quot;</span>: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中支持的信息类型重点分为以下几种：</p>\n<ul>\n<li>sentry 基本配置信息，包括库本身的配置和使用者的配置信息，以及用户的一些自定义信息</li>\n<li>错误信息，主要包括错误调用栈信息</li>\n<li>request 信息，主要包括浏览器的 User-Agent、当前请求地址等</li>\n<li>面包屑信息，关于面包屑具体指的是什么，我们会在下一环节进行介绍</li>\n</ul>\n<h3 id=\"raven-js-面包屑收集\"><a href=\"#raven-js-面包屑收集\" class=\"headerlink\" title=\"raven.js 面包屑收集\"></a>raven.js 面包屑收集</h3><p>面包屑信息，也就是错误在发生之前，一些用户、浏览器的行为信息，raven.js 实现了一个简单的队列（有一个最大条目长度，默认为 100），这个队列在时刻记录着这些信息，一旦错误发生并且需要上报，raven.js 就把这个队列的信息内容，作为面包屑 breadcrumbs，发回客户端。</p>\n<p>面包屑信息主要包括这几类：</p>\n<ul>\n<li>用户对某个元素的点击或者用户对某个可输入元素的输入</li>\n<li>发送的 http 请求</li>\n<li>console 打印的信息（支持配置 ‘debug’, ‘info’, ‘warn’, ‘error’, ‘log’ 等不同级别）</li>\n<li>window.location 变化信息</li>\n</ul>\n<p>接下来，我们对这几类面包屑信息 sentry 的记录实现进行简单的分析。</p>\n<p>实际上，sentry 对这些信息记录的方式比较一致，都是通过对原声的函数进行包装，并且在包装好的函数中增加自己的钩子函数，来实现触发时候的事件记录，实际上，sentry 总共包装的函数有：</p>\n<ul>\n<li>window.setTimeout</li>\n<li>window.setInterval</li>\n<li>window.requestAnimationFrame</li>\n<li>EventTarget.addEventListener</li>\n<li>EventTarget.removeEventListener</li>\n<li>XMLHTTPRequest.open</li>\n<li>XMLHTTPRequest.send</li>\n<li>window.fetch</li>\n<li>History.pushState</li>\n<li>History.replaceState</li>\n</ul>\n<blockquote>\n<p>备注：这里包装的所有函数，其中有一部分只是使 raven.js 具有捕获回调函数中错误的能力（对回调函数进行包装）</p>\n</blockquote>\n<p>接下来我们看一段典型的代码，来分析 raven.js 是如何记录用户的点击和输入信息的（通过对 EventTarget.addEventListener 进行封装）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapEventTarget</span>(<span class=\"params\"><span class=\"built_in\">global</span></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> proto = _window[<span class=\"built_in\">global</span>] &amp;&amp; _window[<span class=\"built_in\">global</span>].prototype;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (proto &amp;&amp; proto.hasOwnProperty &amp;&amp; proto.hasOwnProperty(<span class=\"string\">&#x27;addEventListener&#x27;</span>)) &#123;</span><br><span class=\"line\">        fill(</span><br><span class=\"line\">          proto,</span><br><span class=\"line\">          <span class=\"string\">&#x27;addEventListener&#x27;</span>,</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">orig</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evtName, fn, capture, secure</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fn &amp;&amp; fn.handleEvent) &#123; <span class=\"comment\">//兼容通过 handleEvent 的方式进行绑定事件</span></span><br><span class=\"line\">                  fn.handleEvent = self.wrap(</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                      <span class=\"attr\">mechanism</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">type</span>: <span class=\"string\">&#x27;instrument&#x27;</span>,</span><br><span class=\"line\">                        <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">                          <span class=\"attr\">target</span>: <span class=\"built_in\">global</span>,</span><br><span class=\"line\">                          <span class=\"attr\">function</span>: <span class=\"string\">&#x27;handleEvent&#x27;</span>,</span><br><span class=\"line\">                          <span class=\"attr\">handler</span>: (fn &amp;&amp; fn.name) || <span class=\"string\">&#x27;&lt;anonymous&gt;&#x27;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    fn.handleEvent</span><br><span class=\"line\">                  );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">var</span> before, clickHandler, keypressHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                autoBreadcrumbs &amp;&amp;</span><br><span class=\"line\">                autoBreadcrumbs.dom &amp;&amp;</span><br><span class=\"line\">                (<span class=\"built_in\">global</span> === <span class=\"string\">&#x27;EventTarget&#x27;</span> || <span class=\"built_in\">global</span> === <span class=\"string\">&#x27;Node&#x27;</span>)</span><br><span class=\"line\">              ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> generating multiple handlers per addEventListener invocation, should</span></span><br><span class=\"line\">                <span class=\"comment\">//       revisit and verify we can just use one (almost certainly)</span></span><br><span class=\"line\">                clickHandler = self._breadcrumbEventHandler(<span class=\"string\">&#x27;click&#x27;</span>);</span><br><span class=\"line\">                keypressHandler = self._keypressEventHandler();</span><br><span class=\"line\">                before = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>) </span>&#123; <span class=\"comment\">// 钩子函数，用于在回调函数调用的时候记录信息</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (!evt) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">var</span> eventType;</span><br><span class=\"line\">                  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    eventType = evt.type;</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// just accessing event properties can throw an exception in some rare circumstances</span></span><br><span class=\"line\">                    <span class=\"comment\">// see: https://github.com/getsentry/raven-js/issues/838</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (eventType === <span class=\"string\">&#x27;click&#x27;</span>) <span class=\"keyword\">return</span> clickHandler(evt);</span><br><span class=\"line\">                  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eventType === <span class=\"string\">&#x27;keypress&#x27;</span>) <span class=\"keyword\">return</span> keypressHandler(evt);</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> orig.call(</span><br><span class=\"line\">                <span class=\"built_in\">this</span>,</span><br><span class=\"line\">                evtName,</span><br><span class=\"line\">                self.wrap(</span><br><span class=\"line\">                  &#123;</span><br><span class=\"line\">                    <span class=\"attr\">mechanism</span>: &#123;</span><br><span class=\"line\">                      <span class=\"attr\">type</span>: <span class=\"string\">&#x27;instrument&#x27;</span>,</span><br><span class=\"line\">                      <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">target</span>: <span class=\"built_in\">global</span>,</span><br><span class=\"line\">                        <span class=\"attr\">function</span>: <span class=\"string\">&#x27;addEventListener&#x27;</span>,</span><br><span class=\"line\">                        <span class=\"attr\">handler</span>: (fn &amp;&amp; fn.name) || <span class=\"string\">&#x27;&lt;anonymous&gt;&#x27;</span></span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  fn,</span><br><span class=\"line\">                  before</span><br><span class=\"line\">                ),</span><br><span class=\"line\">                capture,</span><br><span class=\"line\">                secure</span><br><span class=\"line\">              );</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          wrappedBuiltIns</span><br><span class=\"line\">        );</span><br><span class=\"line\">        fill(</span><br><span class=\"line\">          proto,</span><br><span class=\"line\">          <span class=\"string\">&#x27;removeEventListener&#x27;</span>,</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">orig</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt, fn, capture, secure</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                fn = fn &amp;&amp; (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ignore, accessing __raven_wrapper__ will throw in some Selenium environments</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> orig.call(<span class=\"built_in\">this</span>, evt, fn, capture, secure);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          wrappedBuiltIns</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码兼容了通过 handleEvent 的方式进行绑定事件（如果没有听说过这种方式，可以在<a href=\"http://www.ayqy.net/blog/handleevent%E4%B8%8Eaddeventlistener/\">这里</a>补充一些相关的知识）。</p>\n<p>默认情况下，raven.js 只记录通过 <code>EventTarget.addEventListener</code> 绑定的点击和输入信息，实际上这是比较科学的，并且这些信息较为有效。另外，raven.js 也提供了记录所有点击和输入信息的可选项，其实现方式更为简单，直接在 document 上添加相关的监听即可。</p>\n<h3 id=\"raven-js-如何和框架配合使用\"><a href=\"#raven-js-如何和框架配合使用\" class=\"headerlink\" title=\"raven.js 如何和框架配合使用\"></a>raven.js 如何和框架配合使用</h3><p>raven.js 和框架配合使用的方式非常简单，但是我们要知道，很多框架内置了错误边界处理，或者对错误进行转义。以至于我们通过 window.onerror 的方式得不到完整的错误信息。同时，有些框架提供了错误处理的接口（比如 vue），利用错误处理的接口，我们能够获取到和错误有关的更多更重要的信息。</p>\n<p>raven.js 利用各个框架的官方接口，提供了 vue、require.js、angular、ember、react-native 等各个框架的官方插件。</p>\n<p>插件内容本身非常简单，我们可以看一下 vue 插件的代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatComponentName</span>(<span class=\"params\">vm</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vm.<span class=\"variable\">$root</span> === vm) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;root instance&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = vm._isVue ? vm.<span class=\"variable\">$options</span>.name || vm.<span class=\"variable\">$options</span>._componentTag : vm.name;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    (name ? <span class=\"string\">&#x27;component &lt;&#x27;</span> + name + <span class=\"string\">&#x27;&gt;&#x27;</span> : <span class=\"string\">&#x27;anonymous component&#x27;</span>) +</span><br><span class=\"line\">    (vm._isVue &amp;&amp; vm.<span class=\"variable\">$options</span>.__file ? <span class=\"string\">&#x27; at &#x27;</span> + vm.<span class=\"variable\">$options</span>.__file : <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuePlugin</span>(<span class=\"params\">Raven, Vue</span>) </span>&#123;</span><br><span class=\"line\">  Vue = Vue || window.Vue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// quit if Vue isn&#x27;t on the page</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!Vue || !Vue.config) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _oldOnError = Vue.config.errorHandler;</span><br><span class=\"line\">  Vue.config.errorHandler = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">VueErrorHandler</span>(<span class=\"params\"><span class=\"built_in\">error</span>, vm, info</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> metaData = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// vm and lifecycleHook are not always available</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">Object</span>.prototype.toString.call(vm) === <span class=\"string\">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class=\"line\">      metaData.componentName = formatComponentName(vm);</span><br><span class=\"line\">      metaData.propsData = vm.<span class=\"variable\">$options</span>.propsData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeof info !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">      metaData.lifecycleHook = info;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Raven.captureException(<span class=\"built_in\">error</span>, &#123;</span><br><span class=\"line\">      extra: metaData</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeof _oldOnError === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      _oldOnError.call(this, <span class=\"built_in\">error</span>, vm, info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = vuePlugin;</span><br></pre></td></tr></table></figure>\n\n<p>应该不用进行过多解释。</p>\n<p>你也许想知道为什么没有提供 react 插件，事实上，react 16 以后才引入了<a href=\"https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html\">Error Boundaries</a>，这种方式由于灵活性太强，并不太适合使用插件，另外，就算不使用插件，也非常方便地使用 raven.js 进行错误上报，可以参考<a href=\"https://docs.sentry.io/clients/javascript/integrations/react/\">这里</a></p>\n<blockquote>\n<p>但笔者认为，目前 react 的引入方式会对源代码进行侵入，并且比较难通过构建的方式进行 sentry 的配置，也许我们可以寻找更好的方式。</p>\n</blockquote>\n<p>完。</p>\n"},{"title":"浅谈前端中的二进制数据类型","abbrlink":1131173294,"date":"2018-05-09T02:28:42.000Z","_content":"\n>目前在一个项目中，WebSocket部分由于后端使用了gzip压缩，前端处理起来废了一点时间，从而发现自己在二进制数据类型这个知识点还存在一定的盲区，因此这里进行总结。\n\n本文主要简单介绍ArrayBuffer对象、TypedArray对象、DataView对象以及Blob原始数据类型，和它们之间的互相转换方法。部分代码参考[这里](http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc4)而非本人原创，仅做个人学习使用。\n\n这些类型化对象，一般会在以下场景中使用：\n\n* WebGL 中，浏览器和显卡之间需要使用二进制数据进行通信。\n* 在一些 Rest 接口或者 WebSocket 中，采用压缩过的数据进行通信，这个压缩和解压缩的过程可能需要借助二进制对象。\n* 在 Canvas 中，我们可能需要通过生成 Blob 的方式保存当前内容。\n* 在 Img 等资源文件中，URL 可以为 Blob 原始数据类型。\n* 在读取用户上传文件时，可能需要用到二进制数据类型进行中间转换。\n\n下文分两部分，前一部分概述各个二进制数据类型，后一部分将它们之间的互相转换。\n\n### 二进制数据类型概述\n\n#### ArrayBuffer\n\nArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。\n\nArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。\n\n```\nvar buf = new ArrayBuffer(32);\n```\n\n上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。\n\n为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。\n\n```\nvar buf = new ArrayBuffer(32);\nvar dataView = new DataView(buf);\ndataView.getUint8(0) // 0\n```\n\n上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。\n\n另外，我们可以将ArrayBuffer生成的结果，传入TypedArray中：\n\n```\nvar buffer = new ArrayBuffer(12);\n\nvar x1 = new Int32Array(buffer);\nx1[0] = 1;\nvar x2 = new Uint8Array(buffer);\nx2[0]  = 2;\n\nx1[0] // 2\n```\n\nArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。\n\n```\nvar buffer = new ArrayBuffer(32);\nbuffer.byteLength\n// 32\n```\n如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。\n\n```\nif (buffer.byteLength === n) {\n  // 成功\n} else {\n  // 失败\n}\n```\n\nArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。\n\n```\nvar buffer = new ArrayBuffer(8);\nvar newBuffer = buffer.slice(0, 3);\n```\n\n上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。\n\nslice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。\n\n除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。\n\nArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。\n\n```\nvar buffer = new ArrayBuffer(8);\nArrayBuffer.isView(buffer) // false\n\nvar v = new Int32Array(buffer);\nArrayBuffer.isView(v) // true\n```\n\n#### TypedArray\n\n目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。\n\n* Int8Array：8位有符号整数，长度1个字节。\n* Uint8Array：8位无符号整数，长度1个字节。\n* Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。\n* Int16Array：16位有符号整数，长度2个字节。\n* Uint16Array：16位无符号整数，长度2个字节。\n* Int32Array：32位有符号整数，长度4个字节。\n* Uint32Array：32位无符号整数，长度4个字节。\n* Float32Array：32位浮点数，长度4个字节。\n* Float64Array：64位浮点数，长度8个字节。\n\n这9个构造函数生成的对象，统称为TypedArray对象。它们很像正常数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在类型化数组上面都能使用。两者的差异主要在以下方面。\n\n* TypedArray数组的所有成员，都是同一种类型和格式。\n* TypedArray数组的成员是连续的，不会有空位。\n* Typed化数组成员的默认值为0。比如，new Array(10)返回一个正常数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个类型化数组，里面10个成员都是0。\n* TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。\n\n##### 构造函数\n\nTypedArray数组提供9种构造函数，用来生成相应类型的数组实例。\n\n构造函数有多种用法。\n\n* TypedArray(buffer, byteOffset=0, length?)\n\n同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。\n\n```\n// 创建一个8字节的ArrayBuffer\nvar b = new ArrayBuffer(8);\n\n// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾\nvar v1 = new Int32Array(b);\n\n// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾\nvar v2 = new Uint8Array(b, 2);\n\n// 创建一个指向b的Int16视图，开始于字节2，长度为2\nvar v3 = new Int16Array(b, 2, 2);\n```\n\n对于以上代码，v1、v2和v3是重叠的：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。\n\n注意，byteOffset必须与所要建立的数据类型一致，否则会报错。\n\n```\nvar buffer = new ArrayBuffer(8);\nvar i16 = new Int16Array(buffer, 1);\n// Uncaught RangeError: start offset of Int16Array should be a multiple of 2\n```\n\n上面代码中，新生成一个8个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的16位整数视图，结果报错。因为，带符号的16位整数需要两个字节，所以byteOffset参数必须能够被2整除。\n\n如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式。\n\n* TypedArray(length)\n\n视图还可以不通过ArrayBuffer对象，直接分配内存而生成。\n\n```\nvar f64a = new Float64Array(8);\nf64a[0] = 10;\nf64a[1] = 20;\nf64a[2] = f64a[0] + f64a[1];\n```\n\n* TypedArray(typedArray)\n\n类型化数组的构造函数，可以接受另一个视图实例作为参数。\n\n```\nvar typedArray = new Int8Array(new Uint8Array(4));\n```\n\n上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。\n\n注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。\n\n```\nvar x = new Int8Array([1, 1]);\nvar y = new Int8Array(x);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 1\n```\n\n上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。\n\n如果想基于同一段内存，构造不同的视图，可以采用下面的写法。\n\n```\nvar x = new Int8Array([1, 1]);\nvar y = new Int8Array(x.buffer);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 2\n```\n\n* TypedArray(arrayLikeObject)\n\n构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。\n\n```\nvar typedArray = new Uint8Array([1, 2, 3, 4]);\n```\n\n注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。\n\n上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。\n\nTypedArray数组也可以转换回普通数组。\n\n```\nvar normalArray = Array.prototype.slice.call(typedArray);\n```\n\n##### BYTES_PER_ELEMENT属性\n\n每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。\n\n```\nInt8Array.BYTES_PER_ELEMENT // 1\nUint8Array.BYTES_PER_ELEMENT // 1\nInt16Array.BYTES_PER_ELEMENT // 2\nUint16Array.BYTES_PER_ELEMENT // 2\nInt32Array.BYTES_PER_ELEMENT // 4\nUint32Array.BYTES_PER_ELEMENT // 4\nFloat32Array.BYTES_PER_ELEMENT // 4\nFloat64Array.BYTES_PER_ELEMENT // 8\n```\n\n##### ArrayBuffer与字符串的互相转换\n\nArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。\n\n```\n// ArrayBuffer转为字符串，参数为ArrayBuffer对象\nfunction ab2str(buf) {\n  return String.fromCharCode.apply(null, new Uint16Array(buf));\n}\n\n// 字符串转为ArrayBuffer对象，参数为字符串\nfunction str2ab(str) {\n  var buf = new ArrayBuffer(str.length * 2); // 每个字符占用2个字节\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n```\n\n##### TypedArray.prototype.set()\n\nTypedArray数组的set方法用于复制数组（正常数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。\n\n```\nvar a = new Uint8Array(8);\nvar b = new Uint8Array(8);\n\nb.set(a);\n```\n\n上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。\n\n```\nvar a = new Uint16Array(8);\nvar b = new Uint16Array(10);\n\nb.set(a, 2)\n```\n上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。\n\n##### TypedArray.prototype.subarray()\n\nsubarray方法是对于TypedArray数组的一部分，再建立一个新的视图。\n\n```\nvar a = new Uint16Array(8);\nvar b = a.subarray(2,3);\n\na.byteLength // 16\nb.byteLength // 2\n```\n\nsubarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。\n\n##### TypedArray.prototype.slice()\n\nTypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。\n\n```\nlet ui8 = Uint8Array.of(0, 1, 2);\nui8.slice(-1)\n// Uint8Array [ 2 ]\n```\n\n\n上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。\n\nslice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。\n\n##### TypedArray.of()\n\nTypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。\n\n```\nFloat32Array.of(0.151, -8, 3.7)\n// Float32Array [ 0.151, -8, 3.7 ]\n```\n\n##### TypedArray.from()\n\n静态方法from接受一个**可遍历的数据结构（比如数组）**作为参数，返回一个基于这个结构的TypedArray实例。\n\n```\nUint16Array.from([0, 1, 2])\n// Uint16Array [ 0, 1, 2 ]\n```\n\n这个方法还可以将一种TypedArray实例，转为另一种。\n\n```\nvar ui16 = Uint16Array.from(Uint8Array.of(0, 1, 2));\nui16 instanceof Uint16Array // true\n```\n\nfrom方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。\n\n```\nInt8Array.of(127, 126, 125).map(x => 2 * x)\n// Int8Array [ -2, -4, -6 ]\n\nInt16Array.from(Int8Array.of(127, 126, 125), x => 2 * x)\n// Int16Array [ 254, 252, 250 ]\n```\n\n上面的例子中，from方法没有发生溢出，这说明遍历是针对新生成的16位整数数组，而不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中（占用内存从3字节变为6字节），然后再进行处理。\n\n#### DataView\n\n如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。\n\nDataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。\n\nDataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。\n\n```\nDataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);\n```\n下面是一个例子。\n\n```\nvar buffer = new ArrayBuffer(24);\nvar dv = new DataView(buffer);\n```\n\nDataView实例有以下属性，含义与TypedArray实例的同名方法相同。\n\n* DataView.prototype.buffer：返回对应的ArrayBuffer对象\n* DataView.prototype.byteLength：返回占据的内存字节长度\n* DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始\n\nDataView实例提供8个方法读取内存。\n\n* getInt8：读取1个字节，返回一个8位整数。\n* getUint8：读取1个字节，返回一个无符号的8位整数。\n* getInt16：读取2个字节，返回一个16位整数。\n* getUint16：读取2个字节，返回一个无符号的16位整数。\n* getInt32：读取4个字节，返回一个32位整数。\n* getUint32：读取4个字节，返回一个无符号的32位整数。\n* getFloat32：读取4个字节，返回一个32位浮点数。\n* getFloat64：读取8个字节，返回一个64位浮点数。\n\n这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。\n\n```\nvar buffer = new ArrayBuffer(24);\nvar dv = new DataView(buffer);\n\n// 从第1个字节读取一个8位无符号整数\nvar v1 = dv.getUint8(0);\n\n// 从第2个字节读取一个16位无符号整数\nvar v2 = dv.getUint16(1);\n\n// 从第4个字节读取一个16位无符号整数\nvar v3 = dv.getUint16(3);\n```\n\n上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。\n\n如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。\n\n```\n// 小端字节序\nvar v1 = dv.getUint16(1, true);\n\n// 大端字节序\nvar v2 = dv.getUint16(3, false);\n\n// 大端字节序\nvar v3 = dv.getUint16(3);\n```\n\nDataView视图提供8个方法写入内存。\n\n* setInt8：写入1个字节的8位整数。\n* setUint8：写入1个字节的8位无符号整数。\n* setInt16：写入2个字节的16位整数。\n* setUint16：写入2个字节的16位无符号整数。\n* setInt32：写入4个字节的32位整数。\n* setUint32：写入4个字节的32位无符号整数。\n* setFloat32：写入4个字节的32位浮点数。\n* setFloat64：写入8个字节的64位浮点数。\n\n这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。\n\n```\n// 在第1个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(0, 25, false);\n\n// 在第5个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(4, 25);\n\n// 在第9个字节，以小端字节序写入值为2.5的32位浮点数\ndv.setFloat32(8, 2.5, true);\n```\n\n如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。\n\n```\nvar littleEndian = (function() {\n  var buffer = new ArrayBuffer(2);\n  new DataView(buffer).setInt16(0, 256, true);\n  return new Int16Array(buffer)[0] === 256;\n})();\n```\n\n#### Blob\n\nBlob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。\n\n要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，请参阅 File文档。\n\n从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：\n\n```\nvar reader = new FileReader();\nreader.addEventListener(\"loadend\", function() {\n   // reader.result 包含转化为类型数组的blob\n});\nreader.readAsArrayBuffer(blob);\n```\n\n更多关于Blob的内容，请直接查看[这里](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)\n\n### 数据格式转换\n\n#### String转Blob\n\n```\n//将字符串 转换成 Blob 对象\nvar blob = new Blob([\"Hello World!\"], {\n    type: 'text/plain'\n});\nconsole.info(blob);\nconsole.info(blob.slice(1, 3, 'text/plain'));\n```\n#### TypeArray转Blob\n\n```\n//将 TypeArray  转换成 Blob 对象\nvar array = new Uint16Array([97, 32, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33]);\n//测试成功\n//var blob = new Blob([array], { type: \"application/octet-binary\" });\n//测试成功， 注意必须[]的包裹\nvar blob = new Blob([array]);\n//将 Blob对象 读成字符串\nvar reader = new FileReader();\nreader.readAsText(blob, 'utf-8');\nreader.onload = function (e) {\n    console.info(reader.result); //a Hello world!\n}\n```\n\n#### ArrayBuffer转Blob\n\n```\nvar buffer = new ArrayBuffer(32);\nvar blob = new Blob([buffer]);       // 注意必须包裹[]\n```\n\n#### Blob转String\n\n这里需要注意的是readAsText方法的使用。\n\n```\n//将字符串转换成 Blob对象\nvar blob = new Blob(['中文字符串'], {\n    type: 'text/plain'\n});\n//将Blob 对象转换成字符串\nvar reader = new FileReader();\nreader.readAsText(blob, 'utf-8');\nreader.onload = function (e) {\n    console.info(reader.result);\n}\n```\n\n#### Blob转ArrayBuffer\n\n这里需要注意的是readAsArrayBuffer方法的使用。\n\n```\n//将字符串转换成 Blob对象\nvar blob = new Blob(['中文字符串'], {\n    type: 'text/plain'\n});\n//将Blob 对象转换成 ArrayBuffer\nvar reader = new FileReader();\nreader.readAsArrayBuffer(blob);\nreader.onload = function (e) {\n    console.info(reader.result); //ArrayBuffer {}\n    //经常会遇到的异常 Uncaught RangeError: byte length of Int16Array should be a multiple of 2\n    //var buf = new int16array(reader.result);\n    //console.info(buf);\n\n    //将 ArrayBufferView  转换成Blob\n    var buf = new Uint8Array(reader.result);\n    console.info(buf); //[228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]\n    reader.readAsText(new Blob([buf]), 'utf-8');\n    reader.onload = function () {\n        console.info(reader.result); //中文字符串\n    };\n\n    //将 ArrayBufferView  转换成Blob\n    var buf = new DataView(reader.result);\n    console.info(buf); //DataView {}\n    reader.readAsText(new Blob([buf]), 'utf-8');\n    reader.onload = function () {\n        console.info(reader.result); //中文字符串\n    };\n}\n```\n\n","source":"_posts/浅谈前端中的二进制数据类型.md","raw":"---\ntitle: 浅谈前端中的二进制数据类型\ntags:\n  - javascript\nabbrlink: 1131173294\ndate: 2018-05-09 10:28:42\n---\n\n>目前在一个项目中，WebSocket部分由于后端使用了gzip压缩，前端处理起来废了一点时间，从而发现自己在二进制数据类型这个知识点还存在一定的盲区，因此这里进行总结。\n\n本文主要简单介绍ArrayBuffer对象、TypedArray对象、DataView对象以及Blob原始数据类型，和它们之间的互相转换方法。部分代码参考[这里](http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc4)而非本人原创，仅做个人学习使用。\n\n这些类型化对象，一般会在以下场景中使用：\n\n* WebGL 中，浏览器和显卡之间需要使用二进制数据进行通信。\n* 在一些 Rest 接口或者 WebSocket 中，采用压缩过的数据进行通信，这个压缩和解压缩的过程可能需要借助二进制对象。\n* 在 Canvas 中，我们可能需要通过生成 Blob 的方式保存当前内容。\n* 在 Img 等资源文件中，URL 可以为 Blob 原始数据类型。\n* 在读取用户上传文件时，可能需要用到二进制数据类型进行中间转换。\n\n下文分两部分，前一部分概述各个二进制数据类型，后一部分将它们之间的互相转换。\n\n### 二进制数据类型概述\n\n#### ArrayBuffer\n\nArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。\n\nArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。\n\n```\nvar buf = new ArrayBuffer(32);\n```\n\n上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。\n\n为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。\n\n```\nvar buf = new ArrayBuffer(32);\nvar dataView = new DataView(buf);\ndataView.getUint8(0) // 0\n```\n\n上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。\n\n另外，我们可以将ArrayBuffer生成的结果，传入TypedArray中：\n\n```\nvar buffer = new ArrayBuffer(12);\n\nvar x1 = new Int32Array(buffer);\nx1[0] = 1;\nvar x2 = new Uint8Array(buffer);\nx2[0]  = 2;\n\nx1[0] // 2\n```\n\nArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。\n\n```\nvar buffer = new ArrayBuffer(32);\nbuffer.byteLength\n// 32\n```\n如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。\n\n```\nif (buffer.byteLength === n) {\n  // 成功\n} else {\n  // 失败\n}\n```\n\nArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。\n\n```\nvar buffer = new ArrayBuffer(8);\nvar newBuffer = buffer.slice(0, 3);\n```\n\n上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。\n\nslice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。\n\n除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。\n\nArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。\n\n```\nvar buffer = new ArrayBuffer(8);\nArrayBuffer.isView(buffer) // false\n\nvar v = new Int32Array(buffer);\nArrayBuffer.isView(v) // true\n```\n\n#### TypedArray\n\n目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。\n\n* Int8Array：8位有符号整数，长度1个字节。\n* Uint8Array：8位无符号整数，长度1个字节。\n* Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。\n* Int16Array：16位有符号整数，长度2个字节。\n* Uint16Array：16位无符号整数，长度2个字节。\n* Int32Array：32位有符号整数，长度4个字节。\n* Uint32Array：32位无符号整数，长度4个字节。\n* Float32Array：32位浮点数，长度4个字节。\n* Float64Array：64位浮点数，长度8个字节。\n\n这9个构造函数生成的对象，统称为TypedArray对象。它们很像正常数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在类型化数组上面都能使用。两者的差异主要在以下方面。\n\n* TypedArray数组的所有成员，都是同一种类型和格式。\n* TypedArray数组的成员是连续的，不会有空位。\n* Typed化数组成员的默认值为0。比如，new Array(10)返回一个正常数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个类型化数组，里面10个成员都是0。\n* TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。\n\n##### 构造函数\n\nTypedArray数组提供9种构造函数，用来生成相应类型的数组实例。\n\n构造函数有多种用法。\n\n* TypedArray(buffer, byteOffset=0, length?)\n\n同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。\n\n```\n// 创建一个8字节的ArrayBuffer\nvar b = new ArrayBuffer(8);\n\n// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾\nvar v1 = new Int32Array(b);\n\n// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾\nvar v2 = new Uint8Array(b, 2);\n\n// 创建一个指向b的Int16视图，开始于字节2，长度为2\nvar v3 = new Int16Array(b, 2, 2);\n```\n\n对于以上代码，v1、v2和v3是重叠的：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。\n\n注意，byteOffset必须与所要建立的数据类型一致，否则会报错。\n\n```\nvar buffer = new ArrayBuffer(8);\nvar i16 = new Int16Array(buffer, 1);\n// Uncaught RangeError: start offset of Int16Array should be a multiple of 2\n```\n\n上面代码中，新生成一个8个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的16位整数视图，结果报错。因为，带符号的16位整数需要两个字节，所以byteOffset参数必须能够被2整除。\n\n如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式。\n\n* TypedArray(length)\n\n视图还可以不通过ArrayBuffer对象，直接分配内存而生成。\n\n```\nvar f64a = new Float64Array(8);\nf64a[0] = 10;\nf64a[1] = 20;\nf64a[2] = f64a[0] + f64a[1];\n```\n\n* TypedArray(typedArray)\n\n类型化数组的构造函数，可以接受另一个视图实例作为参数。\n\n```\nvar typedArray = new Int8Array(new Uint8Array(4));\n```\n\n上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。\n\n注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。\n\n```\nvar x = new Int8Array([1, 1]);\nvar y = new Int8Array(x);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 1\n```\n\n上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。\n\n如果想基于同一段内存，构造不同的视图，可以采用下面的写法。\n\n```\nvar x = new Int8Array([1, 1]);\nvar y = new Int8Array(x.buffer);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 2\n```\n\n* TypedArray(arrayLikeObject)\n\n构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。\n\n```\nvar typedArray = new Uint8Array([1, 2, 3, 4]);\n```\n\n注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。\n\n上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。\n\nTypedArray数组也可以转换回普通数组。\n\n```\nvar normalArray = Array.prototype.slice.call(typedArray);\n```\n\n##### BYTES_PER_ELEMENT属性\n\n每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。\n\n```\nInt8Array.BYTES_PER_ELEMENT // 1\nUint8Array.BYTES_PER_ELEMENT // 1\nInt16Array.BYTES_PER_ELEMENT // 2\nUint16Array.BYTES_PER_ELEMENT // 2\nInt32Array.BYTES_PER_ELEMENT // 4\nUint32Array.BYTES_PER_ELEMENT // 4\nFloat32Array.BYTES_PER_ELEMENT // 4\nFloat64Array.BYTES_PER_ELEMENT // 8\n```\n\n##### ArrayBuffer与字符串的互相转换\n\nArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。\n\n```\n// ArrayBuffer转为字符串，参数为ArrayBuffer对象\nfunction ab2str(buf) {\n  return String.fromCharCode.apply(null, new Uint16Array(buf));\n}\n\n// 字符串转为ArrayBuffer对象，参数为字符串\nfunction str2ab(str) {\n  var buf = new ArrayBuffer(str.length * 2); // 每个字符占用2个字节\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n```\n\n##### TypedArray.prototype.set()\n\nTypedArray数组的set方法用于复制数组（正常数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。\n\n```\nvar a = new Uint8Array(8);\nvar b = new Uint8Array(8);\n\nb.set(a);\n```\n\n上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。\n\n```\nvar a = new Uint16Array(8);\nvar b = new Uint16Array(10);\n\nb.set(a, 2)\n```\n上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。\n\n##### TypedArray.prototype.subarray()\n\nsubarray方法是对于TypedArray数组的一部分，再建立一个新的视图。\n\n```\nvar a = new Uint16Array(8);\nvar b = a.subarray(2,3);\n\na.byteLength // 16\nb.byteLength // 2\n```\n\nsubarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。\n\n##### TypedArray.prototype.slice()\n\nTypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。\n\n```\nlet ui8 = Uint8Array.of(0, 1, 2);\nui8.slice(-1)\n// Uint8Array [ 2 ]\n```\n\n\n上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。\n\nslice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。\n\n##### TypedArray.of()\n\nTypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。\n\n```\nFloat32Array.of(0.151, -8, 3.7)\n// Float32Array [ 0.151, -8, 3.7 ]\n```\n\n##### TypedArray.from()\n\n静态方法from接受一个**可遍历的数据结构（比如数组）**作为参数，返回一个基于这个结构的TypedArray实例。\n\n```\nUint16Array.from([0, 1, 2])\n// Uint16Array [ 0, 1, 2 ]\n```\n\n这个方法还可以将一种TypedArray实例，转为另一种。\n\n```\nvar ui16 = Uint16Array.from(Uint8Array.of(0, 1, 2));\nui16 instanceof Uint16Array // true\n```\n\nfrom方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。\n\n```\nInt8Array.of(127, 126, 125).map(x => 2 * x)\n// Int8Array [ -2, -4, -6 ]\n\nInt16Array.from(Int8Array.of(127, 126, 125), x => 2 * x)\n// Int16Array [ 254, 252, 250 ]\n```\n\n上面的例子中，from方法没有发生溢出，这说明遍历是针对新生成的16位整数数组，而不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中（占用内存从3字节变为6字节），然后再进行处理。\n\n#### DataView\n\n如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。\n\nDataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。\n\nDataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。\n\n```\nDataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);\n```\n下面是一个例子。\n\n```\nvar buffer = new ArrayBuffer(24);\nvar dv = new DataView(buffer);\n```\n\nDataView实例有以下属性，含义与TypedArray实例的同名方法相同。\n\n* DataView.prototype.buffer：返回对应的ArrayBuffer对象\n* DataView.prototype.byteLength：返回占据的内存字节长度\n* DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始\n\nDataView实例提供8个方法读取内存。\n\n* getInt8：读取1个字节，返回一个8位整数。\n* getUint8：读取1个字节，返回一个无符号的8位整数。\n* getInt16：读取2个字节，返回一个16位整数。\n* getUint16：读取2个字节，返回一个无符号的16位整数。\n* getInt32：读取4个字节，返回一个32位整数。\n* getUint32：读取4个字节，返回一个无符号的32位整数。\n* getFloat32：读取4个字节，返回一个32位浮点数。\n* getFloat64：读取8个字节，返回一个64位浮点数。\n\n这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。\n\n```\nvar buffer = new ArrayBuffer(24);\nvar dv = new DataView(buffer);\n\n// 从第1个字节读取一个8位无符号整数\nvar v1 = dv.getUint8(0);\n\n// 从第2个字节读取一个16位无符号整数\nvar v2 = dv.getUint16(1);\n\n// 从第4个字节读取一个16位无符号整数\nvar v3 = dv.getUint16(3);\n```\n\n上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。\n\n如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。\n\n```\n// 小端字节序\nvar v1 = dv.getUint16(1, true);\n\n// 大端字节序\nvar v2 = dv.getUint16(3, false);\n\n// 大端字节序\nvar v3 = dv.getUint16(3);\n```\n\nDataView视图提供8个方法写入内存。\n\n* setInt8：写入1个字节的8位整数。\n* setUint8：写入1个字节的8位无符号整数。\n* setInt16：写入2个字节的16位整数。\n* setUint16：写入2个字节的16位无符号整数。\n* setInt32：写入4个字节的32位整数。\n* setUint32：写入4个字节的32位无符号整数。\n* setFloat32：写入4个字节的32位浮点数。\n* setFloat64：写入8个字节的64位浮点数。\n\n这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。\n\n```\n// 在第1个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(0, 25, false);\n\n// 在第5个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(4, 25);\n\n// 在第9个字节，以小端字节序写入值为2.5的32位浮点数\ndv.setFloat32(8, 2.5, true);\n```\n\n如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。\n\n```\nvar littleEndian = (function() {\n  var buffer = new ArrayBuffer(2);\n  new DataView(buffer).setInt16(0, 256, true);\n  return new Int16Array(buffer)[0] === 256;\n})();\n```\n\n#### Blob\n\nBlob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。\n\n要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，请参阅 File文档。\n\n从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：\n\n```\nvar reader = new FileReader();\nreader.addEventListener(\"loadend\", function() {\n   // reader.result 包含转化为类型数组的blob\n});\nreader.readAsArrayBuffer(blob);\n```\n\n更多关于Blob的内容，请直接查看[这里](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)\n\n### 数据格式转换\n\n#### String转Blob\n\n```\n//将字符串 转换成 Blob 对象\nvar blob = new Blob([\"Hello World!\"], {\n    type: 'text/plain'\n});\nconsole.info(blob);\nconsole.info(blob.slice(1, 3, 'text/plain'));\n```\n#### TypeArray转Blob\n\n```\n//将 TypeArray  转换成 Blob 对象\nvar array = new Uint16Array([97, 32, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33]);\n//测试成功\n//var blob = new Blob([array], { type: \"application/octet-binary\" });\n//测试成功， 注意必须[]的包裹\nvar blob = new Blob([array]);\n//将 Blob对象 读成字符串\nvar reader = new FileReader();\nreader.readAsText(blob, 'utf-8');\nreader.onload = function (e) {\n    console.info(reader.result); //a Hello world!\n}\n```\n\n#### ArrayBuffer转Blob\n\n```\nvar buffer = new ArrayBuffer(32);\nvar blob = new Blob([buffer]);       // 注意必须包裹[]\n```\n\n#### Blob转String\n\n这里需要注意的是readAsText方法的使用。\n\n```\n//将字符串转换成 Blob对象\nvar blob = new Blob(['中文字符串'], {\n    type: 'text/plain'\n});\n//将Blob 对象转换成字符串\nvar reader = new FileReader();\nreader.readAsText(blob, 'utf-8');\nreader.onload = function (e) {\n    console.info(reader.result);\n}\n```\n\n#### Blob转ArrayBuffer\n\n这里需要注意的是readAsArrayBuffer方法的使用。\n\n```\n//将字符串转换成 Blob对象\nvar blob = new Blob(['中文字符串'], {\n    type: 'text/plain'\n});\n//将Blob 对象转换成 ArrayBuffer\nvar reader = new FileReader();\nreader.readAsArrayBuffer(blob);\nreader.onload = function (e) {\n    console.info(reader.result); //ArrayBuffer {}\n    //经常会遇到的异常 Uncaught RangeError: byte length of Int16Array should be a multiple of 2\n    //var buf = new int16array(reader.result);\n    //console.info(buf);\n\n    //将 ArrayBufferView  转换成Blob\n    var buf = new Uint8Array(reader.result);\n    console.info(buf); //[228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]\n    reader.readAsText(new Blob([buf]), 'utf-8');\n    reader.onload = function () {\n        console.info(reader.result); //中文字符串\n    };\n\n    //将 ArrayBufferView  转换成Blob\n    var buf = new DataView(reader.result);\n    console.info(buf); //DataView {}\n    reader.readAsText(new Blob([buf]), 'utf-8');\n    reader.onload = function () {\n        console.info(reader.result); //中文字符串\n    };\n}\n```\n\n","slug":"浅谈前端中的二进制数据类型","published":1,"updated":"2021-12-23T05:50:07.554Z","_id":"ckxijpqto002rd3mr6y78h5k0","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>目前在一个项目中，WebSocket部分由于后端使用了gzip压缩，前端处理起来废了一点时间，从而发现自己在二进制数据类型这个知识点还存在一定的盲区，因此这里进行总结。</p>\n</blockquote>\n<p>本文主要简单介绍ArrayBuffer对象、TypedArray对象、DataView对象以及Blob原始数据类型，和它们之间的互相转换方法。部分代码参考<a href=\"http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc4\">这里</a>而非本人原创，仅做个人学习使用。</p>\n<p>这些类型化对象，一般会在以下场景中使用：</p>\n<ul>\n<li>WebGL 中，浏览器和显卡之间需要使用二进制数据进行通信。</li>\n<li>在一些 Rest 接口或者 WebSocket 中，采用压缩过的数据进行通信，这个压缩和解压缩的过程可能需要借助二进制对象。</li>\n<li>在 Canvas 中，我们可能需要通过生成 Blob 的方式保存当前内容。</li>\n<li>在 Img 等资源文件中，URL 可以为 Blob 原始数据类型。</li>\n<li>在读取用户上传文件时，可能需要用到二进制数据类型进行中间转换。</li>\n</ul>\n<p>下文分两部分，前一部分概述各个二进制数据类型，后一部分将它们之间的互相转换。</p>\n<h3 id=\"二进制数据类型概述\"><a href=\"#二进制数据类型概述\" class=\"headerlink\" title=\"二进制数据类型概述\"></a>二进制数据类型概述</h3><h4 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h4><p>ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。</p>\n<p>ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。</p>\n<p>为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dataView = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buf);</span><br><span class=\"line\">dataView.getUint8(<span class=\"number\">0</span>) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。</p>\n<p>另外，我们可以将ArrayBuffer生成的结果，传入TypedArray中：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> buffer = new ArrayBuffer(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">var</span> x<span class=\"number\">1</span> = new Int<span class=\"number\">32</span>Array(buffer);</span><br><span class=\"line\"><span class=\"attribute\">x1</span>[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"attribute\">var</span> x<span class=\"number\">2</span> = new Uint<span class=\"number\">8</span>Array(buffer);</span><br><span class=\"line\"><span class=\"attribute\">x2</span>[<span class=\"number\">0</span>]  = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">x1</span>[<span class=\"number\">0</span>] // <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>ArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br><span class=\"line\">buffer.byteLength</span><br><span class=\"line\"><span class=\"comment\">// 32</span></span><br></pre></td></tr></table></figure>\n<p>如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (buffer.byteLength === n) &#123;</span><br><span class=\"line\">  <span class=\"regexp\">//</span> 成功</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"regexp\">//</span> 失败</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Buffer</span> = buffer.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。</p>\n<p>slice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。</p>\n<p>除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p>\n<p>ArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = <span class=\"keyword\">new</span> <span class=\"constructor\">ArrayBuffer(8)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">ArrayBuffer</span>.</span></span>is<span class=\"constructor\">View(<span class=\"params\">buffer</span>)</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">var v = <span class=\"keyword\">new</span> <span class=\"constructor\">Int32Array(<span class=\"params\">buffer</span>)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">ArrayBuffer</span>.</span></span>is<span class=\"constructor\">View(<span class=\"params\">v</span>)</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h4><p>目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。</p>\n<ul>\n<li>Int8Array：8位有符号整数，长度1个字节。</li>\n<li>Uint8Array：8位无符号整数，长度1个字节。</li>\n<li>Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。</li>\n<li>Int16Array：16位有符号整数，长度2个字节。</li>\n<li>Uint16Array：16位无符号整数，长度2个字节。</li>\n<li>Int32Array：32位有符号整数，长度4个字节。</li>\n<li>Uint32Array：32位无符号整数，长度4个字节。</li>\n<li>Float32Array：32位浮点数，长度4个字节。</li>\n<li>Float64Array：64位浮点数，长度8个字节。</li>\n</ul>\n<p>这9个构造函数生成的对象，统称为TypedArray对象。它们很像正常数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在类型化数组上面都能使用。两者的差异主要在以下方面。</p>\n<ul>\n<li>TypedArray数组的所有成员，都是同一种类型和格式。</li>\n<li>TypedArray数组的成员是连续的，不会有空位。</li>\n<li>Typed化数组成员的默认值为0。比如，new Array(10)返回一个正常数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个类型化数组，里面10个成员都是0。</li>\n<li>TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。</li>\n</ul>\n<h5 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h5><p>TypedArray数组提供9种构造函数，用来生成相应类型的数组实例。</p>\n<p>构造函数有多种用法。</p>\n<ul>\n<li>TypedArray(buffer, byteOffset=0, length?)</li>\n</ul>\n<p>同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个8字节的ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v1 = <span class=\"keyword\">new</span> <span class=\"type\">Int32Array</span>(b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v2 = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(b, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Int16视图，开始于字节2，长度为2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v3 = <span class=\"keyword\">new</span> <span class=\"type\">Int16Array</span>(b, <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>对于以上代码，v1、v2和v3是重叠的：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p>\n<p>注意，byteOffset必须与所要建立的数据类型一致，否则会报错。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> i16 = <span class=\"keyword\">new</span> <span class=\"type\">Int16Array</span>(buffer, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// Uncaught RangeError: start offset of Int16Array should be a multiple of 2</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，新生成一个8个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的16位整数视图，结果报错。因为，带符号的16位整数需要两个字节，所以byteOffset参数必须能够被2整除。</p>\n<p>如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式。</p>\n<ul>\n<li>TypedArray(length)</li>\n</ul>\n<p>视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> f<span class=\"number\">64</span>a = new Float<span class=\"number\">64</span>Array(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"attribute\">f64a</span>[<span class=\"number\">0</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"attribute\">f64a</span>[<span class=\"number\">1</span>] = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"attribute\">f64a</span>[<span class=\"number\">2</span>] = f<span class=\"number\">64</span>a[<span class=\"number\">0</span>] + f<span class=\"number\">64</span>a[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>TypedArray(typedArray)</li>\n</ul>\n<p>类型化数组的构造函数，可以接受另一个视图实例作为参数。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> typedArray = <span class=\"keyword\">new</span> <span class=\"type\">Int8Array</span>(<span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">4</span>));</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。</p>\n<p>注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> x = new Int<span class=\"number\">8</span>Array([<span class=\"number\">1</span>, <span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"attribute\">var</span> y = new Int<span class=\"number\">8</span>Array(x);</span><br><span class=\"line\"><span class=\"attribute\">x</span>[<span class=\"number\">0</span>] // <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attribute\">y</span>[<span class=\"number\">0</span>] // <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">x</span>[<span class=\"number\">0</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"attribute\">y</span>[<span class=\"number\">0</span>] // <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。</p>\n<p>如果想基于同一段内存，构造不同的视图，可以采用下面的写法。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> x = new Int<span class=\"number\">8</span>Array([<span class=\"number\">1</span>, <span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"attribute\">var</span> y = new Int<span class=\"number\">8</span>Array(x.buffer);</span><br><span class=\"line\"><span class=\"attribute\">x</span>[<span class=\"number\">0</span>] // <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attribute\">y</span>[<span class=\"number\">0</span>] // <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">x</span>[<span class=\"number\">0</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"attribute\">y</span>[<span class=\"number\">0</span>] // <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>TypedArray(arrayLikeObject)</li>\n</ul>\n<p>构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> typedArray = new Uint<span class=\"number\">8</span>Array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。</p>\n<p>上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。</p>\n<p>TypedArray数组也可以转换回普通数组。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> normalArray = <span class=\"type\">Array</span>.proto<span class=\"keyword\">type</span>.slice.call(typedArray);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"BYTES-PER-ELEMENT属性\"><a href=\"#BYTES-PER-ELEMENT属性\" class=\"headerlink\" title=\"BYTES_PER_ELEMENT属性\"></a>BYTES_PER_ELEMENT属性</h5><p>每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Int8Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">1</span></span><br><span class=\"line\">Uint8Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">1</span></span><br><span class=\"line\">Int16Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">2</span></span><br><span class=\"line\">Uint16Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">2</span></span><br><span class=\"line\">Int32Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">4</span></span><br><span class=\"line\">Uint32Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">4</span></span><br><span class=\"line\">Float32Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">4</span></span><br><span class=\"line\">Float64Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"ArrayBuffer与字符串的互相转换\"><a href=\"#ArrayBuffer与字符串的互相转换\" class=\"headerlink\" title=\"ArrayBuffer与字符串的互相转换\"></a>ArrayBuffer与字符串的互相转换</h5><p>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ArrayBuffer转为字符串，参数为ArrayBuffer对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ab2str</span>(<span class=\"params\">buf</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode.apply(<span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(buf));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串转为ArrayBuffer对象，参数为字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">str2ab</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(str.length * <span class=\"number\">2</span>); <span class=\"comment\">// 每个字符占用2个字节</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> bufView = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(buf);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, strLen = str.length; i &lt; strLen; i++) &#123;</span><br><span class=\"line\">    bufView[i] = str.charCodeAt(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"TypedArray-prototype-set\"><a href=\"#TypedArray-prototype-set\" class=\"headerlink\" title=\"TypedArray.prototype.set()\"></a>TypedArray.prototype.set()</h5><p>TypedArray数组的set方法用于复制数组（正常数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b.<span class=\"keyword\">set</span>(a);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"type\">Uint16Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">Uint16Array</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b.<span class=\"keyword\">set</span>(a, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p>\n<h5 id=\"TypedArray-prototype-subarray\"><a href=\"#TypedArray-prototype-subarray\" class=\"headerlink\" title=\"TypedArray.prototype.subarray()\"></a>TypedArray.prototype.subarray()</h5><p>subarray方法是对于TypedArray数组的一部分，再建立一个新的视图。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> a = new Uint<span class=\"number\">16</span>Array(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"attribute\">var</span> b = a.subarray(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">a</span>.byteLength // <span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"attribute\">b</span>.byteLength // <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p>\n<h5 id=\"TypedArray-prototype-slice\"><a href=\"#TypedArray-prototype-slice\" class=\"headerlink\" title=\"TypedArray.prototype.slice()\"></a>TypedArray.prototype.slice()</h5><p>TypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ui<span class=\"number\">8</span> = Ui<span class=\"symbol\">nt8</span>Array.of<span class=\"comment\">(0, 1, 2)</span>;</span><br><span class=\"line\">ui<span class=\"number\">8.</span>slice<span class=\"comment\">(-1)</span></span><br><span class=\"line\"><span class=\"comment\">// Uint8Array [ 2 ]</span></span><br></pre></td></tr></table></figure>\n\n\n<p>上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。</p>\n<p>slice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。</p>\n<h5 id=\"TypedArray-of\"><a href=\"#TypedArray-of\" class=\"headerlink\" title=\"TypedArray.of()\"></a>TypedArray.of()</h5><p>TypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Float32Array</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"number\">0.151</span>, -<span class=\"number\">8</span>, <span class=\"number\">3.7</span>)</span><br><span class=\"line\"><span class=\"comment\">// Float32Array [ 0.151, -8, 3.7 ]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"TypedArray-from\"><a href=\"#TypedArray-from\" class=\"headerlink\" title=\"TypedArray.from()\"></a>TypedArray.from()</h5><p>静态方法from接受一个<strong>可遍历的数据结构（比如数组）</strong>作为参数，返回一个基于这个结构的TypedArray实例。</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Uint16Array</span>.<span class=\"keyword\">from</span>([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"built_in\">Uint16Array</span> [ <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span> ]</span><br></pre></td></tr></table></figure>\n\n<p>这个方法还可以将一种TypedArray实例，转为另一种。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> ui<span class=\"number\">16</span> = Uint<span class=\"number\">16</span>Array.from(Uint<span class=\"number\">8</span>Array.of(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"attribute\">ui16</span> instanceof Uint<span class=\"number\">16</span>Array // true</span><br></pre></td></tr></table></figure>\n\n<p>from方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Int8Array</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"number\">127</span>, <span class=\"number\">126</span>, <span class=\"number\">125</span>).map(x =&gt; <span class=\"number\">2</span><span class=\"operator\"> * </span>x)</span><br><span class=\"line\"><span class=\"comment\">// Int8Array [ -2, -4, -6 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Int16Array</span>.</span></span>from(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Int8Array</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"number\">127</span>, <span class=\"number\">126</span>, <span class=\"number\">125</span>),<span class=\"function\"> <span class=\"params\">x</span> =&gt;</span> <span class=\"number\">2</span><span class=\"operator\"> * </span>x)</span><br><span class=\"line\"><span class=\"comment\">// Int16Array [ 254, 252, 250 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中，from方法没有发生溢出，这说明遍历是针对新生成的16位整数数组，而不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中（占用内存从3字节变为6字节），然后再进行处理。</p>\n<h4 id=\"DataView\"><a href=\"#DataView\" class=\"headerlink\" title=\"DataView\"></a>DataView</h4><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。</p>\n<p>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>\n<p>DataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">DataView</span>(<span class=\"built_in\">ArrayBuffer</span> buffer [, 字节起始位置 [, 长度]]);</span><br></pre></td></tr></table></figure>\n<p>下面是一个例子。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dv = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>DataView实例有以下属性，含义与TypedArray实例的同名方法相同。</p>\n<ul>\n<li>DataView.prototype.buffer：返回对应的ArrayBuffer对象</li>\n<li>DataView.prototype.byteLength：返回占据的内存字节长度</li>\n<li>DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始</li>\n</ul>\n<p>DataView实例提供8个方法读取内存。</p>\n<ul>\n<li>getInt8：读取1个字节，返回一个8位整数。</li>\n<li>getUint8：读取1个字节，返回一个无符号的8位整数。</li>\n<li>getInt16：读取2个字节，返回一个16位整数。</li>\n<li>getUint16：读取2个字节，返回一个无符号的16位整数。</li>\n<li>getInt32：读取4个字节，返回一个32位整数。</li>\n<li>getUint32：读取4个字节，返回一个无符号的32位整数。</li>\n<li>getFloat32：读取4个字节，返回一个32位浮点数。</li>\n<li>getFloat64：读取8个字节，返回一个64位浮点数。</li>\n</ul>\n<p>这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dv = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第1个字节读取一个8位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v1 = dv.getUint8(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第2个字节读取一个16位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v2 = dv.getUint16(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第4个字节读取一个16位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v3 = dv.getUint16(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。</p>\n<p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 小端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">1</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(1, true)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 大端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">2</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(3, false)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 大端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">3</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(3)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>DataView视图提供8个方法写入内存。</p>\n<ul>\n<li>setInt8：写入1个字节的8位整数。</li>\n<li>setUint8：写入1个字节的8位无符号整数。</li>\n<li>setInt16：写入2个字节的16位整数。</li>\n<li>setUint16：写入2个字节的16位无符号整数。</li>\n<li>setInt32：写入4个字节的32位整数。</li>\n<li>setUint32：写入4个字节的32位无符号整数。</li>\n<li>setFloat32：写入4个字节的32位浮点数。</li>\n<li>setFloat64：写入8个字节的64位浮点数。</li>\n</ul>\n<p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在第1个字节，以大端字节序写入值为25的32位整数</span></span><br><span class=\"line\">dv.setI<span class=\"symbol\">nt32</span><span class=\"comment\">(0, 25, false)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第5个字节，以大端字节序写入值为25的32位整数</span></span><br><span class=\"line\">dv.setI<span class=\"symbol\">nt32</span><span class=\"comment\">(4, 25)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第9个字节，以小端字节序写入值为2.5的32位浮点数</span></span><br><span class=\"line\">dv.setFloat<span class=\"number\">32</span><span class=\"comment\">(8, 2.5, true)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> littleEndian = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(buffer).setInt16(<span class=\"number\">0</span>, <span class=\"number\">256</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Int16Array</span>(buffer)[<span class=\"number\">0</span>] === <span class=\"number\">256</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob\"></a>Blob</h4><p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>\n<p>要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，请参阅 File文档。</p>\n<p>从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reader = <span class=\"keyword\">new</span> <span class=\"constructor\">FileReader()</span>;</span><br><span class=\"line\">reader.add<span class=\"constructor\">EventListener(<span class=\"string\">&quot;loadend&quot;</span>, <span class=\"params\">function</span>()</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// reader.result 包含转化为类型数组的blob</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">reader.read<span class=\"constructor\">AsArrayBuffer(<span class=\"params\">blob</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>更多关于Blob的内容，请直接查看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\">这里</a></p>\n<h3 id=\"数据格式转换\"><a href=\"#数据格式转换\" class=\"headerlink\" title=\"数据格式转换\"></a>数据格式转换</h3><h4 id=\"String转Blob\"><a href=\"#String转Blob\" class=\"headerlink\" title=\"String转Blob\"></a>String转Blob</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串 转换成 Blob 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&quot;Hello World!&quot;</span>], &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;text/plain&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.info(blob);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.info(blob.slice(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"string\">&#x27;text/plain&#x27;</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"TypeArray转Blob\"><a href=\"#TypeArray转Blob\" class=\"headerlink\" title=\"TypeArray转Blob\"></a>TypeArray转Blob</h4><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将 TypeArray  转换成 Blob 对象</span></span><br><span class=\"line\">var <span class=\"built_in\">array</span> = <span class=\"keyword\">new</span> <span class=\"constructor\">Uint16Array([97, 32, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])</span>;</span><br><span class=\"line\"><span class=\"comment\">//测试成功</span></span><br><span class=\"line\"><span class=\"comment\">//var blob = new Blob([array], &#123; type: &quot;application/octet-binary&quot; &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">//测试成功， 注意必须[]的包裹</span></span><br><span class=\"line\">var blob = <span class=\"keyword\">new</span> <span class=\"constructor\">Blob([<span class=\"params\">array</span>])</span>;</span><br><span class=\"line\"><span class=\"comment\">//将 Blob对象 读成字符串</span></span><br><span class=\"line\">var reader = <span class=\"keyword\">new</span> <span class=\"constructor\">FileReader()</span>;</span><br><span class=\"line\">reader.read<span class=\"constructor\">AsText(<span class=\"params\">blob</span>, &#x27;<span class=\"params\">utf</span>-8&#x27;)</span>;</span><br><span class=\"line\">reader.onload = <span class=\"keyword\">function</span> (e) &#123;</span><br><span class=\"line\">    console.info(reader.result); <span class=\"comment\">//a Hello world!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayBuffer转Blob\"><a href=\"#ArrayBuffer转Blob\" class=\"headerlink\" title=\"ArrayBuffer转Blob\"></a>ArrayBuffer转Blob</h4><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> <span class=\"type\">Blob</span>([buffer]);       <span class=\"comment\">// 注意必须包裹[]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Blob转String\"><a href=\"#Blob转String\" class=\"headerlink\" title=\"Blob转String\"></a>Blob转String</h4><p>这里需要注意的是readAsText方法的使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串转换成 Blob对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&#x27;中文字符串&#x27;</span>], &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;text/plain&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//将Blob 对象转换成字符串</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.readAsText(blob, <span class=\"string\">&#x27;utf-8&#x27;</span>);</span><br><span class=\"line\">reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(reader.result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Blob转ArrayBuffer\"><a href=\"#Blob转ArrayBuffer\" class=\"headerlink\" title=\"Blob转ArrayBuffer\"></a>Blob转ArrayBuffer</h4><p>这里需要注意的是readAsArrayBuffer方法的使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串转换成 Blob对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&#x27;中文字符串&#x27;</span>], &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;text/plain&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//将Blob 对象转换成 ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.readAsArrayBuffer(blob);</span><br><span class=\"line\">reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//ArrayBuffer &#123;&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//经常会遇到的异常 Uncaught RangeError: byte length of Int16Array should be a multiple of 2</span></span><br><span class=\"line\">    <span class=\"comment\">//var buf = new int16array(reader.result);</span></span><br><span class=\"line\">    <span class=\"comment\">//console.info(buf);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将 ArrayBufferView  转换成Blob</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(reader.result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(buf); <span class=\"comment\">//[228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]</span></span><br><span class=\"line\">    reader.readAsText(<span class=\"keyword\">new</span> Blob([buf]), <span class=\"string\">&#x27;utf-8&#x27;</span>);</span><br><span class=\"line\">    reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//中文字符串</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将 ArrayBufferView  转换成Blob</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(reader.result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(buf); <span class=\"comment\">//DataView &#123;&#125;</span></span><br><span class=\"line\">    reader.readAsText(<span class=\"keyword\">new</span> Blob([buf]), <span class=\"string\">&#x27;utf-8&#x27;</span>);</span><br><span class=\"line\">    reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//中文字符串</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>目前在一个项目中，WebSocket部分由于后端使用了gzip压缩，前端处理起来废了一点时间，从而发现自己在二进制数据类型这个知识点还存在一定的盲区，因此这里进行总结。</p>\n</blockquote>\n<p>本文主要简单介绍ArrayBuffer对象、TypedArray对象、DataView对象以及Blob原始数据类型，和它们之间的互相转换方法。部分代码参考<a href=\"http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc4\">这里</a>而非本人原创，仅做个人学习使用。</p>\n<p>这些类型化对象，一般会在以下场景中使用：</p>\n<ul>\n<li>WebGL 中，浏览器和显卡之间需要使用二进制数据进行通信。</li>\n<li>在一些 Rest 接口或者 WebSocket 中，采用压缩过的数据进行通信，这个压缩和解压缩的过程可能需要借助二进制对象。</li>\n<li>在 Canvas 中，我们可能需要通过生成 Blob 的方式保存当前内容。</li>\n<li>在 Img 等资源文件中，URL 可以为 Blob 原始数据类型。</li>\n<li>在读取用户上传文件时，可能需要用到二进制数据类型进行中间转换。</li>\n</ul>\n<p>下文分两部分，前一部分概述各个二进制数据类型，后一部分将它们之间的互相转换。</p>\n<h3 id=\"二进制数据类型概述\"><a href=\"#二进制数据类型概述\" class=\"headerlink\" title=\"二进制数据类型概述\"></a>二进制数据类型概述</h3><h4 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h4><p>ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。</p>\n<p>ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。</p>\n<p>为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dataView = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buf);</span><br><span class=\"line\">dataView.getUint8(<span class=\"number\">0</span>) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。</p>\n<p>另外，我们可以将ArrayBuffer生成的结果，传入TypedArray中：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> buffer = new ArrayBuffer(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">var</span> x<span class=\"number\">1</span> = new Int<span class=\"number\">32</span>Array(buffer);</span><br><span class=\"line\"><span class=\"attribute\">x1</span>[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"attribute\">var</span> x<span class=\"number\">2</span> = new Uint<span class=\"number\">8</span>Array(buffer);</span><br><span class=\"line\"><span class=\"attribute\">x2</span>[<span class=\"number\">0</span>]  = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">x1</span>[<span class=\"number\">0</span>] // <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>ArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br><span class=\"line\">buffer.byteLength</span><br><span class=\"line\"><span class=\"comment\">// 32</span></span><br></pre></td></tr></table></figure>\n<p>如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (buffer.byteLength === n) &#123;</span><br><span class=\"line\">  <span class=\"regexp\">//</span> 成功</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"regexp\">//</span> 失败</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Buffer</span> = buffer.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。</p>\n<p>slice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。</p>\n<p>除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p>\n<p>ArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = <span class=\"keyword\">new</span> <span class=\"constructor\">ArrayBuffer(8)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">ArrayBuffer</span>.</span></span>is<span class=\"constructor\">View(<span class=\"params\">buffer</span>)</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">var v = <span class=\"keyword\">new</span> <span class=\"constructor\">Int32Array(<span class=\"params\">buffer</span>)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">ArrayBuffer</span>.</span></span>is<span class=\"constructor\">View(<span class=\"params\">v</span>)</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h4><p>目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。</p>\n<ul>\n<li>Int8Array：8位有符号整数，长度1个字节。</li>\n<li>Uint8Array：8位无符号整数，长度1个字节。</li>\n<li>Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。</li>\n<li>Int16Array：16位有符号整数，长度2个字节。</li>\n<li>Uint16Array：16位无符号整数，长度2个字节。</li>\n<li>Int32Array：32位有符号整数，长度4个字节。</li>\n<li>Uint32Array：32位无符号整数，长度4个字节。</li>\n<li>Float32Array：32位浮点数，长度4个字节。</li>\n<li>Float64Array：64位浮点数，长度8个字节。</li>\n</ul>\n<p>这9个构造函数生成的对象，统称为TypedArray对象。它们很像正常数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在类型化数组上面都能使用。两者的差异主要在以下方面。</p>\n<ul>\n<li>TypedArray数组的所有成员，都是同一种类型和格式。</li>\n<li>TypedArray数组的成员是连续的，不会有空位。</li>\n<li>Typed化数组成员的默认值为0。比如，new Array(10)返回一个正常数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个类型化数组，里面10个成员都是0。</li>\n<li>TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。</li>\n</ul>\n<h5 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h5><p>TypedArray数组提供9种构造函数，用来生成相应类型的数组实例。</p>\n<p>构造函数有多种用法。</p>\n<ul>\n<li>TypedArray(buffer, byteOffset=0, length?)</li>\n</ul>\n<p>同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个8字节的ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v1 = <span class=\"keyword\">new</span> <span class=\"type\">Int32Array</span>(b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v2 = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(b, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Int16视图，开始于字节2，长度为2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v3 = <span class=\"keyword\">new</span> <span class=\"type\">Int16Array</span>(b, <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>对于以上代码，v1、v2和v3是重叠的：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p>\n<p>注意，byteOffset必须与所要建立的数据类型一致，否则会报错。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> i16 = <span class=\"keyword\">new</span> <span class=\"type\">Int16Array</span>(buffer, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// Uncaught RangeError: start offset of Int16Array should be a multiple of 2</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，新生成一个8个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的16位整数视图，结果报错。因为，带符号的16位整数需要两个字节，所以byteOffset参数必须能够被2整除。</p>\n<p>如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式。</p>\n<ul>\n<li>TypedArray(length)</li>\n</ul>\n<p>视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> f<span class=\"number\">64</span>a = new Float<span class=\"number\">64</span>Array(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"attribute\">f64a</span>[<span class=\"number\">0</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"attribute\">f64a</span>[<span class=\"number\">1</span>] = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"attribute\">f64a</span>[<span class=\"number\">2</span>] = f<span class=\"number\">64</span>a[<span class=\"number\">0</span>] + f<span class=\"number\">64</span>a[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>TypedArray(typedArray)</li>\n</ul>\n<p>类型化数组的构造函数，可以接受另一个视图实例作为参数。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> typedArray = <span class=\"keyword\">new</span> <span class=\"type\">Int8Array</span>(<span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">4</span>));</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。</p>\n<p>注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> x = new Int<span class=\"number\">8</span>Array([<span class=\"number\">1</span>, <span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"attribute\">var</span> y = new Int<span class=\"number\">8</span>Array(x);</span><br><span class=\"line\"><span class=\"attribute\">x</span>[<span class=\"number\">0</span>] // <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attribute\">y</span>[<span class=\"number\">0</span>] // <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">x</span>[<span class=\"number\">0</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"attribute\">y</span>[<span class=\"number\">0</span>] // <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。</p>\n<p>如果想基于同一段内存，构造不同的视图，可以采用下面的写法。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> x = new Int<span class=\"number\">8</span>Array([<span class=\"number\">1</span>, <span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"attribute\">var</span> y = new Int<span class=\"number\">8</span>Array(x.buffer);</span><br><span class=\"line\"><span class=\"attribute\">x</span>[<span class=\"number\">0</span>] // <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attribute\">y</span>[<span class=\"number\">0</span>] // <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">x</span>[<span class=\"number\">0</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"attribute\">y</span>[<span class=\"number\">0</span>] // <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>TypedArray(arrayLikeObject)</li>\n</ul>\n<p>构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> typedArray = new Uint<span class=\"number\">8</span>Array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。</p>\n<p>上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。</p>\n<p>TypedArray数组也可以转换回普通数组。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> normalArray = <span class=\"type\">Array</span>.proto<span class=\"keyword\">type</span>.slice.call(typedArray);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"BYTES-PER-ELEMENT属性\"><a href=\"#BYTES-PER-ELEMENT属性\" class=\"headerlink\" title=\"BYTES_PER_ELEMENT属性\"></a>BYTES_PER_ELEMENT属性</h5><p>每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Int8Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">1</span></span><br><span class=\"line\">Uint8Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">1</span></span><br><span class=\"line\">Int16Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">2</span></span><br><span class=\"line\">Uint16Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">2</span></span><br><span class=\"line\">Int32Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">4</span></span><br><span class=\"line\">Uint32Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">4</span></span><br><span class=\"line\">Float32Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">4</span></span><br><span class=\"line\">Float64Array.BYTES_PER_ELEMENT <span class=\"regexp\">//</span> <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"ArrayBuffer与字符串的互相转换\"><a href=\"#ArrayBuffer与字符串的互相转换\" class=\"headerlink\" title=\"ArrayBuffer与字符串的互相转换\"></a>ArrayBuffer与字符串的互相转换</h5><p>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ArrayBuffer转为字符串，参数为ArrayBuffer对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ab2str</span>(<span class=\"params\">buf</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode.apply(<span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(buf));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串转为ArrayBuffer对象，参数为字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">str2ab</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(str.length * <span class=\"number\">2</span>); <span class=\"comment\">// 每个字符占用2个字节</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> bufView = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(buf);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, strLen = str.length; i &lt; strLen; i++) &#123;</span><br><span class=\"line\">    bufView[i] = str.charCodeAt(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"TypedArray-prototype-set\"><a href=\"#TypedArray-prototype-set\" class=\"headerlink\" title=\"TypedArray.prototype.set()\"></a>TypedArray.prototype.set()</h5><p>TypedArray数组的set方法用于复制数组（正常数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b.<span class=\"keyword\">set</span>(a);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"type\">Uint16Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">Uint16Array</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b.<span class=\"keyword\">set</span>(a, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p>\n<h5 id=\"TypedArray-prototype-subarray\"><a href=\"#TypedArray-prototype-subarray\" class=\"headerlink\" title=\"TypedArray.prototype.subarray()\"></a>TypedArray.prototype.subarray()</h5><p>subarray方法是对于TypedArray数组的一部分，再建立一个新的视图。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> a = new Uint<span class=\"number\">16</span>Array(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"attribute\">var</span> b = a.subarray(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">a</span>.byteLength // <span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"attribute\">b</span>.byteLength // <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p>\n<h5 id=\"TypedArray-prototype-slice\"><a href=\"#TypedArray-prototype-slice\" class=\"headerlink\" title=\"TypedArray.prototype.slice()\"></a>TypedArray.prototype.slice()</h5><p>TypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ui<span class=\"number\">8</span> = Ui<span class=\"symbol\">nt8</span>Array.of<span class=\"comment\">(0, 1, 2)</span>;</span><br><span class=\"line\">ui<span class=\"number\">8.</span>slice<span class=\"comment\">(-1)</span></span><br><span class=\"line\"><span class=\"comment\">// Uint8Array [ 2 ]</span></span><br></pre></td></tr></table></figure>\n\n\n<p>上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。</p>\n<p>slice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。</p>\n<h5 id=\"TypedArray-of\"><a href=\"#TypedArray-of\" class=\"headerlink\" title=\"TypedArray.of()\"></a>TypedArray.of()</h5><p>TypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Float32Array</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"number\">0.151</span>, -<span class=\"number\">8</span>, <span class=\"number\">3.7</span>)</span><br><span class=\"line\"><span class=\"comment\">// Float32Array [ 0.151, -8, 3.7 ]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"TypedArray-from\"><a href=\"#TypedArray-from\" class=\"headerlink\" title=\"TypedArray.from()\"></a>TypedArray.from()</h5><p>静态方法from接受一个<strong>可遍历的数据结构（比如数组）</strong>作为参数，返回一个基于这个结构的TypedArray实例。</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Uint16Array</span>.<span class=\"keyword\">from</span>([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"built_in\">Uint16Array</span> [ <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span> ]</span><br></pre></td></tr></table></figure>\n\n<p>这个方法还可以将一种TypedArray实例，转为另一种。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var</span> ui<span class=\"number\">16</span> = Uint<span class=\"number\">16</span>Array.from(Uint<span class=\"number\">8</span>Array.of(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"attribute\">ui16</span> instanceof Uint<span class=\"number\">16</span>Array // true</span><br></pre></td></tr></table></figure>\n\n<p>from方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Int8Array</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"number\">127</span>, <span class=\"number\">126</span>, <span class=\"number\">125</span>).map(x =&gt; <span class=\"number\">2</span><span class=\"operator\"> * </span>x)</span><br><span class=\"line\"><span class=\"comment\">// Int8Array [ -2, -4, -6 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Int16Array</span>.</span></span>from(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Int8Array</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"number\">127</span>, <span class=\"number\">126</span>, <span class=\"number\">125</span>),<span class=\"function\"> <span class=\"params\">x</span> =&gt;</span> <span class=\"number\">2</span><span class=\"operator\"> * </span>x)</span><br><span class=\"line\"><span class=\"comment\">// Int16Array [ 254, 252, 250 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中，from方法没有发生溢出，这说明遍历是针对新生成的16位整数数组，而不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中（占用内存从3字节变为6字节），然后再进行处理。</p>\n<h4 id=\"DataView\"><a href=\"#DataView\" class=\"headerlink\" title=\"DataView\"></a>DataView</h4><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。</p>\n<p>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>\n<p>DataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">DataView</span>(<span class=\"built_in\">ArrayBuffer</span> buffer [, 字节起始位置 [, 长度]]);</span><br></pre></td></tr></table></figure>\n<p>下面是一个例子。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dv = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>DataView实例有以下属性，含义与TypedArray实例的同名方法相同。</p>\n<ul>\n<li>DataView.prototype.buffer：返回对应的ArrayBuffer对象</li>\n<li>DataView.prototype.byteLength：返回占据的内存字节长度</li>\n<li>DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始</li>\n</ul>\n<p>DataView实例提供8个方法读取内存。</p>\n<ul>\n<li>getInt8：读取1个字节，返回一个8位整数。</li>\n<li>getUint8：读取1个字节，返回一个无符号的8位整数。</li>\n<li>getInt16：读取2个字节，返回一个16位整数。</li>\n<li>getUint16：读取2个字节，返回一个无符号的16位整数。</li>\n<li>getInt32：读取4个字节，返回一个32位整数。</li>\n<li>getUint32：读取4个字节，返回一个无符号的32位整数。</li>\n<li>getFloat32：读取4个字节，返回一个32位浮点数。</li>\n<li>getFloat64：读取8个字节，返回一个64位浮点数。</li>\n</ul>\n<p>这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dv = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第1个字节读取一个8位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v1 = dv.getUint8(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第2个字节读取一个16位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v2 = dv.getUint16(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第4个字节读取一个16位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v3 = dv.getUint16(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。</p>\n<p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 小端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">1</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(1, true)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 大端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">2</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(3, false)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 大端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">3</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(3)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>DataView视图提供8个方法写入内存。</p>\n<ul>\n<li>setInt8：写入1个字节的8位整数。</li>\n<li>setUint8：写入1个字节的8位无符号整数。</li>\n<li>setInt16：写入2个字节的16位整数。</li>\n<li>setUint16：写入2个字节的16位无符号整数。</li>\n<li>setInt32：写入4个字节的32位整数。</li>\n<li>setUint32：写入4个字节的32位无符号整数。</li>\n<li>setFloat32：写入4个字节的32位浮点数。</li>\n<li>setFloat64：写入8个字节的64位浮点数。</li>\n</ul>\n<p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在第1个字节，以大端字节序写入值为25的32位整数</span></span><br><span class=\"line\">dv.setI<span class=\"symbol\">nt32</span><span class=\"comment\">(0, 25, false)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第5个字节，以大端字节序写入值为25的32位整数</span></span><br><span class=\"line\">dv.setI<span class=\"symbol\">nt32</span><span class=\"comment\">(4, 25)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第9个字节，以小端字节序写入值为2.5的32位浮点数</span></span><br><span class=\"line\">dv.setFloat<span class=\"number\">32</span><span class=\"comment\">(8, 2.5, true)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> littleEndian = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(buffer).setInt16(<span class=\"number\">0</span>, <span class=\"number\">256</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Int16Array</span>(buffer)[<span class=\"number\">0</span>] === <span class=\"number\">256</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob\"></a>Blob</h4><p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>\n<p>要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，请参阅 File文档。</p>\n<p>从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reader = <span class=\"keyword\">new</span> <span class=\"constructor\">FileReader()</span>;</span><br><span class=\"line\">reader.add<span class=\"constructor\">EventListener(<span class=\"string\">&quot;loadend&quot;</span>, <span class=\"params\">function</span>()</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// reader.result 包含转化为类型数组的blob</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">reader.read<span class=\"constructor\">AsArrayBuffer(<span class=\"params\">blob</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>更多关于Blob的内容，请直接查看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\">这里</a></p>\n<h3 id=\"数据格式转换\"><a href=\"#数据格式转换\" class=\"headerlink\" title=\"数据格式转换\"></a>数据格式转换</h3><h4 id=\"String转Blob\"><a href=\"#String转Blob\" class=\"headerlink\" title=\"String转Blob\"></a>String转Blob</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串 转换成 Blob 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&quot;Hello World!&quot;</span>], &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;text/plain&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.info(blob);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.info(blob.slice(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"string\">&#x27;text/plain&#x27;</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"TypeArray转Blob\"><a href=\"#TypeArray转Blob\" class=\"headerlink\" title=\"TypeArray转Blob\"></a>TypeArray转Blob</h4><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将 TypeArray  转换成 Blob 对象</span></span><br><span class=\"line\">var <span class=\"built_in\">array</span> = <span class=\"keyword\">new</span> <span class=\"constructor\">Uint16Array([97, 32, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])</span>;</span><br><span class=\"line\"><span class=\"comment\">//测试成功</span></span><br><span class=\"line\"><span class=\"comment\">//var blob = new Blob([array], &#123; type: &quot;application/octet-binary&quot; &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">//测试成功， 注意必须[]的包裹</span></span><br><span class=\"line\">var blob = <span class=\"keyword\">new</span> <span class=\"constructor\">Blob([<span class=\"params\">array</span>])</span>;</span><br><span class=\"line\"><span class=\"comment\">//将 Blob对象 读成字符串</span></span><br><span class=\"line\">var reader = <span class=\"keyword\">new</span> <span class=\"constructor\">FileReader()</span>;</span><br><span class=\"line\">reader.read<span class=\"constructor\">AsText(<span class=\"params\">blob</span>, &#x27;<span class=\"params\">utf</span>-8&#x27;)</span>;</span><br><span class=\"line\">reader.onload = <span class=\"keyword\">function</span> (e) &#123;</span><br><span class=\"line\">    console.info(reader.result); <span class=\"comment\">//a Hello world!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayBuffer转Blob\"><a href=\"#ArrayBuffer转Blob\" class=\"headerlink\" title=\"ArrayBuffer转Blob\"></a>ArrayBuffer转Blob</h4><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> <span class=\"type\">Blob</span>([buffer]);       <span class=\"comment\">// 注意必须包裹[]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Blob转String\"><a href=\"#Blob转String\" class=\"headerlink\" title=\"Blob转String\"></a>Blob转String</h4><p>这里需要注意的是readAsText方法的使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串转换成 Blob对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&#x27;中文字符串&#x27;</span>], &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;text/plain&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//将Blob 对象转换成字符串</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.readAsText(blob, <span class=\"string\">&#x27;utf-8&#x27;</span>);</span><br><span class=\"line\">reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(reader.result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Blob转ArrayBuffer\"><a href=\"#Blob转ArrayBuffer\" class=\"headerlink\" title=\"Blob转ArrayBuffer\"></a>Blob转ArrayBuffer</h4><p>这里需要注意的是readAsArrayBuffer方法的使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串转换成 Blob对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&#x27;中文字符串&#x27;</span>], &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;text/plain&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//将Blob 对象转换成 ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.readAsArrayBuffer(blob);</span><br><span class=\"line\">reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//ArrayBuffer &#123;&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//经常会遇到的异常 Uncaught RangeError: byte length of Int16Array should be a multiple of 2</span></span><br><span class=\"line\">    <span class=\"comment\">//var buf = new int16array(reader.result);</span></span><br><span class=\"line\">    <span class=\"comment\">//console.info(buf);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将 ArrayBufferView  转换成Blob</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(reader.result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(buf); <span class=\"comment\">//[228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]</span></span><br><span class=\"line\">    reader.readAsText(<span class=\"keyword\">new</span> Blob([buf]), <span class=\"string\">&#x27;utf-8&#x27;</span>);</span><br><span class=\"line\">    reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//中文字符串</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将 ArrayBufferView  转换成Blob</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(reader.result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(buf); <span class=\"comment\">//DataView &#123;&#125;</span></span><br><span class=\"line\">    reader.readAsText(<span class=\"keyword\">new</span> Blob([buf]), <span class=\"string\">&#x27;utf-8&#x27;</span>);</span><br><span class=\"line\">    reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//中文字符串</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckxijpqs90001d3mr64xf3q7l","tag_id":"ckxijpqsf0004d3mr4dsi6brc","_id":"ckxijpqsm000ed3mre7v4dten"},{"post_id":"ckxijpqs90001d3mr64xf3q7l","tag_id":"ckxijpqsj0009d3mrakd308th","_id":"ckxijpqso000gd3mr6sog6ead"},{"post_id":"ckxijpqsd0003d3mrhq8s68gy","tag_id":"ckxijpqsl000cd3mrc6mb7rsf","_id":"ckxijpqsr000jd3mrbr6k5a55"},{"post_id":"ckxijpqsh0006d3mr3x61eyny","tag_id":"ckxijpqsf0004d3mr4dsi6brc","_id":"ckxijpqsv000qd3mr3o7h9laz"},{"post_id":"ckxijpqsh0006d3mr3x61eyny","tag_id":"ckxijpqss000ld3mrfjg8gsxw","_id":"ckxijpqsw000sd3mr52vg762d"},{"post_id":"ckxijpqsi0007d3mrhsowbqek","tag_id":"ckxijpqsu000od3mra07d9qw7","_id":"ckxijpqsx000vd3mr688bg0qp"},{"post_id":"ckxijpqsj0008d3mrdjfx870h","tag_id":"ckxijpqsx000ud3mrhbgzbqxl","_id":"ckxijpqt10013d3mr0gys5opd"},{"post_id":"ckxijpqsj0008d3mrdjfx870h","tag_id":"ckxijpqsz000yd3mraoe594jh","_id":"ckxijpqt20015d3mrdm206dm0"},{"post_id":"ckxijpqt00010d3mra91kfmla","tag_id":"ckxijpqsu000od3mra07d9qw7","_id":"ckxijpqt30018d3mr8x9r6813"},{"post_id":"ckxijpqsk000ad3mrbcp46vj1","tag_id":"ckxijpqt00011d3mrh9ecdi79","_id":"ckxijpqt4001cd3mrbazhb0g5"},{"post_id":"ckxijpqsk000ad3mrbcp46vj1","tag_id":"ckxijpqss000ld3mrfjg8gsxw","_id":"ckxijpqt5001ed3mr0h9j6sru"},{"post_id":"ckxijpqsl000bd3mrefh84cfi","tag_id":"ckxijpqt3001ad3mr1clo8gkk","_id":"ckxijpqt6001hd3mrbcibdbpt"},{"post_id":"ckxijpqsm000dd3mrdymvgz7c","tag_id":"ckxijpqt6001gd3mrddcy6cou","_id":"ckxijpqt9001jd3mr2fes1onw"},{"post_id":"ckxijpqsn000fd3mrekp5c9f6","tag_id":"ckxijpqsf0004d3mr4dsi6brc","_id":"ckxijpqt9001ld3mrcxbg03r1"},{"post_id":"ckxijpqsn000fd3mrekp5c9f6","tag_id":"ckxijpqt9001id3mr8vi0eqye","_id":"ckxijpqt9001md3mrdv131eqb"},{"post_id":"ckxijpqsq000id3mr32gaa9oo","tag_id":"ckxijpqt9001kd3mreqmuhbi1","_id":"ckxijpqta001od3mrezl8e08d"},{"post_id":"ckxijpqsr000kd3mr0pjn8426","tag_id":"ckxijpqsu000od3mra07d9qw7","_id":"ckxijpqta001qd3mr41mg8ngn"},{"post_id":"ckxijpqst000md3mr4xlc87h0","tag_id":"ckxijpqta001pd3mrbsx28b6b","_id":"ckxijpqtb001sd3mrhkp19i2r"},{"post_id":"ckxijpqst000nd3mraqkzfdrg","tag_id":"ckxijpqta001rd3mrd53e0uox","_id":"ckxijpqtc001ud3mr2k2w4ma6"},{"post_id":"ckxijpqsv000pd3mrbtcv3ryi","tag_id":"ckxijpqsu000od3mra07d9qw7","_id":"ckxijpqtc001wd3mr17uv4gsk"},{"post_id":"ckxijpqsv000rd3mrb8qnd4id","tag_id":"ckxijpqtc001vd3mrerpx8vv6","_id":"ckxijpqtd001yd3mrhte6do3p"},{"post_id":"ckxijpqsw000td3mrfo133gi8","tag_id":"ckxijpqss000ld3mrfjg8gsxw","_id":"ckxijpqtd0020d3mr3tat1fdr"},{"post_id":"ckxijpqsw000td3mrfo133gi8","tag_id":"ckxijpqsu000od3mra07d9qw7","_id":"ckxijpqtd0021d3mrbblodft7"},{"post_id":"ckxijpqsw000td3mrfo133gi8","tag_id":"ckxijpqtc001xd3mrc1dxgngn","_id":"ckxijpqte0023d3mrblw3bsg9"},{"post_id":"ckxijpqsx000wd3mr703s9xc4","tag_id":"ckxijpqtd001zd3mr8nu8azq1","_id":"ckxijpqte0024d3mrg3jceup7"},{"post_id":"ckxijpqsy000xd3mr42lnfyrt","tag_id":"ckxijpqtd0022d3mr1rjr5xba","_id":"ckxijpqte0026d3mrb3zgav19"},{"post_id":"ckxijpqsz000zd3mrfl89hrho","tag_id":"ckxijpqte0025d3mr9w4nete6","_id":"ckxijpqtf0028d3mragt9c8hf"},{"post_id":"ckxijpqt00012d3mrgbxfevmn","tag_id":"ckxijpqte0027d3mr2x96ap7y","_id":"ckxijpqtf002ad3mrh79hga6b"},{"post_id":"ckxijpqt10014d3mr1zaj12qf","tag_id":"ckxijpqtf0029d3mr2mmu3qcc","_id":"ckxijpqtf002cd3mrbkkr59a8"},{"post_id":"ckxijpqt20017d3mr274bheky","tag_id":"ckxijpqtf002bd3mr64sh78o2","_id":"ckxijpqtg002ed3mra5habpcw"},{"post_id":"ckxijpqt30019d3mr67z23f5t","tag_id":"ckxijpqtf002dd3mr26322i9w","_id":"ckxijpqtg002gd3mrh77fgi45"},{"post_id":"ckxijpqt4001bd3mr1w23fgri","tag_id":"ckxijpqtg002fd3mr0oad1jkd","_id":"ckxijpqth002jd3mr8gm11wpd"},{"post_id":"ckxijpqt4001bd3mr1w23fgri","tag_id":"ckxijpqtg002hd3mraynahis3","_id":"ckxijpqth002kd3mr3xrg0mew"},{"post_id":"ckxijpqt5001dd3mrbmrndyrj","tag_id":"ckxijpqtf002dd3mr26322i9w","_id":"ckxijpqth002md3mre7bq84w7"},{"post_id":"ckxijpqt5001fd3mr2m8e7y03","tag_id":"ckxijpqth002ld3mr224k9v0a","_id":"ckxijpqth002nd3mr0f35ezqg"},{"post_id":"ckxijpqtm002od3mrhbdofwqa","tag_id":"ckxijpqsl000cd3mrc6mb7rsf","_id":"ckxijpqto002qd3mr2zg4072d"},{"post_id":"ckxijpqto002rd3mr6y78h5k0","tag_id":"ckxijpqsu000od3mra07d9qw7","_id":"ckxijpqtp002td3mr7mszbmme"},{"post_id":"ckxijpqtn002pd3mr71jueqtf","tag_id":"ckxijpqsu000od3mra07d9qw7","_id":"ckxijpqtq002ud3mrewjuhzud"},{"post_id":"ckxijpqtn002pd3mr71jueqtf","tag_id":"ckxijpqtp002sd3mr7u88em76","_id":"ckxijpqtq002vd3mrfmfcel21"}],"Tag":[{"name":"centOS","_id":"ckxijpqsf0004d3mr4dsi6brc"},{"name":"redis","_id":"ckxijpqsj0009d3mrakd308th"},{"name":"前端框架","_id":"ckxijpqsl000cd3mrc6mb7rsf"},{"name":"Node.js","_id":"ckxijpqss000ld3mrfjg8gsxw"},{"name":"javascript","_id":"ckxijpqsu000od3mra07d9qw7"},{"name":"Linux","_id":"ckxijpqsx000ud3mrhbgzbqxl"},{"name":"ssh","_id":"ckxijpqsz000yd3mraoe594jh"},{"name":"TCP","_id":"ckxijpqt00011d3mrh9ecdi79"},{"name":"Rust","_id":"ckxijpqt3001ad3mr1clo8gkk"},{"name":"PWA","_id":"ckxijpqt6001gd3mrddcy6cou"},{"name":"nginx","_id":"ckxijpqt9001id3mr8vi0eqye"},{"name":"git","_id":"ckxijpqt9001kd3mreqmuhbi1"},{"name":"前端构建","_id":"ckxijpqta001pd3mrbsx28b6b"},{"name":"跨端融合","_id":"ckxijpqta001rd3mrd53e0uox"},{"name":"react","_id":"ckxijpqtc001vd3mrerpx8vv6"},{"name":"Rx.js","_id":"ckxijpqtc001xd3mrc1dxgngn"},{"name":"OpenCV","_id":"ckxijpqtd001zd3mr8nu8azq1"},{"name":"rust","_id":"ckxijpqtd0022d3mr1rjr5xba"},{"name":"WebAssembly","_id":"ckxijpqte0025d3mr9w4nete6"},{"name":"组件化","_id":"ckxijpqte0027d3mr2x96ap7y"},{"name":"前端综合","_id":"ckxijpqtf0029d3mr2mmu3qcc"},{"name":"MVVM","_id":"ckxijpqtf002bd3mr64sh78o2"},{"name":"性能优化","_id":"ckxijpqtf002dd3mr26322i9w"},{"name":"Vue","_id":"ckxijpqtg002fd3mr0oad1jkd"},{"name":"viola","_id":"ckxijpqtg002hd3mraynahis3"},{"name":"ShadowSocks","_id":"ckxijpqth002ld3mr224k9v0a"},{"name":"前端监控","_id":"ckxijpqtp002sd3mr7u88em76"}]}}